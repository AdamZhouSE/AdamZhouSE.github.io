{"meta":{"title":"Blog of Adam Zhou","subtitle":"Art is long, but life is short.","description":"把全盛的爱都活过 把全盛的我都活过","author":"ZZY","url":"https://adamzhouse.github.io","root":"/"},"pages":[{"title":"About me","date":"2020-04-02T05:26:58.000Z","updated":"2020-04-06T09:53:08.123Z","comments":false,"path":"about/index.html","permalink":"https://adamzhouse.github.io/about/index.html","excerpt":"","text":"2020 开了博客，好好学习，多写文章，做一条有梦想的咸鱼！ 2018 南京大学软件工程本科"},{"title":"Category","date":"2020-04-01T14:21:43.000Z","updated":"2020-04-06T08:22:33.747Z","comments":false,"path":"categories/index.html","permalink":"https://adamzhouse.github.io/categories/index.html","excerpt":"","text":""},{"title":"Messageboard","date":"2020-04-06T11:34:55.000Z","updated":"2020-04-06T11:38:07.315Z","comments":true,"path":"messageboard/index.html","permalink":"https://adamzhouse.github.io/messageboard/index.html","excerpt":"","text":"欢迎留言~"},{"title":"Projects","date":"2020-04-02T05:29:14.000Z","updated":"2020-04-06T07:41:29.135Z","comments":false,"path":"projects/index.html","permalink":"https://adamzhouse.github.io/projects/index.html","excerpt":"","text":""},{"title":"Tag","date":"2020-04-01T17:35:18.000Z","updated":"2020-04-06T08:22:18.889Z","comments":false,"path":"tags/index.html","permalink":"https://adamzhouse.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo-melody主题扩展","slug":"Hexo-melody主题扩展","date":"2020-04-05T15:13:13.000Z","updated":"2020-04-05T19:41:33.347Z","comments":true,"path":"posts/6663916b.html","link":"","permalink":"https://adamzhouse.github.io/posts/6663916b.html","excerpt":"在搭建博客的时候，在github上逛了不少主题，最符合我审美的就是我现在正在用的melody，不过还是有一些美中不足的地方，但我并没有大佬的水平重新写一个，所以选择在原方案上稍微改动一下，实现一些自己的想法。 建立utterances评论系统 持续更新","text":"在搭建博客的时候，在github上逛了不少主题，最符合我审美的就是我现在正在用的melody，不过还是有一些美中不足的地方，但我并没有大佬的水平重新写一个，所以选择在原方案上稍微改动一下，实现一些自己的想法。 建立utterances评论系统 持续更新 1. 建立utterances评论系统 melody主题一共支持5个评论系统， Disqus：要翻墙，不支持markdown Laibili: 虽然支持的账号多，但是不太稳定，跳转到第三方的网页登录让人没有了评论的欲望 Gitment和Gitalk 这两者要求把GitHub 注册的 OAuth Application 的 Client ID、Client Secret 以明文形式写进前端代码里，这样别人直接查看源代码就可以得到我们的密码，而这是不能够公开的，会有很大的安全隐患，具体可以看这篇博客Gitment 安全性争议 valine：不好看 然后我发现了utterances，也是基于issue建立的，但是控制了权限，不需要读写代码，前端没有要求你填写密码，而是填写你的仓库名，保证安全性，同时也支持markdown语法，而且很好看~~~ 不过melody暂时并不支持这个系统，需要自己手动添加，这个操作并不难。 1.1 安装 首先，进入utterances安装该app，指定博客所在的repo 然后就可以得到需要添加的代码，注意这里src不可以改变，repo是拥有者/仓库名，issue-term和 theme都可以自己指定。 1.2 配置utterances.pug 然后进入themes\\melody\\layout\\includes\\comments目录，新建一个utterances.pug文件，并在里面加入指定的内容，格式如下 if theme.utterances &amp;&amp; theme.utterances.enable script(src=&quot;https://utteranc.es/client.js&quot;,repo=&quot;用户名/仓库名&quot;,issue-term=&apos;title&apos;,label=&apos;utterances&apos;,theme=&apos;github-light&apos;,crossorigin=&apos;anonymous&apos;,async) pug的形式与html稍有不同，可以自行搜索一下，改变成上面的样式就可以了。 这里有个小坑，就是repo里面填的是own/repo，也就是用户名加上仓库名，而不仅仅是仓库名，否则就检索不到了。 1.3 配置index.pug 接着，就是在themes\\melody\\layout\\includes\\comments中，找到index.pug文件，会看到里面许多if-else的结构，把utterances也加上去就行 else if theme.utterances &amp;&amp; theme.utterances.enable include ./utterances.pug 1.4 配置主题配置文件 最后一步，就是在主题配置文件里面加上utterances评论系统啦。 # Utterances# See: https://utteranc.es/utterances: enable: true 因为是自己的小改动，所以我直接在pug文件里面指定了相关内容，就没有像其它评论系统里面写引用，因此这里也只要enable一下就可以了。 1.5 启动","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://adamzhouse.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://adamzhouse.github.io/tags/hexo/"}]},{"title":"概率的定义","slug":"概率的定义","date":"2020-04-05T12:24:12.000Z","updated":"2020-04-06T08:49:24.370Z","comments":true,"path":"posts/5a95beee.html","link":"","permalink":"https://adamzhouse.github.io/posts/5a95beee.html","excerpt":"一、概率的定义 当我们还不能用数学符号描述一件事情，那么说明我们还没有想清楚这件事。 所以，我们需要建立元素到数据的映射 graph LR A[物理世界] -->|映射| B[数据集合]","text":"一、概率的定义 当我们还不能用数学符号描述一件事情，那么说明我们还没有想清楚这件事。 所以，我们需要建立元素到数据的映射 graph LR A[物理世界] -->|映射| B[数据集合] 1. 基本概念 1.1 随机实验 可以在相同的条件下重复进行 每次实验结果不止一个，并且事先明确实验的所有可能结果 进行一次实验前不能够确定那一个结果会出现 例：抛一枚硬币，观察正面H与反面T出现的情况 1.2 样本空间 随机试验EEE的所有可能结果组成的集合称为EEE的样本空间，记为Ω\\OmegaΩ 样本空间中的每个元素，即EEE的每个结果，称为样本点，记为eee 1.3 随机事件 样本空间Ω\\OmegaΩ的任意子集AAA称为随机事件 观察到样本点eee，若e∈Ae\\in Ae∈A，则称这一事件发生。 基本事件：由一个样本点组成的单点集 复合事件：由两个或两个以上样本点组成的集合 必然事件：全集Ω\\OmegaΩ 不可能事件：空集∅\\emptyset∅ 2. 事件的集合运算 包含：A⊂BA\\subset BA⊂B，事件B包含事件A，则事件A发生必然导致事件B发生 相等：A=BA=BA=B，即A⊂BA\\subset BA⊂B且B⊂AB\\subset AB⊂A 和：A⋃BA\\bigcup BA⋃B，即A和B至少有一个发生 差：A−BA-BA−B，即事件A发生且事件B不发生 积：A⋃BA\\bigcup BA⋃B，记作ABABAB，即事件A和事件B都发生 互不相容：AB=∅AB = \\emptysetAB=∅，即A和B不能同时发生 互逆：A⋃B=ΩA\\bigcup B=\\OmegaA⋃B=Ω 且AB=∅AB = \\emptysetAB=∅，A和B互逆，通常B记为A‾\\overline{A}A 2.1 复杂事件的集合运算 A发生而B和C都不发生：AB‾C‾=A−B−C=A−(B⋃C)A\\overline{B} \\overline{C}=A-B-C=A-(B\\bigcup C)ABC=A−B−C=A−(B⋃C) A与B都发生而C不发生：ABC‾=AB−C=AB−ABCAB\\overline{C}=AB-C=AB-ABCABC=AB−C=AB−ABC 三个事件都发生：ABCABCABC 三个事件恰好有一个发生：AB‾C‾+A‾BC‾+A‾B‾CA\\overline{B}\\overline{C}+\\overline{A}B\\overline{C}+\\overline{A}\\overline{B}CABC+ABC+ABC 三个事件至少发生一个：A⋃B⋃CA\\bigcup B\\bigcup CA⋃B⋃C 2.2 常用定律 交换律 结合律 分配率：A ⋃ (B⋂C)=(A⋃B)⋂(A⋃C)A\\, \\bigcup \\,(B\\bigcap C)=(A\\bigcup B)\\bigcap (A\\bigcup C)A⋃(B⋂C)=(A⋃B)⋂(A⋃C) A ⋂ (B⋃C)=(A⋂B) ⋃ (A⋂C)A\\, \\bigcap \\,(B\\bigcup C)=(A\\bigcap B)\\,\\bigcup \\,(A\\bigcap C)A⋂(B⋃C)=(A⋂B)⋃(A⋂C) 德摩根定律：A⋃B‾=A‾⋂B‾\\overline{A\\bigcup B}=\\overline{A}\\bigcap\\overline{B}A⋃B​=A⋂B A⋂B‾=A‾⋃B‾\\overline{A\\bigcap B}=\\overline{A}\\bigcup\\overline{B}A⋂B​=A⋃B 3. 频率 描述了事件发生的频繁程度 定义 重复观察n次事件A发生的次数nAn_AnA​称为A的频数 比值nAn\\frac{n_A}{n}nnA​​称为事件A发生的频率，并记为fn(A)f_n(A)fn​(A) 性质 0 ≤ fn(A) ≤ 10\\,\\leq\\, f_n(A)\\, \\leq\\, 10≤fn​(A)≤1 fn(Ω)=1f_n(\\Omega)=1fn​(Ω)=1 若A1,⋯ ,AkA_1,\\cdots,A_kA1​,⋯,Ak​两两互不相容，则 fn(A1 ⋃ ⋯⋃ Ak)=fn(A1)+⋯+fn(Ak)f_n(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=f_n(A_1)+\\cdots+f_n(A_k)fn​(A1​⋃⋯⋃Ak​)=fn​(A1​)+⋯+fn​(Ak​) 收敛性 当n足够大，fn(A)f_n(A)fn​(A)收敛于某个常数，这个常数就是概率（证明见后续） 我们应该都听说过德摩根抛硬币的故事，对一个事件进行大量的实验可以得到频率，但是我们不可能对所有事件都做类似的事情，所以就有了概率 4. 概率 表征事件发生的可能性大小 定义 Ω\\OmegaΩ为样本空间，对于每一事件A赋予一实数P(A)P(A)P(A)，若P(A)满足下列条件则被称为概率： 非负性：0≤P(A)≤10\\leq P(A)\\leq 10≤P(A)≤1 规范性：P(Ω)=1P(\\Omega)=1P(Ω)=1 可列可加性：A1,⋯ ,AnA_1,\\cdots,A_nA1​,⋯,An​互不相容，则P(A1 ⋃ ⋯⋃ Ak)=P(A1)+⋯+P(Ak)P(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=P(A_1)+\\cdots+P(A_k)P(A1​⋃⋯⋃Ak​)=P(A1​)+⋯+P(Ak​) 性质 P(∅)=0P(\\empty)=0P(∅)=0 P(A‾)=1−P(A)P(\\overline{A})=1-P(A)P(A)=1−P(A) 若A⊂BA\\sub BA⊂B，则有P(A)≤P(B),P(B−A)=P(B)−P(A)P(A)\\leq P(B),\\quad P(B-A)=P(B)-P(A)P(A)≤P(B),P(B−A)=P(B)−P(A) 对于任意两个事件A和B，P(A⋃B)=P(A)+P(B)−P(A+B)P(A\\bigcup B)=P(A)+P(B)-P(A+B)P(A⋃B)=P(A)+P(B)−P(A+B) 4.1 古典概型(等可能概型) 定义 若Ω\\OmegaΩ是**有限样本空间，其样本点为e1,⋯ene_1,\\cdots e_ne1​,⋯en​，在有限样本空间中引进概率。 1/n称为事件{ei}\\{e_i\\}{ei​}的概率，记为P({ei})P(\\{e_i\\})P({ei​}) P({e1})+⋯+P({en})=P(Ω)=1P(\\{e_1\\})+\\cdots +P(\\{e_n\\})=P(\\Omega)=1P({e1​})+⋯+P({en​})=P(Ω)=1 从定义中不难发现古典概型的两个特点： 样本空间包含有限个元素 试验中每个基本事件发生的可能性相同 注：基本事件是两两不相容的 若事件A包含k个基本事件，则有 P(A)=∑i=1kP({eik})=knP(A)=\\sum_{i=1}^kP(\\{e_{i_k}\\})=\\frac{k}{n} P(A)=i=1∑k​P({eik​​})=nk​ 4.2 几何概型 数据从有限集合推广到无限集合 例：约会问题 两人约定7点到8点在某地会面，先到者等候另一人20分钟，过时就离去，试求这两人会面的概率。 解：以x,yx,yx,y分别表示两人到达的时刻，则会面的充要条件为∣x−y∣≤20|x-y|\\leq20∣x−y∣≤20，这就是一个几何概率的问题，可能的结果全体是边长60的正方形里面的点，结果为 P(A)=602−402602P(A)=\\frac{60^2-40^2}{60^2} P(A)=602602−402​ 从上面的例子不难看出，样本空间从原来的有限的个数，变成了无限的点。 如果要在半径为1的圆内随机地取一条弦，问弦长超过3\\sqrt{3}3​的概率是多少？ 3种思路有3种不同的答案 在数据映射中，我们需要遵循物理世界到数据集合的某种结构保持","categories":[{"name":"数据科学基础","slug":"数据科学基础","permalink":"https://adamzhouse.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"name":"概率论","slug":"数据科学基础/概率论","permalink":"https://adamzhouse.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/%E6%A6%82%E7%8E%87%E8%AE%BA/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://adamzhouse.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"字符串,向量和数组","slug":"字符串-向量和数组","date":"2020-04-03T14:03:24.000Z","updated":"2020-04-05T04:13:32.132Z","comments":true,"path":"posts/869e4b19.html","link":"","permalink":"https://adamzhouse.github.io/posts/869e4b19.html","excerpt":"二、字符串，向量和数组 作用域操作符:: 含义：编译器应从操作符左侧的作用域中寻找右边那个名字 比如std::cin是要使用命名空间std中的cin 这样做是为了避免某些名字被重复使用 使用using声明可以更加简便的使用命名空间中的成员。","text":"二、字符串，向量和数组 作用域操作符:: 含义：编译器应从操作符左侧的作用域中寻找右边那个名字 比如std::cin是要使用命名空间std中的cin 这样做是为了避免某些名字被重复使用 使用using声明可以更加简便的使用命名空间中的成员。 1. String类型 表示可变长的字符串 1.1 定义和初始化 使用需要头文件和命名空间 #include&lt;string&gt;using std::string; 初始化 string s1; // 空字符串string s2 = s1; // s2是s1的副本string s3 = \"abc\";string s4(10, 'c'); // 十个c 1.2 string对象上的操作 使用getline读取一整行 string line;getline(cin, line); 当读取到换行符时结束，并将读到的内容存入string中，但是不存换行符 empty和size操作 str.empty()根据字符串是否为空返回一个布尔值 str.size()返回字符串长度 使用visual studio编程的时候，碰到过一个warning，将无符号数赋值给了有符号数。 这是由于size函数的返回值类型引起的，它是一个string::size_type类型的值，是无符号类型的， 可以用auto来推断变量的值 auto len = str.size(); 比较，赋值，相加 string s1 = \"abc\";string s2 = \"xcvd\";// s1 &lt; s2 比较第一个不同的字符string s3 = s1; // 赋值string s4 = s1 + s2; // abcxcvd 处理string中的字符 #include&lt;cctype&gt;isalnum(c);isalpha(c);islower(c);isupper(c);ispunct(c); // 是标点符号为真 2. Vector类型 可变长数组，类似于Java中的ArrayList 2.1 初始化 vector&lt;T&gt; v;vector&lt;T&gt; v1 = &#123;a, b, c&#125;; // 注意是花括号vector&lt;T&gt; v2&#123;a, b&#125;; // 花括号，两个元素vector&lt;int&gt; v3(10, 1); // 圆括号 10个元素，每个初始化为1 2.2 操作 vector&lt;int&gt; v;v.push_back(1); // 添加1v.pop_back(); // 去掉最后一个数据v.empty();v.size();v[n]; // 注意下标只能访问，但是不能够添加元素 3. 迭代器 访问元素的作用 string s = \"abcde\";if (s.begin() != s.end()) &#123; // 确保s非空 &#125; 4. 数组 4.1 指针和数组 int ia[] = &#123;1, 2, 3, 4, 5&#125;;auto p(ia); // 整型指针，指向ia的第一个元素p++; // 指向第一个元素","categories":[{"name":"C++","slug":"C","permalink":"https://adamzhouse.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://adamzhouse.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://adamzhouse.github.io/tags/C/"}]},{"title":"Hexo-Permalink简化","slug":"Hexo-Permalink简化","date":"2020-04-03T12:59:43.000Z","updated":"2020-04-04T14:45:26.611Z","comments":true,"path":"posts/838443af.html","link":"","permalink":"https://adamzhouse.github.io/posts/838443af.html","excerpt":"Permalink简化 在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章 阮一峰 关于url编码 有两种方法优化。","text":"Permalink简化 在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章 阮一峰 关于url编码 有两种方法优化。 方法一：自定义 首先，在scaffolds的post.md中，加入urlname元素。 title: &#123;&#123; title &#125;&#125;urlname:date: &#123;&#123; date &#125;&#125;tags:categories: 然后，在配置文件_config.yml中，将永久链接permalink的形式改为 permalink: :category/:urlname/ 也就是类别加上自定义的url链接。 每次写文章时，可以自己设计该页的url，使得它变得简单，同时也利于区分。 但是，这种修改方法的链接会随着文件目录的改变而改变， 比如一篇文章HelloWorld.md本来放在_posts目录下，链接为https://xxx/_posts/HelloWorld.md 之后归类到_posts/A目录下，那么链接变为https://xxx/_posts/A/HelloWorld.md 这样不太利于分享，所以推荐使用第二种方法。 方法二：插件 使用hexo-abbrlink这个插件 安装 npm install hexo-abbrlink --save 设置 在_config.yml文件中修改永久链接格式 permalink: posts/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex posts部分是可以更改的，也可以仿照方法一添加一个关键词便于识别 permalink: :keywords/:abbrlink.html 生成 在根目录创建Gruntfile.js文件，让插件到source/_posts/下读取所有的.md文件，把文件中的@@abbrlink替换成文件内容的hash值。 module.exports = function(grunt) &#123; grunt.initConfig(&#123; rewrite: &#123; abbrlink: &#123; src: 'source/_posts/**/*.md', editor: function(contents, filepath)&#123; const crypto = require('crypto'); const hash = crypto.createHash('sha256'); hash.update(contents); var hashValue = hash.digest('hex'); return contents.replace(/@@abbrlink/g, hashValue.substring(0, 16)); &#125; &#125;, &#125;, &#125;); grunt.loadNpmTasks('grunt-rewrite');&#125;; 这种方法生成的链接是不带目录的，直接就是第二步设置中permalink的样式，所以也没有了被改变的风险。 参考 http://blog.jvaeyhcd.wang/posts/05c9df7e0c47bd64.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://adamzhouse.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://adamzhouse.github.io/tags/hexo/"}]},{"title":"变量和基本类型","slug":"变量和基本类型","date":"2020-04-03T12:44:47.000Z","updated":"2020-04-04T14:44:34.579Z","comments":true,"path":"posts/96db5496.html","link":"","permalink":"https://adamzhouse.github.io/posts/96db5496.html","excerpt":"变量和基本类型 1. 复合类型(Compound type) 基于其它类型定义的类型 1.1 引用(Reference) 引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。","text":"变量和基本类型 1. 复合类型(Compound type) 基于其它类型定义的类型 1.1 引用(Reference) 引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。 (在这里，引用指的是左值引用) int ival = 1024;int &amp;refval = ival; // refval指向ival，是ival的另外一个名字int &amp;refVal2; // 报错；引用必须被初始化 定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。（与初始化变量时不同的） 无法令引用重新绑定到另一个对象，所以引用必须被初始化 引用即别名，它不是对象，而是为了一个已经存在的对象起了另外一个名字 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的 refVal = 2; // 把2赋值给与refVal绑定的对象上，这里就是绑定到iVal上int ii = refVal; 除了两种特殊情况，其它所有引用的类型都要与之绑定的对象严格匹配。不能够与字面值或表达式的计算结果绑定。 int &amp;refVal4 = 10; // 错误：引用对象初始值必须是一个对象double dval = 3.14;int &amp;refVal5 = dval; // 错误：此处引用类型的初始值必须是int型对象 1.2 指针 指针是指向另外一种类型的符合类型，与引用类似，指针实现了对其它对象的间接访问。 不同： 指针本身是一个对象 指针无需在定义时赋初值 int *ip1; // ip1是指向int对象的指针 获取对象的地址 指针存放某个对象的地址。 int ival = 42;int *p = &amp;ival; // p是存放变量ival的地址，或者说p是指向引用的指针。 指针值 指针的值（即地址）应该属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针 无效指针 利用指针访问对象 如果指针指向了一个对象，可以使用解引用符（操作符*）来访问对象 int ival = 42;int *p = &amp;ival;cout &lt;&lt; *p // 输出42*p = 0;cout &lt;&lt; *p // 输出0，为*p赋值实际上是为p所指的对象赋值 空指针 int *p1 = nullptr;int *p2 = 0;int *p3 = NULL; // 需要头文件cstdlib void*指针 用于存放任意对象的地址，不能直接操作void*指针所指的对象 指向指针的指针 指向指针的引用 指针是对象，所以存在对指针的引用 int i = 42;int *p;int *&amp;r = p; // r是一个对p的引用r = &amp;i; // r引用了一个指针，因此给r赋值&amp;就是令p指向i*r = 0; // 将i的值改为0 2. const限定符 值不能被改变，所以const对象必须被初始化 const int bufSize = 512; // 输入缓冲区大小 如果要在多个文件之间共享const，必须在变量定义前加extern关键字 2.1 对const的引用 对常量的引用，不能够修改其绑定的对象 对const的引用可以使一个并非const的对象，但是不能通过其改变值 const int ci = 1024;const int &amp;r1 = ci; // 正确r1 = 42; // 错误：r1是对常量的引用int &amp;r2 = ci; // 错误：非常量引用指向一个常量对象int i = 42；const int &amp;r1 = i; // 允许将const int&amp;绑定到一个普通的int上r1 = 10; // 错误 3. 处理类型 3.1 类型别名 某种类型的同义词，使得复杂的类型名字变得简单，易于理解和使用。 typedef double wages; // wages是double的同义词using SI = Sales_item; // SI是Sales_item的同义词 3.2 auto类型说明符 让编译器分析表达式所属的类型，必须有初始值 auto item = val1 + val2; // 由val1和val2相加的结果推断item的类型// auto一条声明语句只能有一个基础数据类型auto i = 0, *p = &amp;i; // 正确auto sz = 0, pi = 3.14; // 错误，sz和pi的类型不一致 4. 自定义数据结构 将一组相关的数据元素组织起来然后使用他们的策略和方法 struct Sales_data &#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0;&#125;Sales_data accum;","categories":[{"name":"C++","slug":"C","permalink":"https://adamzhouse.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://adamzhouse.github.io/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://adamzhouse.github.io/tags/C/"}]},{"title":"Head First Pattern读书笔记(一)","slug":"Head-First-Pattern读书笔记-一","date":"2020-04-02T06:37:55.000Z","updated":"2020-04-04T14:44:00.687Z","comments":true,"path":"posts/9883ff8.html","link":"","permalink":"https://adamzhouse.github.io/posts/9883ff8.html","excerpt":"Head First 设计模式 读书笔记 本文介绍了策略模式","text":"Head First 设计模式 读书笔记 本文介绍了策略模式 一、 设计模式入门 如果有一个鸭子的类如下 class Duck &#123; quack(); swim(); dispaly(); // 每一种鸭子不同，display()抽象 // 其它方法&#125; 现在需要增加一个功能，让鸭子会飞。 如果直接添加一个fly()方法，则所有子类都具备该方法，那么会出现会飞的橡皮鸭。 涉及维护问题，为了&quot;复用&quot;目的而使用继承，并不合适 可能的解决方案： 继承：把在橡皮鸭的fly()方法覆盖 问题：如果再加入诱饵鸭，不会飞也不会叫，每次更新加入更多的鸭子…… 于是每当有新的子类，就要检查fly()方法 我们发现了以下缺点 代码在多个子类中重复 运行时的状态不易改变 很难知道所有鸭子的行为 改变会牵一发而动全身，造成不想要的改变 接口：把fly()从超类中取出，放入Flyable接口，使得会飞的鸭子实现接口。 问题：重复代码变多，代码无法复用（如果有100个duck子类都要修改飞行的行为？？？） 1. 软件开发的不变真理——改变 不管一开始软件设计的有多好，一段时间后，总是需要成长和改变。 2. 设计模式入门 继承的问题：让所有鸭子都有某些行为，不恰当 接口的问题：Java接口不具有实现代码，所以继承接口无法实现代码的复用。修改量大。 解决方案 设计原则 找到可能需要变化的地方，独立出来，不要和不需要变化的代码混在一起。 把会变化的部分取出封装起来，改动和扩充时不会影响不需要变化的部分。 核心：系统中某部分的改变不影响其他部分 结果：改动引起的可能错误减少，系统更有弹性 分开变化和不会变化的部分 对于Duck，分离fly与quack，建立两组类，分别实现各自的动作 比如一组类中可以有“呱呱叫”，“吱吱叫”，“安静” 设计鸭子的行为 一切要由弹性。鸭子类中包含设定行为的方法，这样可以动态的改变实例的行为 设计原则 针对接口编程，而不是针对实现编程 利用接口代表每个行为，由行为类而不是Duck类实现行为接口 比较： ​ 以前行为来自Duck超类，依赖于实现，无法更改行为 ​ 现在使用接口表是的行为，特定的具体行为编写在了行为类中。 比如，FlyBehavior接口,以及它对应的类，负责实现具体的行为： ​ 实现复用，新增行为不会影响到已有的类 针对接口编程的真正意思是针对超类型编程，这里的接口可以是interface构造，也可以是超类型编程。 关键在于多态。 整合鸭子的行为 动态设定行为 见代码 封装行为的大局观 鸭子的一组行为 --&gt; 一族算法（代表鸭子能做的事） 每一个鸭子都有一个（HAS-A）FlyBehavior和一个QuackBehavior，将飞行和叫声委托给它代为处理。 将两个类结合起来使用——组合 设计原则 多用组合，少用继承 使用继承具有很大的弹性，不仅可以将算法族封装成类，还可以在运行时动态地改变行为。 第一个设计模式：策略模式 定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。 3. 工具 基础 原则 模式 抽象 封装变化 策略模式 封装 多用组合，少用继承 多态 针对接口编程，不针对实现编程 继承","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://adamzhouse.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Strategy","slug":"Strategy","permalink":"https://adamzhouse.github.io/tags/Strategy/"}]},{"title":"使用Github pages+Hexo 搭建个人博客","slug":"使用Github-pages-Hexo-搭建个人博客","date":"2020-04-01T17:56:42.000Z","updated":"2020-04-04T14:45:15.001Z","comments":true,"path":"posts/ae6c038e.html","link":"","permalink":"https://adamzhouse.github.io/posts/ae6c038e.html","excerpt":"Github pages + Hexo 搭建个人博客 2019年11月19日，我决定开始写博客，首先要用github pages+hexo搭建一个个人博客，其中的过程我就记录在这里面。","text":"Github pages + Hexo 搭建个人博客 2019年11月19日，我决定开始写博客，首先要用github pages+hexo搭建一个个人博客，其中的过程我就记录在这里面。 准备工作 注册一个 GitHub 账户 安装 Node.js 下载链接 https://nodejs.org/en/download/ 下面这个是中文网，对于国内用户来说下载速度非常快。 http://nodejs.cn/download/ 推荐菜鸟教程关于node的安装教程以及简易的语法介绍https://www.runoob.com/nodejs/nodejs-install-setup.html 安装git markdown语法学习 https://www.jianshu.com/p/191d1e21f7ed git语法学习 推荐廖雪峰的git教程 https://www.liaoxuefeng.com/wiki/896043488029600 安装 在终端检查node和npm的版本情况 node -vnpm -v 然后输入命令安装hexo npm install -g hexo-cli 我使用的是Mac电脑，在这一步出现了问题，终端显示如下 rollbackFailedOptional verb npm-session 然后我又等了一会儿，终端又报错了。 npm WARN checkPermissions Missing write access to /usr/local/lib/node_modulesnpm ERR! code EACCESnpm ERR! syscall accessnpm ERR! path /usr/local/lib/node_modulesnpm ERR! errno -13npm ERR! Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;npm ERR! [Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;] &#123;npm ERR! stack: &quot;Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;&quot;,npm ERR! errno: -13,npm ERR! code: &apos;EACCES&apos;,npm ERR! syscall: &apos;access&apos;,npm ERR! path: &apos;/usr/local/lib/node_modules&apos;npm ERR! &#125;npm ERR! npm ERR! The operation was rejected by your operating system.npm ERR! It is likely you do not have the permissions to access this file as the current usernpm ERR! npm ERR! If you believe this might be a permissions issue, please double-check thenpm ERR! permissions of the file and its containing directories, or try runningnpm ERR! the command again as root/Administrator. 根据官方文档，如果在尝试安装 Hexo 的过程中出现 EACCES权限错误，要遵循由npmjs发布的指导修复该问题。强烈建议不要使用 root、sudo 等方法覆盖权限。 根据要求，下载了nvm，并且在终端利用nvm下载了最新版本的node和更新了npm后，hexo下载成功了。（以下是下载和使用nvm的教程链接） https://github.com/nvm-sh/nvm. 建站 输入以下命令hexo就会出现在指定的文件夹中 hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 如果出现错误 -bash: syntax error near unexpected token `newline' 这是占位符的问题，将第一行命令的&lt;&gt;去除，再重新输入即可。 到此，建站的基本操作就完成了。 界面的设计等就可以由自己来操作了。放一个hexo的官方网站供大家参考。 https://hexo.io/zh-cn/docs/configuration 创建Github远程仓库 注意仓库名为github的用户名.github.io，勾选readme 创建之后，进入仓库，点击Settings按钮，然后翻到GitHub Pages的部分，点击网页链接，就能够看到一个简易的网页了。 部署hexo 进入本地的hexo文件，找到 _config.yml，打开后翻到最后，修改成 deploy: type: git repo: gitHub: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git branch: master repo后面的内容要修改成自己github仓库的SSH密匙。 然后在终端中输入 npm install hexo-deployer-git --save 开始安装hexo-deploy-git，安装完成后，开始部署，在终端中输入 hexo deploy 部署完成。 测试 这个时候，再次进入刚刚进入过的网页链接，就会看到一个船新版本的界面，也就是本地的hexo库已经部署到github上了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://adamzhouse.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://adamzhouse.github.io/tags/hexo/"}]},{"title":"Hexo写作","slug":"Hexo写作","date":"2020-04-01T15:58:14.000Z","updated":"2020-04-06T03:19:51.155Z","comments":true,"path":"posts/c4064b2b.html","link":"","permalink":"https://adamzhouse.github.io/posts/c4064b2b.html","excerpt":"Hexo写作 本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。","text":"Hexo写作 本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。 1. Hexo基本命令 hexo g = hexo generate #生成hexo s = hexo server #启动本地预览hexo d = hexo deploy #远程部署hexo n \"文章标题\" = hexo new \"文章标题\" #新建一篇博文 2. 整体配置 \\hexo\\_config.yml # Sitetitle: # 网站名，标签页显示subtitle: # 副标题，网站名下显示description: # 网站描述，便于搜索keywords:author: # 作者language: zh-CN # 中文timezone: Asia/Shanghai # 时区 3. 更换主题 推荐使用melody hexo-theme-melody快速开始 这个主题就是我现在网站使用的主题，它有完整的中文教程，功能齐全。按照教程配置就可以了。 4. 写作步骤 新建文章 hexo new \"title\" 写作 \\hexo\\source\\_post中找到title.md，使用typora打开 注意文章的tags格式是[] 在信息栏填写top_img信息可以自定义该页图片情况，如false表示不显示 文章中&lt;!-- more --&gt;之前的部分会显示在主页上，并出现Read more按钮，点击阅读更多内容 预览 hexo s 同步到远程 hexo d -g 5. 问题 Template render error: (unknown path) 在命令行输入hexo -g后报错，原因在于文章内容中有**{}**时，如果它没有被代码块包括，解析会出现错误，所以需要写成 &#123;% raw %&#125; 本地预览与远程显示不一致 删除缓存 hexo clean 在网页上刷新","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://adamzhouse.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://adamzhouse.github.io/tags/hexo/"}]},{"title":"学习cpp","slug":"学习cpp","date":"2020-01-27T03:49:27.000Z","updated":"2020-04-04T02:37:46.759Z","comments":true,"path":"posts/6b599344.html","link":"","permalink":"https://adamzhouse.github.io/posts/6b599344.html","excerpt":"C++学习笔记 本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。","text":"C++学习笔记 本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。 一、 变量 1. 用sizeof运算符求某一类型或变量占据的字节数 #include&lt;iostream&gt;using namespace std;int main() &#123; int a; cout &lt;&lt; sizeof(a) &lt;&lt; endl; // sizeof运算符可以求变量占据的字节数 cout &lt;&lt; a &lt;&lt; endl; // 未初始化的变量，其值是不确定的 int b = 1; cout &lt;&lt; b &lt;&lt; endl;&#125; 2. 数据类型的自动转换 1. 数 int a = 11.34; // 11.34被自动转化为11后赋值给aint b = 30;double d = b; // d的值是30.0 2. 字符类型与整型 int k = 'a';printf(\"%d\", k); // 输出97，即a的ASCII码int n = 98;char k = n;printf(\"%c\", k); // 输出b 3. 输入和输出 1. scanf和printf #include&lt;iostream&gt;#include&lt;cstdio&gt; //使用scanf和printf时需要使用该库int main() &#123; int n; char c; float m; scanf(\"%d%c%f\", &amp;n, &amp;c, &amp;m); printf(\"%d %c %f\\n\", n, c, m); return 0;&#125; 用scanf可以一次读入多个不同类型的变量，输入各项用空格隔开 注意在输入字符时，不会跳过空格（空格也会被当做字符读入） 输入其它数据时，会跳过空格 2. cin和cout #include&lt;iostream&gt;using namespace std;int main() &#123; int c; while ((c=cin.get()) != EOF) &#123; cout &lt;&lt; (char) c; &#125; return 0;&#125; 使用cin读入所有字符，包括空格和回车，EOF Mac（ctrl+D停止输入，ctrl+C停止程序) windows ctrl+Z停止 3. cin&amp;cout / scanf&amp;printf 比较 cin，cout速度慢，输入输出数据量大时用scanf/printf 一个程序不要同时出现cin和scanf，cout和prinf 4. 运算 加、减、乘运算的溢出 二、函数 1. 数组作为函数的参数传递 数组作为函数的参数时，是传引用的，即形参数组改变了，实参数组也会改变 二维数组作为函数的形参时，必须写明函数有多少列，不要写明有多少行 void PrintArray(int a[][5]) &#123; cout &lt;&lt; a[4][3];&#125; 必须要写明列数，编译器才能够根据下标算出元素的地址 $\\color&#123;#F00&#125;&#123;a[i][j]的地址 = 数组首地址 + i \\times N \\times sizeof(a[0][0]) + j \\times sizeof(a[0][0])&#125;$ (N是数组列数) 形参数组的首地址就是实参数组的首地址 三、字符串 1. 字符串的形式 （1）字符串常量 用双引号括起来的，如&quot;China&quot;, “C++ program”. 字符串常量占据内存的字节数等于字符中字符数目加1，结尾多出字符’\\0’. 但是字符串的长度不包含’\\0’ &quot;&quot;也是合法的·1字符串常量，称为空串，仍然占据一个字节的内存空间，存放’\\0’ （2）存放于字符数组中，以’\\0’结尾 用一维char数组存放字符串，结尾是’\\0’，数组元素个数至少为字符串长度+1。 用cin、scanf将字符串读入字符数组时，会自动在字符数组中字符串的末尾加上’\\0’。 （3）string对象。 string是C++标准模板库里的一个类，专门用于处理字符串","categories":[{"name":"C++","slug":"C","permalink":"https://adamzhouse.github.io/categories/C/"},{"name":"basic","slug":"C/basic","permalink":"https://adamzhouse.github.io/categories/C/basic/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://adamzhouse.github.io/tags/C/"}]}],"categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://adamzhouse.github.io/categories/Hexo/"},{"name":"数据科学基础","slug":"数据科学基础","permalink":"https://adamzhouse.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"name":"概率论","slug":"数据科学基础/概率论","permalink":"https://adamzhouse.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"C++","slug":"C","permalink":"https://adamzhouse.github.io/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://adamzhouse.github.io/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://adamzhouse.github.io/categories/Design-Pattern/"},{"name":"basic","slug":"C/basic","permalink":"https://adamzhouse.github.io/categories/C/basic/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://adamzhouse.github.io/tags/hexo/"},{"name":"概率论","slug":"概率论","permalink":"https://adamzhouse.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"C++","slug":"C","permalink":"https://adamzhouse.github.io/tags/C/"},{"name":"Strategy","slug":"Strategy","permalink":"https://adamzhouse.github.io/tags/Strategy/"}]}