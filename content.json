{"meta":{"title":"Blog of Adam","subtitle":"Today is a gift, that is why it is called the present.","description":"Take notes and write articles about Software Engineering","author":"ZZY","url":"https://zhouzhuyan.com","root":"/"},"pages":[{"title":"About me","date":"2020-04-02T05:26:58.000Z","updated":"2020-04-02T05:26:58.000Z","comments":false,"path":"about/index.html","permalink":"https://zhouzhuyan.com/about/index.html","excerpt":"","text":"Introduction 重度b站用户，动漫，日剧，美剧，游戏，时政，生活区，电影，克苏鲁跑团，什么都看一点。 正在练习长跑，目标是跑一次半马 早睡早起，多读书，多运动，做一个不会猝死的攻城狮。 Experience 2020 开了博客，好好学习，天天向上 2018 南京大学软件工程"}],"posts":[{"title":"容器概念与docker入门","slug":"spring/容器概念与docker入门","date":"2021-04-03T02:47:08.000Z","updated":"2021-04-03T02:47:08.000Z","comments":true,"path":"posts/d2d74293.html","link":"","permalink":"https://zhouzhuyan.com/posts/d2d74293.html","excerpt":"本文简要介绍了容器的概念，然后结合例子对docker的基本命令进行介绍，最后介绍了数据卷和容器网络的概念。","text":"容器概念与Docker入门1. 容器是什么?容器与微服务是相伴而生的。 那么什么是容器？ 容器可以等同于虚拟机来理解，但是又与虚拟机不一样。 容器是一种轻量级的虚拟化，是共用主机内核，利用内核的虚拟化技术隔离出的一个独立的运行环境，拥有独立的一个文件系统，网络空间，进程空间视图等。 从虚拟化层看容器，它的核心价值是 轻量级 高性能：启动速度快，消耗资源少 虚拟机 vs 容器 容器是在Linux内核实现的轻量级资源隔离机制 虚拟机是操作系统级别的资源隔离，容器本质上是进程级的资源隔离 2. Docker2.1 Docker EngineDocker是创建、管理容器的一个软件。 它的核心是Docker Daemon(Engine)，在宿主机后台运行。 用户通过Docker Client与Daemon进行交互，将命令传输到宿主机上执行 Docker registeries是docker仓库，存储容器镜像，用户可以上传和下载需要的镜像 2.2 docker基本命令查看docker有哪些命令 docker 获得帮助，查看某个命令的细节 docker container --help # 这里是查看管理容器命令的细节 查看docker的版本 docker --version 查看docker engine的具体信息 docker version 可以看到Client和Server端的版本，操作系统等信息。 server端的操作系统信息是：OS/Arch: linux/amd64，说明容器是跑在Linux上的 查看系统更加细节的信息 docker info 可以看到server端的镜像Registry Mirrors，代理Http Proxy等 查看docker中安装了哪些镜像 docker image ls 从远端拉取镜像xxx docker pull xxx 2.3 docker run在新的容器中执行操作 -d 后台运行容器，并返回容器id -i 以交互模式运行容器 -t 为容器重新分配一个伪输入终端，通常与-i同时使用 -p 指定（发布）端口映射 格式：主机（宿主）端口：容器端口 -P 随机端口映射，容器内部端口随机映射到主机的高端口 --name=&quot;nginx-lb&quot; 为容器指定一个名称 -e username=&quot;ritchie&quot; 设置环境变量 --env-file=c:/temp1/t.txt 从指定文件读入环境变量 --expose=2000-2002 开放（暴露）一个端口或一组端口 --link my-mysql:adam 添加链接到另一个容器，将已经启动的容器链接到新启动的容器 -v c:/temp1:/data 绑定一个卷(volume) (详细介绍见第4部分) --rm 退出时自动删除容器 下面通过一些例子运用上述命令 在仓库中搜索某个docker镜像 docker search xxx 拉取镜像busybox(BusyBox 是一个集成了三百多个最常用Linux命令和工具的软件)和镜像nginx docker pull busybox:latest docker pull nginx:latest 运行镜像busybox，并命名为mycontainer（为了避免一直要查询容器id，可以在启动容器时给它命名） docker run -it --name mycontainer busybox 在后台运行nginx，并在容器和当前的宿主机之间建立一个端口映射 docker run -d -p 80:80 --name mynginx nginx 运行上述命令之后，在宿主机浏览器访问localhost，即可看到Welcome to Nginx的页面 随机映射 docker run -d -P nginx 自己设置环境变量 docker run --name mycontainer -it -e myname=zzy busybox # 读入单个环境变量 docker run --env-file=filepath busybox # 可以写一个文件批量读入环境变量 set # 列出所有环境变量 查看某个镜像的细节信息 比如Cmd，即启动时执行什么命令，Env 环境变量等 docker image inspect busybox 2.4 docker container列出当前正在运行的容器 docker container ls docker ps 列出所有容器的信息 docker container ls -a docker ps -a 列出所有容器的id docker container ls –aq 显示容器细节信息，比如ip地址，网关等 docker container inspect 容器名/id # 显示容器mynginx的详细信息 docker container inspect mynginx 显示容器端口映射信息 docker port 容器名/id 查看容器内部的标准输出 docker logs -f 容器名/id -f作用是动态显示，会不断更新，不加就会打印当前状态下的所有信息然后退出 docker stop 容器名/ID # 停止一个容器 docker start 容器名/ID # 启动已停止运行的容器 docker restart 容器名/ID # 正在运行的容器可以重启 将本地的标准输入、输出或错误流加入到正在运行的容器上 docker attach 容器名/ID 进入容器，执行命令 docker exec -it 容器名/ID /bin/bash 删除容器，-f表示强制删除 docker rm -f 容器名/ID 如果docker中有很多处在停止状态中的容器，可以使用这个命令将它们全部删除 docker container prune 2.5 docker实践gcc如果在Windows环境下希望使用linux的gcc进行编译 # 拉取镜像 docker pull gcc:latest # 启动 docker run --rm -v C:\\codec\\hw:/hw -w /hw –it -–name=server gcc -v 绑定一个卷，将目录关联起来 我们知道docker分为客户端和服务端，这里的编译其实是在服务端linux环境下进行的，这里将Windows系统中C盘下的codec\\hw目录与服务端的/hw目录进行关联，前者的内容会映射到后者中 -w指定了工作目录，这样在启动gcc容器之后，就可以直接在该目录下编译相关的文件 --rm表示退出时删除容器 # 查询容器的IP: cat /etc/hosts # 查看操作系统的版本 cat /proc/version uname -a # 查看发行版的信息 cat /etc/issue MongoDBdocker pull mongo # pull到本地 docker run --name mymongo -d mongo # 启动mongo服务端 docker run -it --link mymongo:taozs --rm mongo mongo --host taozs # 启动mongo客户端 #第一个mongo是镜像 #--host 连接哪一台机器 # --link 链接到一个新的容器 如果不链接，无法直接使用mymongo 如果想要从本地连接mongo，可以使用-p指定映射端口 redisdocker pull redis docker run -d --name myredis redis docker run -it --rm --link myredis:adam redis redis-cli -h adam mysqldocker pull mysql:5.7 docker run --name my-mysql -e MYSQL_ROOT_PASSWORD=exampledb20 -d mysql:5.7 # 为什么加-e参数 为了创建一个可以连接的用户 用户名，密码等 docker run -it --rm --link my-mysql:taozs mysql mysql –h taozs -u root -p exampledb20 3. 镜像分层如何持久化数据？ 容器的文件系统 每一个容器都有一个独立的文件系统，从最底层开始逐步叠加 写时复制 在一个进程fork自己之后，在不做写操作之前，复用原来的数据，在要执行写操作之后，再进行复制 要修改时再复制，否则就复用 不可变的优势：多线程环境中，安全 4. 数据卷volumn2种类型的数据卷 uDocker-managed volume（docker管理卷） docker自己管理的卷，可以告诉docker创建一个卷，将数据存储在宿主机的某一个目录下 docker volume ls docker volume inspect xxx docker volume create myvolume docker volume inspect myvolume # 可以看到`MountPoint` 就是存储数据的位置 docker run -it --rm -v myvolume:/data busybox # 容器中有一个目录/data 当操作这个目录时比如拷贝一个文件，就会存储到myvolume中 # 删除容器，但是数据仍然存在，可以恢复 # 这就是docker自己管理的卷 uBind mount volume（绑定挂载卷） -v将数据持久化到本地 5. 导出和导入容器镜像6. 容器网路docker network ls docker network inspect bridge","categories":[{"name":"Spring","slug":"Spring","permalink":"https://zhouzhuyan.com/categories/Spring/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://zhouzhuyan.com/tags/docker/"},{"name":"Spring","slug":"Spring","permalink":"https://zhouzhuyan.com/tags/Spring/"}]},{"title":"简单工厂模式","slug":"设计模式/简单工厂模式","date":"2021-03-25T05:48:07.000Z","updated":"2021-03-25T05:48:07.000Z","comments":true,"path":"posts/6b3bea20.html","link":"","permalink":"https://zhouzhuyan.com/posts/6b3bea20.html","excerpt":"本文介绍了简单工厂模式，包括定义，模式结构，代码示例。并分析了它的适用情况，优点和不足。","text":"简单工厂模式当我们需要实例化一些具体的类时，可能会写出如下的代码 if (cash) &#123; // 现金支付处理 &#125; else if (creditcard) &#123; // 信用卡支付 &#125; else if (alipay) &#123; // 支付宝支付 &#125; 一旦需要进行变化或扩展，比如增加微信支付或者修改已有支付的逻辑，就需要修改原有的代码，更容易产生错误，也增加了维护的难度。我们的代码应该对扩展开放，对修改关闭（开闭原则）。所以，我们应该考虑在使用这些具体的类时，只需要知道一个参数，并提供一个调用方便的方法，将该参数传入方法返回一个相应的对象。我们可以使用简单工厂模式。 本质上，就是找出会变化的方面，把它们从不变的部分分离出来。 1.1 定义又称为静态工厂方法。属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例，简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 1.2 模式结构Factory：工厂角色 Product：抽象产品角色 ConcreteProduct：具体产品角色 1.3 代码实例我们将开头的支付逻辑代码使用简单工厂模式进行修改。 // 抽象支付类 public abstract class AbstractPay &#123; public abstract void pay(); &#125; // 具体支付类 public class CashPay extends AbstractPay &#123; public void pay() &#123; // 现金支付处理 &#125; &#125; // 支付工厂 public class PayMethodFactory &#123; public class Abstarct getPayMethod(String type) &#123; if (cash) &#123; return new CashPay(); // 根据参数创建具体产品 &#125; else if (creditcard) &#123; return new Creditcard(); &#125; ...... &#125; &#125; 1.4 模式分析1.4.1 优缺点 优点 缺点 将对象的创建和对象本身的业务处理分离可以降低系统的耦合度（责任的分割） 工厂职责过重，集中了所有创建逻辑，出问题会影响整个系统 客户端无需知道所创建的产品类的类名，只需要知道其所对应的参数 更多的类，增加了系统的复杂度，（降低耦合的代价，难以两全其美） 使用静态方法，可以通过引入配置文件，在不修改代码的情况下增加新的具体产品类，提高了灵活性 系统扩展困难，一旦添加新产品就要更改工厂逻辑，使得逻辑越来越复杂，由于使用静态方法，不能通过继承来改变创建方法的行为。 1.4.2 适用环境 工厂类负责创建的对象比较少，工厂逻辑不复杂 客户端只知道传入工厂类的参数，对于如何创建对象不关心 1.4.3 不足前面提到的开闭原则，我们的代码应该对扩展开放，对修改关闭，但是如果要添加新的产品到系统中，必须修改工厂类，加入必要的处理逻辑，这其实还是违背了“开闭原则”。而且工厂类的职责重，业务逻辑复杂，影响了系统的灵活性和扩展性。要想解决这个问题，就需要使用工厂模式。 1.5 模式应用在实际的项目中的使用 待补充","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhouzhuyan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhouzhuyan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Neo4j_CQL语法简介","slug":"数据库/Neo4j-CQL语法简介","date":"2021-03-10T14:07:57.000Z","updated":"2021-03-10T14:07:57.000Z","comments":true,"path":"posts/55958cb4.html","link":"","permalink":"https://zhouzhuyan.com/posts/55958cb4.html","excerpt":"本文通过一些例子简要介绍了图形数据库Neo4j的查询语言CQL的语法。","text":"Neo4j CQL语法简介注：本文中的示例来自于Neo4j的Example Graphs中的Movies 1. MATCH &amp; RETURNMATCH (p:Person) RETURN p LIMIT 10 match查询节点，关系，标签，属性等。类似于SQL中的SELECT 匹配10个Person并返回，注意如果需要使用RETURN就需要一个像p这样的变量来存储返回内容 MATCH (p:Person &#123;name: &quot;Al Pacino&quot;&#125;) RETURN p 查询姓名为Al Pacino的Person节点并返回 MATCH (:Person &#123;name: &#39;Tom Hanks&#39;&#125;)-[:DIRECTED]-&gt;(movie:Movie) RETURN movie.title 查询Tom Hanks导演的电影，并返回电影的标题 MATCH (tom:Person &#123;name:&#39;Tom Hanks&#39;&#125;)-[rel:DIRECTED]-(movie:Movie) RETURN tom.name AS name 使用AS关键字设置别名 2. CREATECREATE (friend:Person &#123;name: &#39;Mark&#39;, born: 36&#125;) RETURN friend 创建一个Person界面，设置两个属性的值，返回创建的节点（这一步不是必须的，但在实际开发中可以作为测试） MATCH (jennifer:Person &#123;name: &#39;jennifer&#39;&#125;) MATCH (mark:Person &#123;name: &#39;Mark&#39;&#125;) CREATE (jennifer)-[rel:IS_FRIENDS_WITH]-&gt;(mark) 注意：CREATE不会判断节点在数据库中是否已经存在，为了避免重复插入，这里先使用MATCH查询节点是否已经存在，再在两者间建立关系 但是如果节点不存在，就不会执行？？？ 3. UPDATEMATCH (p:Person &#123;name: &#39;Keanu Reeves&#39;&#125;) set p.born &#x3D; 1962 RETURN p 使用set关键字执行更新操作 使用MATCH查找节点 使用set设置节点的属性值 返回节点确保更新正确 MATCH (:Person &#123;name: &#39;Keanu Reeves&#39;&#125;)-[rel:ACTED_IN]-&gt;(:Movie &#123;title: &#39;Something\\&#39;s Gotta Give&#39;&#125;) set rel.roles &#x3D; &#39;阿巴阿巴&#39; RETURN rel 也可以更新关系的属性，比如这里更新了演员在某部电影中饰演的角色 4. DELETE &amp; REMOVE由于Neo4j数据库具备原子性，一致性，隔离性和持久性，所以无法在一个节点仍然有关系的情况下删除它。 4.1 删除关系MATCH (j:Person &#123;name: &#39;Jennifer&#39;&#125;)-[r:IS_FRIENDS_WITH]-&gt;(m:Person &#123;name: &#39;Mark&#39;&#125;) DELETE r 要想删除一个关系，需要找到关系的起始节点和关系的终止节点，然后使用`DELETE关键字删除节点之间的关系 4.2 删除节点MATCH (m:Person &#123;name: &#39;Mark&#39;&#125;) DELETE m 如果一个节点没有任何的关系，那么可以直接删除它。 4.3 同时删除节点和关系MATCH (m:Person &#123;name: &#39;Mark&#39;&#125;) DETACH DELETE m DETACH DELETE可以删除节点的所有关系，同时删除节点。 4.4 删除属性MATCH (n:Person &#123;name: &#39;Jennifer&#39;&#125;) REMOVE n.birthdate 第一种删除属性的方式是REMOVE关键字 MATCH (n:Person &#123;name: &#39;Jennifer&#39;&#125;) SET n.birthdate &#x3D; null 第二种删除属性的方式是使用set关键字将属性的值设为null。因为neo4j数据库不会存储null值，所以它也会被删除。 5. Merge在第二部分里面提到的重复插入问题，可以通过关键字merge来解决。 5.1 节点MERGE (mark:Person &#123;name: &#39;Mark&#39;, born: 1999&#125;) RETURN mark 可以使用merge关键字来避免重复插入节点，它会事先检查节点是否已经存在在数据库中，执行的是select-or-insert的操作。 5.2 关系MATCH (j:Person &#123;name: &#39;Jennifer&#39;&#125;) MATCH (m:Person &#123;name: &#39;Mark&#39;&#125;) MERGE (j)-[r:IS_FRIENDS_WITH]-&gt;(m) RETURN j, r, m 这里首先通过MATCH检查是否存在我们要建立关系的两个节点，如果存在，再在两者之间建立关系。 注意：Merge会检查我们要建立的模式在数据库中已经存在，如果不存在，那么它会将模式完整地建立，包括节点和关系。使用下面的语句，如果节点已经存在，那么就会造成重复插入的问题。所以一定要先用MATCH匹配节点是否已经存在 &#x2F;&#x2F;this statement will create duplicate nodes for Mark and Jennifer MERGE (j:Person &#123;name: &#39;Jennifer&#39;&#125;)-[r:IS_FRIENDS_WITH]-&gt;(m:Person &#123;name: &#39;Mark&#39;&#125;) RETURN j, r, m MERGE (m:Person &#123;name: &#39;Mark&#39;&#125;)-[r:IS_FRIENDS_WITH]-(j:Person &#123;name:&#39;Jennifer&#39;&#125;) ON MATCH SET r.updated &#x3D; date() RETURN m, r, j 如果想要不重复创建节点，并且更新匹配到的节点属性，可以使用ON MATCH SET的方式 官方文档上的ON CTRATE SET似乎没有作用，而ON MATCH SET就可以起到创建和更新的作用 6. WHERE与SQL查询类似，CQL也可以使用where进行范围的限定，在全键值等值查询时，效果与前面的例子一样。但对于熟悉SQL语法的人来说可能这种方式更容易上手。 &#x2F;&#x2F;query using equality check in the MATCH clause MATCH (j:Person &#123;name: &#39;Jennifer&#39;&#125;) RETURN j &#x2F;&#x2F;query using equality check in the WHERE clause MATCH (j:Person) WHERE j.name &#x3D; &#39;Jennifer&#39; RETURN j 6.1 否定属性使用NOT AND OR XOR等操作符 MATCH (j:Person) WHERE NOT j.name &#x3D; &#39;Jennifer&#39; RETURN j 6.2 范围查询查询1960到1970年出生的人 MATCH (p:Person) WHERE 1960 &lt;&#x3D; p.born &lt;&#x3D; 1970 RETURN p 6.3 exists检查一个属性是否存在 注意：neo4j不会存储null值 &#x2F;&#x2F;Query1: find all users who have a birthdate property MATCH (p:Person) WHERE exists(p.birthdate) RETURN p.name 6.4 模糊查询对一个字符串，我们可能需要根据前缀，后缀或包含进行模糊查询。 &#x2F;&#x2F;check if a property starts with &#39;M&#39; MATCH (p:Person) WHERE p.name STARTS WITH &#39;Ma&#39; RETURN p.name &#x2F;&#x2F;check if a property contains &#39;a&#39; MATCH (p:Person) WHERE p.name CONTAINS &#39;a&#39; RETURN p.name &#x2F;&#x2F;check if a property ends with &#39;n&#39; MATCH (p:Person) WHERE p.name ENDS WITH &#39;n&#39; 当然，我们还可以使用正则表达式的形式。~表示使用正则表达式 MATCH (p:Person) WHERE p.name &#x3D;~ &#39;Jo.*&#39; RETURN p.name 6.5 Filtering on Patterns由于neo4j是图形数据库，它比其它数据库更注重于关系(relationships)。所以我们也可以通过关系来进行筛选。 比如下面这个关系匹配同时担任一部电影的导演和编剧的人。 MATCH (p:Person)-[r:DIRECTED]-&gt;(m:Movie) WHERE exists((p)-[:WROTE]-&gt;(m)) RETURN p 6.6 Optional Patterns类似于SQL的外连接。可选匹配。 这个例子匹配以姓名以Jo开头并且担任过电影编剧的人，后面这个条件不是强制的。 MATCH (p:Person) WHERE p.name STARTS WITH &#39;Jo&#39; OPTIONAL MATCH (p) - [:WROTE] -&gt; (m:Movie) RETURN p.name, m.title 7. Aggregation in Cypher7.1 count统计数量 例1加上了属性值title，可以去掉null值，而使用*会统计所有电影节点。 MATCH (m:Movie) RETURN count(m.title) MATCH (m:Movie) RETURN count(*) 7.2 collect将值聚合成一个列表。可以使用collect基于一个起始节点或关系等组织一系列的值。 下面这个例子展示了导演和他们执导的电影。如果不使用collect，那么导演和电影会一对一的呈现在表格中。但一个导演可能执导过多部电影，所以使用collect将电影节点聚合起来。 MATCH (p:Person) - [r:DIRECTED] -&gt; (m:Movie) RETURN p.name, collect(m.title) AS titles 7.3 sizesize的作用是统计列表中元素的个数或者统计一个表达式返回的内容大小。 &#x2F;&#x2F; 统计导演执导电影数量 MATCH (p:Person) - [r:DIRECTED] -&gt; (m:Movie) RETURN p.name, collect(m.title) AS titles, size(collect(m.title)) AS count &#x2F;&#x2F; 统计导演同时还担任该电影的编剧的数量 MATCH (p:Person) - [r:DIRECTED] -&gt; (m:Movie) RETURN p.name, size((p) - [:WROTE] -&gt; (m)) AS count 7.4 WITH使用WITH传递参数到下一个查询 &#x2F;&#x2F;find number of friends who have other friends MATCH (p:Person)-[:IS_FRIENDS_WITH]-&gt;(friend:Person) WITH p, collect(friend.name) AS friendsList, size((friend)-[:IS_FRIENDS_WITH]-(:Person)) AS numberOfFoFs WHERE numberOfFoFs &gt; 1 RETURN p.name, friendsList, numberOfFoFs &#x2F;&#x2F;find people with 2-6 years of experience WITH 2 AS experienceMin, 6 AS experienceMax MATCH (p:Person) WHERE experienceMin &lt;&#x3D; p.yrsExperience &lt;&#x3D; experienceMax RETURN p 7.5 UNWIND将一个列表拆分成单独的值，与collect()的作用相反 &#x2F;&#x2F;Query10: for numbers in a list, find candidates who have that many years of experience WITH [4, 5, 6, 7] AS experienceRange UNWIND experienceRange AS number MATCH (p:Person) WHERE p.yearsExp &#x3D; number RETURN p.name, p.yearsExp 7.6 ORDER BY排序，默认是升序的。 如下的例子将出生在1960年到1965年的人按降序排序 （如果对个值参与排序，那按照先后顺序排序） MATCH (p:Person) WHERE 1960 &lt;&#x3D; p.born &lt;&#x3D; 1965 RETURN p.name, p.born ORDER BY p.born DESC 7.7 DISTINCT有点时候，一个查询可能会返回多个重复的结果。使用DISTINCT可以解决这个问题。 下面这个例子查询导演过电影并且担任过电影编剧的人，有的人导演过多部电影，那么就会返回重复的名字，但使用了DISTINCT，就可以获得独特的结果。 MATCH (p:Person) - [:DIRECTED] -&gt; (m:Movie) MATCH (p) - [:WROTE] -&gt; (:Movie) RETURN DISTINCT p.name 7.8 LIMIT限制返回的个数 MATCH (p:Person) RETURN p LIMIT 10 8. 进阶8.1 APOC插件8.1.1 简介 APOC是 Neo4j 3.3 版本推出时正式推荐的一个Java存储过程包，里面包含丰富的函数和过程，作为对Cypher所不能提供的复杂图算法和数据操作功能的补充，APOC还具有使用灵活、高性能等优势，是一个基于Neo4j的函数包插件。 8.1.2 安装 下载对应的jar包https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases 把jar包放在安装目录的plugins文件夹下 进入neo4j的目录，编辑在conf文件夹下的neo4j.conf配置文件，加入如下一行 dbms.security.procedures.unrestricted=apoc.* 重启Neo4j服务 在可视化界面运行：return apoc.version()。如果出现对应的版本号，证明安装成功 8.2变量引用$ MATCH (n:Person) WHERE n.name &#x3D; $name RETURN n 动态访问节点或关系[] Springboot data neo4j @Query支持apoc，但是如果返回数据格式不一致不会报错，只是接受到的信息为null 参考： Neo4j官方文档 Neo4j：入门基础（三）之APOC插件","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zhouzhuyan.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Neo4j","slug":"Neo4j","permalink":"https://zhouzhuyan.com/tags/Neo4j/"}]},{"title":"Hadoop与Spark集群搭建","slug":"云计算/Hadoop与Spark集群搭建","date":"2020-12-01T06:06:28.000Z","updated":"2020-12-01T06:06:28.000Z","comments":true,"path":"posts/e567410e.html","link":"","permalink":"https://zhouzhuyan.com/posts/e567410e.html","excerpt":"本文介绍了如何在虚拟机上搭建Hadoop集群与Spark集群，为云计算实践做好了准备工作。文章共分为3个部分，准备工作，Hadoop集群搭建和Spark集群搭建。","text":"Hadoop与Spark集群搭建本文介绍了如何在虚拟机上搭建Hadoop集群与Spark集群，为云计算实践做好了准备工作。文章共分为3个部分，准备工作，Hadoop集群搭建和Spark集群搭建。 强烈建议在Linux操作系统上部署Hadoop集群与Spark集群，在Windows和macOS上安装会在部署和后续的开发中遇到各种各样的问题！！！ 1. 准备1.1 环境3台VMware虚拟机 Ubuntu 18.04.5 Tip：可以先安装好一台虚拟机，然后通过克隆再制作另外2台虚拟机，这样就不用在每台机器上重复配置了，克隆的方式后续会介绍。 在虚拟机中创建一个hadoop用户，然后进入hadoop用户的根目录 sudo addgroup hadoop sudo adduser --ingroup hadoop hadoop cd /home/hadoop 1.2 虚拟机克隆vmware fusion的虚拟机克隆步骤如下，进入Virtual Machine Library右键虚拟机，然后点击show in finder，复制一份后更改名字即可。克隆成功将3台虚拟机全部启动。 1.3 网络规划与配置静态ip集群需要运行在局域网下(比如开一个手机热点)，不同的机器才可以互相连通，所以需要配置好网络。 我的网络规划如下，集群共3台机器，一台为master，两台为slave 172.20.10.3 master 172.20.10.4 slave1 172.20.10.5 slave2 在master机器修改主机名 hostname master 编辑/etc/hosts文件，注释掉前两行，并加上我们自定义的配置。 sudo vi /etc/hosts #127.0.0.1 localhost #127.0.1.1 ubuntu 172.20.10.3 master 172.20.10.4 slave1 172.20.10.5 slave2 虚拟机网络需要选择桥接模式，如下图 然后配置静态ip地址，ubuntu18以后采用了netplan来配置静态ip，与以前有所不同。 cd /etc/netplan vi 01-network-manager-all.yaml 在文件中写入如下内容 # Let NetworkManager manage all devices on this system network: ethernets: ens33: # 配置的网卡名称 dhcp4: no # 关闭dhcp4 dhcp6: no # 关闭dhcp6 addresses: [172.20.10.3/24] # 设置本机IP地址及掩码 gateway4: 172.20.10.1 # 设置网关 nameservers: addresses: [172.20.10.1, 114.114.114.114, 8.8.8.8] # 设置DNS version: 2 按:wq保存退出，然后如下命令使得网络设置生效 sudo netplan apply 通过ping命令检测网络运行是否正常 ping www.baidu.com PING www.a.shifen.com (39.156.66.18) 56(84) bytes of data. 64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=1 ttl=50 time=55.8 ms 64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=2 ttl=50 time=83.2 ms 64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=3 ttl=50 time=104 ms 64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=4 ttl=50 time=119 ms 在两台slave机器上进行同样的操作，修改主机名分别为slave1和slave2，然后修改/etc/hosts文件，在配置静态ip时要注意将addresses: [172.20.10.3/24]修改为addresses: [172.20.10.4/24]和addresses: [172.20.10.5/24]。 最后，在master机器上ping slave1和slave2验证 ping slave1 PING slave1 (172.20.10.4) 56(84) bytes of data. 64 bytes from slave1 (172.20.10.4): icmp_seq=1 ttl=64 time=0.684 ms 64 bytes from slave1 (172.20.10.4): icmp_seq=2 ttl=64 time=0.997 ms 64 bytes from slave1 (172.20.10.4): icmp_seq=3 ttl=64 time=1.19 ms 64 bytes from slave1 (172.20.10.4): icmp_seq=4 ttl=64 time=0.591 ms 能够ping通则说明网络配置成功。 2. Hadoop集群搭建2.1 安装在安装hadoop之前。首先需要安装java apt-get update apt-get install -y openjdk-8-jdk openjdk-8-jre 然后下载hadoop安装包，解压后移动到/usr/local目录下 wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz tar -zxf hadoop-3.2.1.tar.gz sudo mv ./hadoop-3.2.1 /usr/local/ 安装完成后，将其写入环境变量 sudo vi /etc/bash.bashsrc export HADOOP_HOME=/usr/local/hadoop export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/ 在终端输入如下命令验证，出现命令下的内容说明配置成功 java -version openjdk version &quot;1.8.0_275&quot; OpenJDK Runtime Environment (build 1.8.0_275-8u275-b01-0ubuntu1~18.04-b01) OpenJDK 64-Bit Server VM (build 25.275-b01, mixed mode) hadoop version Hadoop 3.2.1 Source code repository https://gitbox.apache.org/repos/asf/hadoop.git -r b3cbbb467e22ea829b3808f4b7b01d07e0bf3842 Compiled by rohithsharmaks on 2019-09-10T15:56Z Compiled with protoc 2.5.0 From source with checksum 776eaf9eee9c0ffc370bcbc1888737 This command was run using /usr/local/hadoop/share/hadoop/common/hadoop-common-3.2.1.jar 上述安装步骤3台机器都需要执行。 2.2 SSH免登陆在master机器上创建ssh密匙 ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys chmod 0600 ~/.ssh/authorized_keys 将密匙分发给两台slave机器 ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop@slave1 ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop@slave2 并且在两台slave机器上分别创建密匙 ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys chmod 0600 ~/.ssh/authorized_keys 2.3 配置文件在master机器上进入hadoop配置目录，修改配置文件 cd /usr/local/hadoop/etc/hadoop rm core-site.xml hdfs-site.xml mapred-site.xml yarn-site.xml wget https://gitee.com/focksor/hadoop-config/raw/master/Cluster/core-site.xml wget https://gitee.com/focksor/hadoop-config/raw/master/Cluster/hdfs-site.xml wget https://gitee.com/focksor/hadoop-config/raw/master/Cluster/mapred-site.xml wget https://gitee.com/focksor/hadoop-config/raw/master/Cluster/yarn-site.xml 修改workers文件，这里我们将3台机器都作为子节点。 master slave1 slave2 然后将配置内容分发给两台slave机器 cd /usr/local/hadoop/etc scp -r hadoop/ hadoop@slave1:/usr/local/hadoop/etc scp -r hadoop/ hadoop@slave2:/usr/local/hadoop/etc 2.4 启动在master机器上输入命令启动集群 start-all.sh 会输出如下内容 WARNING: Attempting to start all Apache Hadoop daemons as hadoop in 10 seconds. WARNING: This is not a recommended production deployment configuration. WARNING: Use CTRL-C to abort. Starting namenodes on [master] Starting datanodes Starting secondary namenodes [master] Starting resourcemanager Starting nodemanagers 等待命令执行完毕，然后在浏览器打开master:9870查看网页，在DataNode页面可以看到3个节点，说明集群正常启动。 3. Spark集群搭建3.1 安装Tip：搭建集群时所有机器上的spark版本必须一致，否则无法成功连接 下载spark，解压后移动到指定的目录 wget https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-3.0.1/spark-3.0.1-bin-hadoop3.2.tgz tar -zvxf spark-3.0.1-bin-hadoop3.2.tgz sudo mv spark-3.0.1-bin-hadoop3.2 /usr/local/ cd /usr/local sudo mv spark-3.0.1-bin-hadoop3.2/ spark 配置环境变量 sudo vi /etc/profile 按i进入编辑模式，输入如下内容 export SPARK_HOME=/usr/local/spark export PATH=$PATH:$&#123;SPARK_HOME&#125;/bin 按esc键后输入:wq保存退出 使用source命令使得修改生效 source /etc/profile 使用spark-shell命令验证安装情况 spark-shell 如果出现spark的图标并出现scala的输入就说明成功了。 3.2 配置进入spark/conf目录，编辑spark-env.sh文件 cd /usr/local/spark/conf cp spark-env.sh.template spark-env.sh vi spark-env.sh 注意SPARK_MASTER_HOST需要根据自己配置的集群的Master机器IP地址进行改变 export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/ export SPARK_MASTER_HOST=172.20.10.3 export SPARK_WORKER_MEMORY=2g export SPARK_WORKER_CORES=1 export HADOOP_HOME=/usr/local/hadoop export HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop 配置slaves文件，将3个节点都都当做worker cp slaves.template slaves vi slaves master slave1 slave2 Tip：因为3台机器的用户名都是hadoop，所以这里只需要写上主机名，如果用户名不一致，需要写成hadoop@master的形式，这样比较麻烦，所以推荐集群所有机器用户名保持一致。 3.3 启动进入sbin目录，启动 cd /usr/local/spark/sbin sudo ./start-all.sh 可以看到如下界面，出现3个节点则说明配置成功。 引用： Hadoop集群+Spark集群搭建一篇文章就够了 使用vmware+Ubuntu搭建hadoop集群","categories":[{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://zhouzhuyan.com/tags/Hadoop/"},{"name":"Spark","slug":"Spark","permalink":"https://zhouzhuyan.com/tags/Spark/"}]},{"title":"虚拟化技术","slug":"云计算/虚拟化技术","date":"2020-10-29T11:48:36.000Z","updated":"2020-10-29T11:48:36.000Z","comments":true,"path":"posts/aa435277.html","link":"","permalink":"https://zhouzhuyan.com/posts/aa435277.html","excerpt":"虚拟化意味着对计算机资源的抽象。在云计算中，虚拟化技术可以用来对数据中心的各种资源进行虚拟化和管理，是实现云计算的关键技术。可以实现服务器虚拟化、存储虚拟化、网络虚拟化和桌面虚拟化。","text":"虚拟化技术虚拟化意味着对计算机资源的抽象。在云计算中，虚拟化技术可以用来对数据中心的各种资源进行虚拟化和管理，是实现云计算的关键技术。可以实现服务器虚拟化、存储虚拟化、网络虚拟化和桌面虚拟化。 1. 虚拟化技术简介1.1 核心思想虚拟化技术的核心思想是利用软件或固件管理程序构成虚拟化层，把物理资源映射为虚拟资源。在虚拟资源上可以安装和部署多个虚拟机，实现多用户共享物理资源。 1.2 虚拟化的实现添加一个称为虚拟化层的软件，管理客户操作系统，使其能够独立于主机操作系统同时运行在同一个硬件上。 2. 数据中心虚拟化云计算中运用虚拟化技术主要体现在对数据中心的虚拟化上。 数据中心是云计算技术的核心，由于数据中心的规模不断增大，成本上升，管理日趋复杂，传统的数据中心网络采用的多种技术，业务之间的孤立性，使得其结构复杂，导致服务器之间存在操作系统和上层软件异构、接口和数据格式不统一等问题。 随着云计算的发展，传统数据中心逐渐过渡到虚拟化数据中心，即采用虚拟化技术将原来数据中心的物理资源进行抽象整合。满足虚拟数据中心网络高速、扁平、虚拟化的要求。它的作用如下： 实现资源的动态分配和调度，提高现有资源的利用率和服务可靠性 提供自动化的服务开通能力，降低运维成本 具有有效的安全机制和可靠性机制，满足公众客户和企业客户的安全需求 方便系统升级、迁移和改造 数据中心的虚拟化是通过服务器虚拟化、存储虚拟化和网络虚拟化实现的。服务器虚拟化在云计算中是最重要和最关键的。 服务器虚拟化：将一个或多个物理服务器虚拟成多个逻辑上的服务器，集中管理 存储虚拟化：把分布的异构存储设备统一为一个或几个大的存储池，方便用户使用和管理 网络虚拟化：在底层物理网络和网络用户之间增加一个抽象层，其向下对物理网络资源进行分割，向上提供虚拟网络 2.1 服务器虚拟化2.2.1 服务器虚拟化的层次1. 寄居虚拟化寄居虚拟化层一般称为虚拟机监控器（VMM）。VMM安装在已有的主机操作系统上。损耗大，没有独立的Hypervisor层。 2. 裸机虚拟化直接将VMM安装在服务器硬件设备中，也可以认为该架构中的VMM是一个操作系统，一般称为Hypervisor，实现从虚拟资源到物理资源的映射。 x86体系结构的处理器并不是完全支持虚拟化，因为某些x86特权指令在地特权级上下文执行时，不能产生自陷，导致VMM无法直接捕获特权指令。解决方案是基于动态指令转换或硬件辅助的完全虚拟化技术和半虚拟化技术。 2.2.2 服务器虚拟化的底层实现1. CPU的虚拟化 任意时刻一个物理CPU只能运行一个虚拟CPU 每个客户操作系统可以使用一个或多个虚拟CPU 在各个操作系统之间，虚拟CPU运行相互隔离，互不影响 CPU虚拟化需要解决正确运行和调度两个关键问题。 虚拟CPU的正确运行是要保证虚拟机指令正确运行，而且各个虚拟机之间不能相互影响。现有的实现技术包括模拟执行和监控执行。 调度问题是指VMM决定当前哪个虚拟CPU在物理CPU上运行，要保证隔离性、公平性和性能。 2. 内存虚拟化内存虚拟化技术把物理内存统一管理，包装成多个虚拟的物理内 存提供给若干虚拟机使用，每个虚拟机拥有各自独立的内存空间。 内存虚拟化的思路主要是分块共享，内存共享的核心是内存页面的写时复刻（Copy on Write） 虚拟内存的管理包括3种地址：机器地址、物理地址和虚拟地址。 3. I/O设备虚拟化把真实的设备统一管理起来，包装成多个虚拟设备给虚拟机使用。 I/O设备虚拟化同样是由VMM进行管理的，主要有全虚拟化、半虚拟化和软件模拟3种思路。其中软件模拟是主流。 2.2.3 虚拟机迁移将虚拟机实例从源宿主机迁移到目标宿主机，并且在目标宿主机上能够将虚拟机运行状态恢复到其在迁移之前的状态。从虚拟机迁移的源于目的的角度看，虚拟机迁移包括3类： 物理机到虚拟机 P2V （Physical-to-Virtual） 虚拟机到虚拟机 V2V 虚拟机到物理机 V2P 其中虚拟机到虚拟机的迁移是云计算关注的重点。 1. 虚拟机动态迁移实时迁移（Live Migration），就是保持虚拟机运行的同时，把它从一台计算机迁移到另一台计算机，并在目的计算机恢复运行的技术。动态实时迁移对云计算至关重要。 云计算中心物理服务器负载处于动态变化中，当无法提供额外的物理资源时，可以将占用热门物理资源的虚拟机迁移到其它物理服务器，以达到负载均衡 物理服务器定期升级的需要，升级前将虚拟机迁移到其他物理服务器，等升级完成再迁移回来 2. 迁移的步骤 预迁移：主机A选定一个目的计算机作为VM的新主机 预定资源：主机向主机B发送迁移请求，确认B是否有必须资源，有就预定这些资源 预复制：主机A以迭代的方式将VM的内存页复制到主机B上，第一轮迭代传送所有的页，后面的迭代只复制前一轮传送过程中被修改过的页面。 停机复制：停止主机A的VM，把它的网络连接重定向到B。传送CPU状态和前一轮传送过程中被修改过的页。此时，主机A与B有一致的VM映像 提交：主机B通知A成功收到VM映像，主机A确认消息，抛弃或销毁其上的VM 启动：启动B上的VM，迁移后使用B上的设备驱动，广播新的IP地址 3. 迁移的内容内存迁移是虚拟机迁移最困难的部分。 一个完整的内存迁移可以分为3个阶段： Push：在VM运行的同时，将它的一些内存页面通过网络复制到目的机器上，过程中被修改的页面需要重传，以保证内容的一致性。 Stop-and-Copy：VM停止工作，把剩下的页面复制到计算机上，然后在目的计算机启动新的VM Pull：新的虚拟机运行过程中，如果访问到未被复制的页面，就会出现页错误并从原来的VM处把该页复制过来 实际操作中没有必要同时包含上述3个阶段。下面是3种迁移策略的优劣比较： 网络资源的迁移 虚拟机这种系统级别的封装方式意味着迁移时VM的所有网络设备，包括协议状态(如TCP连接状态)以及IP地址都要随之一起迁移。 在局域网内，可以通过发送ARP重定向包，将VM的IP地址与目的机器的MAC地址相绑定， 之后的所有包就可以发送到目的机器上。 存储设备的迁移 迁移存储设备的最大障碍在于需要占用大量时间和网络带宽，通常的解决办法是以共享的方式共享数据和文件系统，而非真正迁移。 目前大多数集群使用NAS(Network Attached Storage，网络连接存储)作为存储设备共 享数据。 2.2.4 隔离技术虚拟机隔离是指虚拟机之间在没有授权许可的情况下，互相之间不可通信，不可联系的一种技术。 软件角度：互相隔离的虚拟机之间保持独立，如同一个完整的计算机 硬件角度：被隔离的虚拟机相当于一台物理机，有自己的CPU、内存、硬盘、I/O等，它与宿主机之间保持互相独立的状态 网络角度：被隔离的虚拟机如同物理机一样，既可以对外提供网络服务，也一样可以从外界接受网络服务 现有虚拟机隔离机制主要包括： 网络隔离 构建虚拟安全文件防护网 基于访问控制的逻辑隔离机制 通过硬件虚拟让每一个虚拟机无法突破虚拟机管理器给出的资源限制 硬件提供的内存保护机制 进程地址空间的保护机制，IP地址隔离 确保虚拟机之间的安全与可靠性 1. 内存隔离内存管理单元（MMU Memory Management Unit） 管理虚拟存储器、物理存储器的控制路线 负责将虚拟地址映射为物理地址 提供硬件机制的内存访问授权 以Xen为例，它在虚拟内存到机器内存之间引入了一层中间地址，Guest OS看到的是这层中间地址，而不是机器的实际地址。Guest OS感觉自己的物理地址从0开始，是连续的，但Xen将这层中间地址真正地映射到机器地址上却可以是不连续的，这样保证了所有的物理内存可被任意分配给不同的Guest OS。 虚拟机监控器使用分段和分页机制对自身的物理内存进行保护。x86体系结构提供了支 持分段机制的虚拟内存，这能够提供另一种形式的特权级分离。 每个段包括基址、段限和一些属性位。 2. 网络隔离目标：确保把有害的攻击隔离，在可信网络之外和保证可信网络内部信息不外泄的前提下，完成网间数据的安全交换。 关键：系统对通信数据的控制，即通过不可路由的协议完成网间数据交换 问题：通信硬件工作在网络最下层（物理层），不能感知交换数据的机密性、完整性、可用性、可控性、抗抵赖等安全要素。 解决方案：通过访问控制、身份认证、加密签名等安全机制来实现，这些机制都是通过软件实现的。 实现原理：通过专用通信设备、专有安全协议和加密验证机制及应用数据提取和鉴别认证技术，进行不同安全级别网络之间的数据交换。 效果： 彻底阻断了网络间的直接TCP/IP连接 保证了网间数据交 换的安全、可控 杜绝了由于操作系统和网络协议自身漏洞带来的安全风险 2.2 存储虚拟化存储虚拟化将系统中分散的存储资源整合起来。 提高了存储资源利用率 降低单位存储空间成本 降低存储管理的负担和复杂性 技术与效果 在虚拟层通过适用数据镜像、数据校验和多路径等技术，提高了数据的可靠性及系统的可用性 利用负载均衡、数据迁移、数据块重组等技术，提升系统的潜在性能 整合和重组底层物理资源，得到多种不同性能和可靠性的 新的虚拟设备，满足多种存储应用的需求 2.2.1 存储虚拟化的一般模型虚拟化存储系统在原有存储系统结构上增加了虚拟化层，将多个存储单元抽象成一个虚拟存储池。 它的优势如下： 减少存储系统的管理开销 实现存储系统数据共享 提供透明的高可靠性和可扩展性 2.2.2 存储虚拟化的实现方式1. 基于主机的存储虚拟化也称基于服务器的存储虚拟化或者基于系统卷管理器的存储虚拟化，其一般是通过逻辑卷管理来实现的。虚拟机为物理卷映射到逻辑卷提供了一个虚拟层。 虚拟机的主要功能如下： 数据存储共享 存储资源管理 数据复制及迁移 集群系统 远程备份 灾难恢复 2. 基于存储设备的存储虚拟化也称基于存储控制器的存储虚拟化。主要是在存储设备的磁盘、 适配器或者控制器上实现虚拟化功能。 有很多的存储设备的内部都有功能比较强的处理器，带有专门的嵌入式 统，可以在存储子系统的内部进行存储虚拟化，对外提供虚拟化磁盘。 3. 基于网络的存储虚拟化在网络设备上实现存 储虚拟化功能，包括基于互连设备和基于路由器两种方式。 4. 优劣比较 方式 优势 劣势 主机 性价比较高 性能较差、可扩展性差、不支持异构平台 存储设备 存储子系统与主机无关，对系统性能的影响比较小，较容易管理 对于包含异构存储设备的SAN存储系统，虚拟化方法的效果不好，设备规模有限并不能进行级联，可扩展性差 网络 在性能、效果和安全都要好一些 连接主机到存储网络的路由器出现故障导致与故障路由器连接在一起的主机受到影响，数据无法访问 2.3 网络虚拟化传统数据中心由于服务器之间操作系统和上层软件异构、接口于数据格式不统一，数据中心内网络传输效率低。使用云计算后，数据同步传送的大流量、备份的大流量、虚拟机迁移的大流量，采用统一的交换网络减少布线、维护工作量和扩容成本。引入虚拟化技术后，数据中心网络虚拟化分为核心层、接入层和虚拟机网络虚拟化三个层面 2.4 桌面虚拟化每个桌面镜像就是一个带有应用程序的操作系统，终端用户通过一个虚拟显示协议来访问他们的桌面系统。这样做 的目的就是使用户的使用体验同他们使用桌面上的PC一样。 引用： [1]刘鹏.云计算[M].电子工业出版社:北京,2015:250-268.","categories":[{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"虚拟化","slug":"虚拟化","permalink":"https://zhouzhuyan.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"Java 线程（一）","slug":"Java/Java-并发","date":"2020-09-24T08:47:31.000Z","updated":"2020-09-24T08:47:31.000Z","comments":true,"path":"posts/909f13b2.html","link":"","permalink":"https://zhouzhuyan.com/posts/909f13b2.html","excerpt":"本文介绍了线程的基本概念，线程的状态，两种创建线程的方法，线程的属性，线程的休眠以及线程内部的数据共享。","text":"线程（一）1. 线程的基本概念一个线程是程序内部的顺序控制流 1.1 线程与进程：每个进程都有独立的代码和数据空间，进程切换的开销大 线程是轻量的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器，线程切换的开销小 多进程：在操作系统中，能同时运行多个任务（程序） 多线程：在同一个应用程序中，有多个顺序流同时执行（有多个代码段同时在运行） 关于线程与进程的辨析可以看这一篇文章进程与线程的一个简单解释 1.2 线程的概念模型：虚拟的CPU，封装在java.lang.Thread类中 CPU所执行的代码和所处理的数据，传递给Thread类 线程体 Java的线程是通过java.lang.Thread类来实现的 每个线程都是通过某个特定的Thread对象的方法run()来完成其操作的，方法run()称为线程体 2. 线程状态线程可以有如下6种状态： New（新建） Runnable（可运行） Blocked （阻塞） Waiting （等待） Timed waiting（计时等待） Terminated （终止） 2.1 新建线程new Thread(t); 当使用new新建一个线程时，这个线程还没有开始运行，状态是新建 2.2 可运行线程new Thread(t).start(); 调用start方法，线程就处于可运行状态。它可能正在运行也可能没有运行，由操作系统决定它具体的运行时间。所以这个状态被称为可运行，而不是运行。 2.3 阻塞和等待线程当线程处于阻塞或等待状态时，它暂时是不活动的。 要由线程调度器重新激活这个线程，具体细节取决于它是怎样到达非活动状态的。 2.4 终止线程线程终止的原因有2个： run方法正常退出，线程自然终止 因为一个没有捕获的异常终止了run方法，使线程意外终止 3. 如何创建线程构造线程的两种方法 定义一个线程类，它继承类Thread并重写其中的方法run() 提供一个实现接口Runnable的类作为线程的目标对象，在初始化一个Thread类或者Thread子类的线程对象时，把目标对象传递给这个线程实例，由该目标对象提供线程体run() 3.1 通过Thread类创建线程通过Thread类来创建线程 继承Thread类，创建多线程的方法之一 从Thread类派生一个子类，并创建子类的对象 子类应该重写Thread类的run方法，写入需要在新线程中执行的语句段 调用start方法来启动新线程，自动进入run方法（不是直接调用run方法） 我们来看下面这个计算阶乘的程序 public class FactorialThreadTester &#123; public static void main(String[] args) &#123; System.out.println(&quot;main thread starts&quot;); FactorialThread myThread = new FactorialThread(10); myThread.start(); System.out.println(&quot;main thread ends&quot;); &#125; &#125; 我们自定义了FactorialThread类继承Thread类，重写了run方法 public class FactorialThread extends Thread &#123; private int num; public FactorialThread(int num) &#123; this.num = num; &#125; @Override public void run() &#123; int i = num; int result = 1; System.out.println(&quot;new thread starts&quot;); while (i &gt; 0) &#123; result *= i; i--; &#125; System.out.println(&quot;Result: &quot; + result); System.out.println(&quot;new thread ends&quot;); &#125; &#125; 结果： main thread starts main thread ends new thread starts Result: 3628800 new thread ends 主线程的任务就是创新新线程，创建完成后主线程就结束了 结果说明： main线程已经执行完后，新线程才执行完 main方法调用thread.start()方法启动新线程后并不等待run方法返回就继续运行，线程的run方法在一边独自运行，不影响原来的main方法的运行，也就是说新建的线程调用start()方法后不一定立即进入运行状态 3.2 通过Runnable接口构造线程 只有一个run()方法 Thread类实现了Runnable接口 便于多个线程共享资源 Java不支持多继承，如果定义的类已经继承了某个基类，便需要实现Runnable接口来实现多线程 以实现Runnable的对象为参数建立新的线程 我们定义一个ThreadSleep类实现Runnable接口 public class ThreadSleep implements Runnable &#123; private int sleepTime; public ThreadSleep() &#123; this.sleepTime = (int) (Math.random() * 6000); &#125; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; is going to sleep for &quot; + sleepTime); Thread.sleep(sleepTime); &#125; catch (Exception e) &#123; &#125; System.out.println(Thread.currentThread().getName() + &quot; ends&quot;); &#125; &#125; public class ThreadTest &#123; public static void main(String[] args) &#123; ThreadSleep t = new ThreadSleep(); new Thread(t, &quot;task1&quot;).start(); &#125; &#125; 或者也可以使用lambda表达式来创建实例 public class ThreadTest &#123; public static void main(String[] args) &#123; Runnable task1 = () -&gt; &#123; try &#123; int sleepTime = (int) (Math.random() * 6000); System.out.println(Thread.currentThread().getName() + &quot; is going to sleep for &quot; + sleepTime); Thread.sleep(sleepTime); &#125; catch (Exception e) &#123;&#125; System.out.println(Thread.currentThread().getName() + &quot; ends&quot;); &#125;; new Thread(task1, &quot;task1&quot;).start(); &#125; &#125; 使用Runnable接口实现线程可以将CPU，代码和数据分开，形成清晰的模型，还可以从其他类继承 直接继承Thread类实现线程，编写简单，直接继承，重写run方法，但是不能再从其他类继承 3. 线程属性3.1 中断线程除了已经废弃的stop方法，没有方法可以强制线程终止。不过，interrupt方法可以用来请求终止一个线程 当对一个线程调用interrupt方法时，就会设置线程的中断状态为true，如果当前线程被一个sleep调用阻塞，则抛出一个InterruptedException异常。 while (!Thread.currentThread().isInterrupted()) &#123; //blablabla &#125; static Thread currentThread()返回表示当前正在执行的线程的Thread对象 boolean isInterrupted()测试线程是否被中断 3.2 守护线程void setDaemon(boolean isDaemon) 调用t.setDaemon(true)将一个线程转换为守护线程，必须在线程启动之前调用，作用是为其它线程提供服务。比如计时器定时发送信号给其它线程，如果只剩下守护线程，虚拟机就会退出。 4. 线程的休眠public class FactorialThreadTester &#123; public static void main(String[] args) &#123; System.out.println(&quot;main thread starts&quot;); FactorialThread myThread = new FactorialThread(10); myThread.start(); try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; &#125; System.out.println(&quot;main thread ends&quot;); &#125; &#125; 结果 main thread starts new thread starts Result: 3628800 new thread ends main thread ends 运行结果说明，新线程结束后main线程才结束。 线程休眠就是为了让其他线程得到执行的机会 5. 线程内部的数据共享public class ThreadTest &#123; public static void main(String[] args) &#123; ThreadSleep t = new ThreadSleep(); System.out.println(&quot;Starting threads&quot;); new Thread(t, &quot;task1&quot;).start(); new Thread(t, &quot;task2&quot;).start(); new Thread(t, &quot;task3&quot;).start(); System.out.println(&quot;Thread started, main ends&quot;); &#125; &#125; 结果 Starting threads Thread started, main ends task1 is going to sleep for 5235 task3 is going to sleep for 5235 task2 is going to sleep for 5235 task2 ends task1 ends task3 ends 3个线程的休眠时间是一样的，因为是用一个Runnable类型的对象创建的3个新线程，这3个线程就共享了这个对象的私有成员sleepTime。 在现实生活中，如果我们需要多个售票窗口同时销售200张票，就可以使用上述的方法。 参考： 《Java核心技术 卷I》 学堂在线-Java程序设计进阶","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"},{"name":"线程","slug":"线程","permalink":"https://zhouzhuyan.com/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"泛型程序设计","slug":"Java/泛型程序设计","date":"2020-09-18T10:25:08.000Z","updated":"2020-09-18T10:25:08.000Z","comments":true,"path":"posts/98735cb0.html","link":"","permalink":"https://zhouzhuyan.com/posts/98735cb0.html","excerpt":"本文介绍了Java泛型程序设计，包括使用泛型程序设计的目的，如何自己设计泛型类和泛型方法，类型擦除，泛型设计的限制与局限性，泛型设计的继承规则和通配符规则。","text":"泛型程序设计1. 为什么要使用泛型程序设计？泛型程序设计(generic programming)意味着编写的代码可以对多种不同类型的对象重用。能够提高代码的复用性，比如ArrayList就可以收集任何类的对象，比如String，Integer等，而不用为这些对象去编写不同的类。 1.1 类型参数泛型允许在定义类和接口的时候使用类型参数(type parameter)，声明的类型参数在使用时使用具体的类来替换，比如下面这个例子 List&lt;String&gt; files = new ArrayList&lt;&gt;(); 可以很明显的看出数组中包含的是String对象，类型参数使得程序更易读，也更安全。 2. 定义简单泛型类泛型类(generic class)就是有一个或多个类型变量的类。下面定义了一个简单的泛型类Pair Pair类引入了一个类型变量T，用于指定方法的返回类型，字段和局部变量的类型 public class Pair&lt;T&gt; &#123; private T first; private T second; public Pair() &#123; first = null; second = null; &#125; public Pair(T first, T second) &#123; this.first = first; this.second = second; &#125; public T getFirst() &#123; return first; &#125; public T getSecond() &#123; return second; &#125; public void setFirst(T newValue) &#123; first = newValue; &#125; public void setSecond(T newValue) &#123; second = newValue; &#125; &#125; 3. 泛型方法与类型变量的限定我们再定义了泛型类之后，就可以设计带有类型参数的方法，比如我们想要寻找数组中元素的最大最小值，就可以这样定义 public static &lt;T&gt; T min(T[] a) &#123; // blablabla &#125; 但是这样的设计有一个问题，在方法内部对元素进行比较时，需要使用compareTo方法，这就要求类型T实现Comparable接口，所以需要对其进行限定(bound) public static &lt;T extends Comparable&gt; T min(T[] a) &#123; // blablabla &#125; 之所以使用extends而不是使用implements是因为T是限定类型的子类型，而继承关系更接近于这种概念，一个类型变量也可以有多个限定 T extends Comparable &amp; Serializable 下面使用我们定义的泛型类实现了一个寻找数组元素最大和最小值的方法。 import java.time.*; public class PairTest2 &#123; public static void main(String[] args) &#123; LocalDate[] birthdays = &#123; LocalDate.of(1906, 12, 9), // G. Hopper LocalDate.of(1815, 12, 10), // A. Lovelace LocalDate.of(1903, 12, 3), // J. von Neumann LocalDate.of(1910, 6, 22), // K. Zuse &#125;; Pair&lt;LocalDate&gt; mm = ArrayAlg.minmax(birthdays); System.out.println(&quot;min = &quot; + mm.getFirst()); System.out.println(&quot;max = &quot; + mm.getSecond()); &#125; &#125; class ArrayAlg &#123; /** Gets the minimum and maximum of an array of objects of type T. @param a an array of objects of type T @return a pair with the min and max values, or null if a is null or empty */ public static &lt;T extends Comparable&gt; Pair&lt;T&gt; minmax(T[] a) &#123; if (a == null || a.length == 0) return null; T min = a[0]; T max = a[0]; for (int i = 1; i &lt; a.length; i++) &#123; if (min.compareTo(a[i]) &gt; 0) min = a[i]; if (max.compareTo(a[i]) &lt; 0) max = a[i]; &#125; return new Pair&lt;&gt;(min, max); &#125; &#125; 4. 泛型代码和虚拟机虚拟机没有泛型类型对象，所有对象都属于普通类。 4.1 类型擦除无论何时定义一个泛型类型，都会自动提供一个相应的原始类型(raw type)，这个原始类型的名字就是去掉类型参数后的泛型类型名。同时，类型变量会被擦除(erased)，并替换为其限定类型。 类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。 类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换 2.移除所有的类型参数。 比如3中的例子，原始类型就会变成下面的样子 public class Pair &#123; private Object first; private Object second; &#125; 由于T是一个无限定的变量，所以直接用Object替换。 4.2 转换泛型表达式调用一个泛型方法时，如果擦除了返回类型，编译器会插入强制类型转换 Pair&lt;Employee&gt; buddies = ...; Employee buddy = buddies.getFirst(); getFirst方法擦除类型后的返回类型是Object，编译器自动插入转换到Employee的强制类型转换。 4.3 转换泛型方法类型擦除还会出现在泛型方法中，比如 public static &lt;T extends Comparable&gt; T min(T[] a) 在擦除类型之后，就会变成 public static Comparable min(T[] a) 5. 限制与局限性5.1 泛型遇到重载public class A &#123; public static void method(List&lt;Integer&gt; list) &#123; &#125; public static void method(List&lt;String&gt; list) &#125; 上述代码编译器会报错，提示两个方法冲突，因为它们被擦除之后都变为List 5.2 泛型类中静态变量无效public class Singleton&lt;T&gt; &#123; private static T singleInstance; public static &#125; 静态变量被泛型类的所有实例对象所共享。 5.3 不能抛出或捕获泛型类的实例既不能抛出也不能捕获泛型类的对象，泛型类扩展Throwable不合法。 6. 泛型类的继承规则考虑一个父类和子类，比如Employee和Manager，需要注意的是，Pair&lt;Manager&gt;不是Pair&lt;Employee&gt;的子类。 也就是说，无论S和T又怎样的关系，Pair&lt;T&gt;和Pair&lt;S&gt;没有任何关系，这对于类型安全非常重要。 参考： 《Java核心技术 卷I》 Java成神之路","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"云计算概述","slug":"云计算/云计算概述","date":"2020-09-16T12:00:44.000Z","updated":"2020-09-16T12:00:44.000Z","comments":true,"path":"posts/756f403a.html","link":"","permalink":"https://zhouzhuyan.com/posts/756f403a.html","excerpt":"本文对云计算进行了简单的介绍，包括云计算的起源，云计算产生的时代背景，云计算的定义，服务模型和实现机制，云计算的优势以及当前云计算的面对的风险与挑战。","text":"云计算概述1. 起源自计算机诞生之日起，人类就从未停止对更高计算性能的追求。 那么如何提高计算性能呢？ 思路1 把一台计算机做的足够强大 计算范式：集中式计算 将所有计算资源集中在一个物理系统之内，所有资源（处理器，内存，存储器）是共享的，并且紧耦合在一个集成式操作系统中。 计算范式：并行计算 提高效率，同一时间执行多个计算 所有处理器紧耦合于中心共享内存或松耦合于分布式内存，处理器通信通过共享内存或通过消息传递完成。 问题：单台计算机价格高昂，并行计算有瓶颈 思路2 人多力量大，机多计算强 由众多自治计算机组成，各自拥有私有内存，通过计算机网络通信，信息交换通过信息传递完成。 多个物理系统：分布式系统，分布式程序，分布式编程 1.1 传统分布式计算系统 1.1.1 计算集群实现计算抽象 特点 基本组件为计算节点、通信软件、网络接口卡以单独身份接入互联网 1.1.2 P2P系统实现了存储抽象 特点 节点是简单接入互联网的客户机，自治，自由加入和退出问题 无中心协作或中心数据库，有专用的物理互联网络，不稳定，不可靠，不安全 1.1.3 计算网络接近”云“ 特点 计算资源整合，一个集成的资源池，提供基础设施 节点包括：工作站，服务器，集群，超级计算机问题： 异构、用户管理、耗资源的协议、安全性、应用受限 1.2 云计算1.2.1 定义云计算是相对与1.1中的3个系统更好的解决方案，它对网格进行优化，可以完美解决分布式计算。 大量计算节点，同构可控 专用内部网络 通过互联网对外服务（公有云） 全面虚拟化（计算、存储、网络、桌面） 集中管理 安全高效 云计算的定义基本可以总结为： 云计算是一种商业计算模型，通过网络按需提供可以动态伸缩的廉价计算服务。 云是一些可以自我维护和管理的虚拟计算资源，通常是一些大型服务器集群，包括计算服务器，存储服务器和宽带资源等。 之所以称为云，是因为其具有现实中云的特征——云一般都较大，云的规模可以动态伸缩，它的边界是模糊的，位置是不确定的， 1.2.2 概念模型PPT p11 1.2.3 云计算 vs 网格计算 网格计算 云计算 共同： 提升计算能力，完成数据处理 构建虚拟资源池且动态可伸缩 支持多承租任务 聚合分布的资源，恰好有 使用专有的资源，专门做 强调虚拟组织，立足特定任务 不强调虚拟组织，重视通用性 利用中间件来屏蔽异构系统 不强调异构性 面向科研，商业模式不清晰 针对企业应用，商业模式清晰 2. 初探2.1 时代背景今天是大数据的时代，一切皆为大数据，一切皆为大数据。我们先来简单的介绍一下大数据。 什么是大数据？ 海量数据或巨量数据，其规模巨大到无法通过目前主流的计算机系统在合理时间内获取、存储、管理、处理并提炼以帮助使用者决策。 （刘鹏，《云计算》第三版） 为什么会产生大数据？ 数据产生方式的改变，越来越自动化 人类活动越来越依赖数据 互联网+物联网大数据有怎样的特征？ 3V: Volume(量大), Variety(多样), Velocity(快速) 4V+1C: Value(低价值密度), Complexity(复杂:处理和分析难度大) 5V: Volume, Variety, Velocity, Value, Veracity(真实) 云计算是处理大数据的手段。大数据促进了云计算的产生，激发了云计算的潜力。云计算为大数据的收集，存储，加工和应用提供了更好的支持。 2.2 云的服务模型 2.2.1 IaaS将硬件设备等基础资源封装成服务服务提供给用户。用户相当于在使用裸机和磁盘，比如亚马逊云计算AWS的弹性计算云EC2 通过虚拟机的方式对外提供计算和存储能力 机器享有公网IP，多个虚拟机之间通过网络进行通信 类似租用独立的计算机 用户自行解决多台机器之间的协同问题 优势 允许用户动态申请和释放资源 按使用量计费 由公众共享，具有更高的资源使用效率（节能环保） 2.2.2 PaaS抽象层次更进一步，提供用户应用程序的运行环境 自身负责资源的动态扩展和容错管理 优势 用户无需考虑节点间的配合问题 缺陷 用户自主权降低，需按照给定的编程环境和编程模型构建应用 2.2.3 SaaS针对性更强，将某些特定应用软件功能封装成服务。只提供某些专门用途的服务供应用调用 2.2.4 实现机制不同的供应商提供了不同的解决方案，没有同意的技术体系结构。下图是云计算体系结构参考模型 SOA构建层 封装云计算能力成标准的Web Service服务，并纳入SOA体系 其中，SOA是面向服务的体系结构(Service-oriented Architecture) 管理中间件层 云计算的资源管理，并对众多应用任务进行调度，使资源能够高效、安全的为应用提供服务 资源池层 将大量相同类型的资源构成同构或接近同构的资源池 物理资源层 计算机、存储器、网路设施、数据库和软件等 Tip 管理中间件层和资源池层是云计算技术最关键的部分，SOA构建层的功能更多依靠外部设施提供。 下面以IaaS为例，简述云计算的实现机制。 用户交互接口向应用以Web Services方式提供访问接口，获取用户需求。 服务目录是用户可以访问的服务清单。 系统管理模块负责管理和分配所有可用的资源，其核心是负载均衡。 配置工具负责在分配的节点上准备任务运行环境。 监视统计模块负责监视节点的运行状 态，并完成用户使用节点情况的统计 2.3 风险和挑战2.3.1 云计算压倒性的成本优势云计算之所以拥有划时代的优势，就是因为它的技术特征和规模效应所带来的的压倒性的性能价格比优势。 全球企业的IT开销分为三部分：硬件开销、能耗和管理成本。调查显示，在硬件开销持平的同时，能耗和管理成本上升非常迅速。而云计算的经济性主要体现在以下两个方面： 一方面，如果使用云计算，可以获得更低的硬件和网络成本，更低管理成本和电力成本。比如Google的数据中心就建立在人烟稀少，气候寒冷，水电资源丰富的地区，这样使得电价、场地、人力都远远比在城市建立要低，今天的中小企业直接租用相关的云服务也比自己去租用场地，搭建服务器要便宜的多。 另一方面，云计算与传统的互联网数据中心(IDC)的资源利用率有很大不同。在以前，每个租用IDC的网站所获得的带宽，处理能力和存储空间都是固定的，但是网站的访问量并不均衡，比如有的网站白天没啥人看，晚上流量很多。为了应对这些情况，网站拥有者需要按照峰值要求来配置服务器和网络资源，这就造成了资源的浪费。而云计算平台提供弹性服务，动态分配和释放资源，大大提高了资源的利用效率。 2.3.2 其它优势 可扩展性和可伸缩性 虚拟化 模拟符合用户需求的任何计算环境 高可靠 多副本容错 计算节点同构可互换等保障措施 管理简单 安全 2.3.3 云计算技术难点 2.3.4 风险与挑战增加了安全漏洞 运程使用IT资源需要云用户将信任边界扩展到外部的云，建立这样的安全架构同时又不引入安全漏洞是非常困难的 重叠的信任边界和不断增加的数据曝光为恶意的云用户提供了更多的攻击IT资源、窃 取或破坏企业数据的机会 降低了运营管理控制 云用户对云资源的管理控制低于对企业内部IT资源的管理控制 云提供者可能不遵守它发布的云服务保证 云用户和云提供者之间较长的地理距离可能需要更多的网络跳数，会带来延迟波 动和带宽受限 云提供者之间有限的可移植性 由于缺乏行业标准，不同的云提供者提供的服务存在较大差异 出于商业原因，云平台也不希望用户更换平台 多地区法规和法律问题 第三方云提供者通常选择造价较低、方便的地理位置建立数据中心，而云用户通常不会意识到所使用IT资源和自身数据所存放的位置 潜在的数据获得和公开，比如某些国家的法律规定，某些类型的数据必须向某些政府机构或数据主体公开 参考： 《云计算 （第三版）》 刘鹏","categories":[{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"异常与断言","slug":"Java/异常与断言","date":"2020-09-12T13:26:04.000Z","updated":"2020-09-12T13:26:04.000Z","comments":true,"path":"posts/35f9d194.html","link":"","permalink":"https://zhouzhuyan.com/posts/35f9d194.html","excerpt":"在理想世界里，用户输入数据的格式永远都是正确的，代码永远不会出现bug，然而，在现实世界的开发过程中，总会遇到各种各样的问题，这时候就需要我们使用异常和断言来调试我们的程序，解决问题。","text":"异常与断言在理想世界里，用户输入数据的格式永远都是正确的，代码永远不会出现bug，然而，在现实世界的开发过程中，总会遇到各种各样的问题，当然，我也可以说，这不是bug，而是特性~~~言归正传，如果由于程序的错误导致用户所做的工作统统丢失，那用户可能就再也不会用它了。为了避免这样的情况，至少应该做到以下几点 向用户通知错误 保存所有的工作 允许用户妥善地退出程序 1. 处理错误为了能够处理程序中的异常情况，必须考虑到程序中可能会出现的错误和问题。比如： 用户输入错误 设备错误 物理限制 代码错误 1.1 异常分类在Java中，异常对象都是派生于Throwable类的一个实例。在下一层分解为两个分支，Error和Exception。Error描述了Java运行时系统的内部错误和资源耗尽错误Exception又分解为两个分支由编程错误导致的RuntimeException，比如错误的强制类型转换，数组访问越界等由I/O错误导致的其他异常IOException，比如试图打开一个不存在的文件等如下图所示是异常层次结构的一个示意图 Tip 如果出现RuntimeException，那么一定是你的问题 Java将派生于Error类或RuntimeException类的所有异常称为非检查型(unchecked)，所有其他异常称为检查型(checked) 1.2 如何抛出异常假设我们正在读取一个文件，预期读取1024个字符，但是在读到500个字符的时候文件就结束了，出现了问题，我们希望抛出一个EOFException，即输入过程中意外遇到了EOF。 String readData(Scanner in) throws EOFException &#123; // blablabla if (!in.hasNext()) &#123; if (n &lt; len) &#123; throw new EOFException(); &#125; &#125; &#125; 1.3 创建异常类如果我们遇到了标准异常类无法描述清楚的问题，可以自己创建异常类。我们可以定义一个派生于Exception的类，或者某个Exception的子类，比如IOException。 class FileFormatException extends IOException &#123; public FileFormatException() &#123;&#125; public FileFormatException(String gripe) &#123; super(gripe); &#125; &#125; 2. 捕获异常要想捕获一个异常，需要设置try/catch块。 try &#123; // blablabla &#125; catch (Exception e) &#123; // blablabla &#125; 如果try语句块中的代码抛出了catch子句中指定的一个类，那么程序将跳过try语句块中的其余代码，并执行catch语句块中的代码。如果try中的代码没有异常，那么程序就会跳过catch语句。 2.1 finally子句代码抛出一个异常时，就会停止处理这个方法中的剩余代码，但是如果这个方法中存在一些资源需要被清理，就会产生问题。finally子句不管异常有没有被捕获，都会执行。比如下面的例子，所有情况下都会程序都会关闭输入流。 FileInputStream in = new FileInputStream(); try &#123; // blablabla &#125; catch (IOException e) &#123; // blablabla &#125; finally &#123; in.close(); &#125; 2.2 try-with-resources语句对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。关闭资源的常用方式就是在finally块里是释放，即调用close方法。就像我们在2.1节中的例子一样，但是从java7开始，我们可以使用一种更好的方法try-with-resources语句来实现。它的形式如下 try (Resources res = ...) &#123; // blablabla &#125; 我们来看一个具体的例子，读取一个文件中的所有单词。 try (Scanner in = new Scanner( new FileInputStream(&quot;/usr/share/dict/words&quot;), StandardCharsets.UTF_8)) &#123; while (in.hasNext()) &#123; System.out.println(in.next()); &#125; &#125; 3. 使用断言断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查。断言的关键字是assert。有以下两种形式 assert condition; assert condition : expression; 这两种形式都会计算条件，如果结果为false，抛出AssertionError异常。在第二个语句中，表达式将传入AssertionError对象的构造器，并转换成一个消息字符串。 默认情况下，断言是禁用的，需要在运行程序时用-ea启用断言。 参考： 《Java核心技术 卷I》 Java工程师成神之路","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"概述与递归简论","slug":"数据结构与算法/数据结构与算法概述","date":"2020-09-10T12:23:52.000Z","updated":"2020-09-10T12:23:52.000Z","comments":true,"path":"posts/ddb07891.html","link":"","permalink":"https://zhouzhuyan.com/posts/ddb07891.html","excerpt":"本文对数据结构进行了介绍，讲述了什么是数据结构以及数据结构涉及到的3个层面。同时介绍了递归的思想和设计，并讲解了斐波那契数列，排列，汉诺塔问题的递归解决方式。","text":"概述1. 什么是数据结构？我们把这个词分解开来，首先回答什么是数据。数据是信息的载体，是数字，字符或其它符号的集合。数据结构是数据对象和组成对象的数据成员之间的关系。 Data_Structure = &#123;D, R&#125;D是数据对象R是D中所有数据成员的关系 数据结构涉及3个方面：逻辑结构：从用户视图看，是面向问题的物理结构：从具体实现视图看，是面向计算机的操作及其实现我们以一个学生表为例，它的逻辑结构式线性表，物理结构是数组，而操作是增删改查 2. 递归简论2.1 如何设计递归我们通过递归来引入数据结构与算法的学习。当一个函数用它自己来定义时，我们就称它是递归(recursive)的。我们可以看下面这个简单的例子 f(x) = \\begin{cases} 0, & x=0 \\\\\\\\ 2f(x-1)+x^2, & x > 0\\end{cases}我们用代码来实现它 public static int f(int x) &#123; if (x == 0) &#123; return 0; &#125; return 2 * f(x - 1) + x * x; &#125; 观察这段代码，函数体内首先有一个if结构，这是递归的基准情况(base case)，即此时函数的值可以直接算出而不用进行递归。再往下的return语句则进入了递归，要注意的是，递归调用将反复进行直到出现基准情况为止。比如我们计算f(3)，那么会调用f(2), f(1)直到出现基准情况f(0)，它的计算实际上是这样的 (2\\times(2\\times(2\\times f(0)+1\\times1) + 2\\times2)+3\\times3)下面我们再来看一种糟糕的递归设计 public static int bad(int n) &#123; if (n == 0) &#123; return 0; &#125; return bad(n / 3 + 1) + n - 1; &#125; 我们会发现，在上述的代码中，bad(1)被定义为bad(1)，而不知道具体是多少，计算机会反复调用它，程序无法停止，也求不出解。 通过上面的两个例子，可以得出递归的设计准则 基准情形(base case)。必须有某些基准的情形，不用递归就能够求解。 不断推进(make progress) 递归调用必须能够朝着一个基准情形推进。 2.2 递归实践我们通过几个经典的例子来加深对递归的理解。 2.2.1 菲波那切数列我们知道它的函数是$fib(0)=0,\\ fib(1)=1,\\ fib(n)=fib(n-1)+fib(n-2); n&gt;=2$可以很容易地将其用代码表示 public static long fib(long n) &#123; if (n == 0 || n == 1) &#123; // base case return n; &#125; return fib(n - 1) + fib(n - 2); &#125; 2.2.2 排列现在有一个数组&#123;a, b, c&#125;，要求对它进行全排列，即排列结果是abc,acb,bac,bca,cab,cba public class Permutation &#123; public static void permutation(char[] list, int k, int m) &#123; int i; if (k == m) &#123; for (i = 0; i &lt;= m; i++) &#123; System.out.print(list[i]); &#125; System.out.println(); &#125; else &#123; for (i = k; i &lt;= m; i++) &#123; char temp = list[k]; list[k] = list[i]; list[i] = temp; permutation(list, k + 1, m); temp = list[k]; list[k] = list[i]; list[i] = temp; &#125; &#125; &#125; public static void main(String[] args) &#123; char[] list = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; permutation(list, 0, 2); &#125; &#125; 2.2.3 汉诺塔问题汉诺塔问题是一个经典的问题。汉诺塔(Hanoi Tower)，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？64个圆盘对于当前的计算机，可能需要几百上千年才能算出，但是我们可以简化这个问题，使用3个圆盘来看一下如何用递归来实现。 根据我们的递归设计准则，首先要明确基准条件，也就是只有一个圆盘，那很简单，就是把它从第一根柱子移动到第三根柱子，然后设计不断推进的过程，有3根柱子，起点(fromTower)，终点(toTower)，中转(auxTower)。有一个非常易于理解的方式，我们首先将盘从起点移到中转点，这个时候的中转点实际上是终点，再从中转点移到终点，这个时候的中转点实际上是起点，所以设计的两个递归是这样的。 moveDisks(n - 1, fromTower, auxTower, toTower); moveDisks(n - 1, auxTower, toTower, fromTower); 下面是完整的代码实现。 public class HanoiTower &#123; public static void moveDisks(int n, char fromTower, char toTower, char auxTower) &#123; if (n == 1) &#123; System.out.println(&quot;move disk &quot; + n + &quot; from &quot; + fromTower + &quot; to &quot; + toTower); &#125; else &#123; moveDisks(n - 1, fromTower, auxTower, toTower); System.out.println(&quot;move disk &quot; + n + &quot; from &quot; + fromTower + &quot; to &quot; + toTower); moveDisks(n - 1, auxTower, toTower, fromTower); &#125; &#125; public static void main(String[] args) &#123; moveDisks(3, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;); &#125; &#125; 打印结果 move disk 1 from A to C move disk 2 from A to B move disk 1 from C to B move disk 3 from A to C move disk 1 from B to A move disk 2 from B to C move disk 1 from A to C 参考： 《数据结构与算法 Java语言描述》","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://zhouzhuyan.com/tags/%E9%80%92%E5%BD%92/"}]},{"title":"Java 接口","slug":"Java/Java-接口","date":"2020-09-09T01:06:16.000Z","updated":"2020-09-09T01:06:16.000Z","comments":true,"path":"posts/d993c7e9.html","link":"","permalink":"https://zhouzhuyan.com/posts/d993c7e9.html","excerpt":"本文介绍了Java面向对象编程中的另外一个重要概念——接口，介绍了接口的基本含义，属性，接口的回调，以Comparator接口为例展示了如何自定义和使用接口。","text":"接口接口(interface)用来描述类应该做什么，而不指定它们具体该如何做。一个类可以实现(implement)一个或多个接口。 1. 接口的概念接口不是类，而是对希望符合这个接口的类的一组需求 Tip 接口中的所有方法都自动是public，因此在接口中声明方法时，不必提供关键字public 接口绝不会有实例字段 public class Employee implement Comparable&lt;Employee&gt; &#123; // blablabla @Override public int compareTo(Employee other) &#123; return Integer.compare(salary, other.salary); &#125; &#125; 2. 接口的属性接口不是类，不能够使用new实例化一个接口，但是可以声明接口的变量，接口变量必须引用实现这个接口的类对象 Comparable x = new Employee(. . .); Tip为什么需要接口，而不是直接使用抽象类？因为Java不支持多继承，所以每个类只能扩展一个类。而接口提供了多继承的好处，而避免了多重继承的复杂性和低效性。 3. 接口与回调回调(callback)是一种常见的程序设计模式。在这种模式中，可以指定某个特定事件发生时应该采取的动作。比如我们设计了一个时钟，可以请求每秒更新一次，以便更新时钟的表盘。 下面是一个定时器和动作监听的具体使用的例子，定时器启动之后，程序将弹出一个消息对话框，并等待用户点击OK来终止程序的运行，在程序等待用户操作的同时，每隔1秒显示一次当前时间 import java.awt.*; import java.awt.event.*; import java.time.*; import javax.swing.*; public class TimerTest &#123; public static void main(String[] args) &#123; TimePrinter listener = new TimePrinter(); // construct a timer that calls the listener // once every second Timer timer = new Timer(1000, listener); timer.start(); // keep program running until the user selects &quot;OK&quot; JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;); System.exit(0); &#125; &#125; class TimePrinter implements ActionListener &#123; @Override public void actionPerformed(ActionEvent event) &#123; System.out.println(&quot;At the tone, the time is &quot; + Instant.ofEpochMilli(event.getWhen())); Toolkit.getDefaultToolkit().beep(); &#125; &#125; 4. Comparator接口如果我们想要对字符串数组进行排序，可以直接使用String.compareTo方法按字典顺序比较字符串。如果我们希望按照字符串长度来进行比较，可以自己实现一个比较器(comparator)，如下面的例子中，将比较器作为参数传入Arrays.sort方法中。 import java.util.Arrays; import java.util.Comparator; public class LengthCompare &#123; public static void main(String[] args) &#123; String[] friends = &#123;&quot;Adam&quot;, &quot;Ben&quot;, &quot;Peter&quot;, &quot;Noah&quot;&#125;; Arrays.sort(friends, new LengthComparator()); System.out.println(Arrays.toString(friends)); &#125; &#125; class LengthComparator implements Comparator&lt;String&gt; &#123; @Override public int compare(String o1, String o2) &#123; return o1.length() - o2.length(); &#125; &#125; 参考： 《Java核心技术 卷I》","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"Java 继承","slug":"Java/Java-继承","date":"2020-09-08T08:09:47.000Z","updated":"2020-09-08T08:09:47.000Z","comments":true,"path":"posts/8b3a0e63.html","link":"","permalink":"https://zhouzhuyan.com/posts/8b3a0e63.html","excerpt":"本位介绍了Java面向对象编程中的重要思想——继承，包括对超类和子类，对象包装器和继承的设计技巧的介绍。","text":"继承继承(inheritance)的基本思想是基于已经有的类创建新的类，复用这些类的方法。 一、类，超类和子类在前面的文章中我们实现了一个Employee类，假设你在某个公司工作，这个公司的经理和员工的待遇不一样，普通员工在完成任务后仅领取薪水，而经理还拥有奖金。这个时候，我们可以定义一个新类Manager，使用继承重用Employee中的代码，同时定义新的方法来增加奖金这一功能。 TipManager is-a Employeeis-a关系是继承的一个明显特征 1. 定义子类使用extends关键字来表示继承 public class Manager extends Employee &#123; // blablabla &#125; 关键字extends表明正在构造的新类派生于一个已经存在的类。这个类被称为超类(superclass) 或父类(parent class)，新类称为子类(subclass)在设计类时，应该将一般方法放在超类中，将更特殊的方法放在子类中比如我们在Manager类中应该实现一个设置奖金金额的方法。 public class Manager extends Employee &#123; private int bonus; public void setBonus(double bonus) &#123; this.bonus = bonus; &#125; &#125; 2. 覆盖方法超类中的某些方法对子类不一定适用，比如Manager类中的getSalary方法应该返回薪水和奖金的总和，所以要提供一个新的方法来覆盖(override)超类中的某个方法。要注意的是，Manager类的getSalary方法不能够直接访问salary字段，因为其实Employee类的私有字段，所以需要使用super关键字 public int getSalary() &#123; int baseSalary = super.getSalary(); return baseSalary + bonus; &#125; 3. 子类构造器public Manager(int id, String name, int salary) &#123; super(id, name, salary); bonus = 0; &#125; 语句super(id, name, salary);实现了对Employee中私有字段的调用 4. 多态我们可以通过is-a来判断是否将数据设计为继承关系，它的另外一种表述是替换原则，即程序中出现超类对象的任何地方都可以使用子类对象替换。 在Java中，对象变量时多态(polymophic)的。一个Employee类型的变量既可以引用一个Employee类型的对象,也可以引用Employee类的任何一个子类的对象(比如Manager) Employee e; e = new Employee(1, &quot;A&quot;, 10000); e = new Manager(2, &quot;B&quot;, 20000); 虽然这里的e引用了Manager类型的对象，但是编译器只将e看成是一个Employee对象，所以如下的调用是错误的。 e.setBonus(10000); // ERROR 5. 阻止继承: final类和方法如果我们需要阻止某个类被继承，可以使用final关键字 public final class Child extends Father &#123; // blablabla &#125; 类中的某个特定的方法也可以声明为final，这样子类就不能够覆盖这个方法。 Tip为什么要将类或方法声明为final？确保它们不会在子类中改变语义。比如String类是final类，所以一个String引用引用的一定是String对象，而不是其它。 6. 抽象类在继承层次结构中，位于上层的类更具有一般性比如我们加入Person类和Student类，下图是这三个类之间的继承关系 每个人都有一些属性，比如姓名，年龄，引入一个公共的超类，就可以把getName方法放在继承层次结构中的更高一层，使用abstract关键字来定义抽象类 public abstract class Person &#123; private String name; public Person (String name) &#123; this.name = name; &#125; public abstract String getDescription(); public String getName() &#123; return name; &#125; &#125; 抽象类不能够实例化，如下的表达式是错误的 new Person(); // ERROR 二、对象包装器与自动装箱所有的基本类型都有一个与之对应的类，这些类被称为包装器(wrapper)，分别是Integer, Long, Float, Double, Short, Byte, Character, Boolean。包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值，同时，包装器还是final，不能够派生它们的子类。 Tip为什么需要包装类？因为Java是一种面向对象程序设计语言，很多地方需要使用对象而不是基本类型。比如在ArrayList中，我们不能够写成ArrayList&lt;int&gt;，而要写成ArrayList&lt;Integer&gt;。 2. 自动拆箱与装箱自动装箱: 就是将基本数据类型自动转换成对应的包装类。自动拆箱：就是将包装类自动转换成对应的基本数据类型。 Integer n = 3; // 自动装箱 int m = n; // 自动拆箱 三、继承的设计技巧 将公共操作和字段放在超类中 使用继承实现is-a关系 除非所有继承的方法都有意义，否则不要使用继承 在覆盖方法时，不要改变预期的行为 使用多态，而不要使用类型信息 参考： Java工程师成神之路 《Java核心技术 卷I》","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"Java 面向对象概述","slug":"Java/Java面向对象概述","date":"2020-09-04T08:08:48.000Z","updated":"2020-09-04T08:08:48.000Z","comments":true,"path":"posts/e27767b2.html","link":"","permalink":"https://zhouzhuyan.com/posts/e27767b2.html","excerpt":"本文介绍了Java面向对象的相关内容，包括面向对象的思想和特点，类的使用以及静态变量和方法。","text":"对象与类概述一、面向对象程序设计概述结构化程序：算法+数据结构 = 程序 （即确定如何操作数据，再决定如何组织数据的结构） 面向对象程序设计(OOP)：将数据放在第一位，再考虑操作数据的算法 1. 类 类(class)是构造对象的模板或蓝图，就好像一个制作某件工艺品的模具，对象就是工艺品 由类构造(construct)对象的过程称为创建类的实例(instance) 封装(encapsulation)将数据和行为组合在一个包中，对对象的使用者隐藏具体的实现方式，也称为数据隐藏 对象中的数据称为实例字段(instance field)，操作数据的过程称为方法(method) 对象拥有的实例字段值的集合就是这个对象的当前状态(state) 程序只能通过对象的方法和对象数据进行交互，对象被赋予了“黑盒”的特征，提高了重用性和可靠性 可以通过扩展一个类来构建新的类，这使得用户自定义类更加容易。在Java中，所有类都来自于一个超类，即Object。 通过扩展一个类来建立一个新的类的过程就是继承(inheritance)，新类具有被扩展的类的全部属性和方法，可以自定义新的属性和方法。 2. 对象对象的3个特性： 行为(behavior)——可以对对象完成的操作（应用的方法） 状态(state)——描述当前状况的信息，状态的改变必须通过调用方法实现 标识(identity)——每个对象有唯一的标识来区分（如两个订单的编号肯定不相同） 3. 识别类编写程序从识别类开始，然后为各个类添加方法。 一个简单的方法是在分析问题的过程中寻找名词——类，寻找动词——方法 例如我们有商品，订单，账户这样的名词作为类，即Item，Order，Account 那么在账户这个类中，就可以有增加账户，修改账户等方法。 4. 类之间的关系类之间最常见的关系有： 依赖（”uses-a“） 聚合 （”has-a“） 继承（“is-a”) 4.1 依赖（dependence）如果一个类的方法使用或操纵另一个类的对象，我们就可以说一个类依赖于另一个类 比如Order对象访问Account对象查看信用状态，这就是一个使用(“uses-a”)的关系。 （尽可能减少相互依赖的类，做到低耦合） 4.2 聚合（aggregation）类A的对象包含（”has-a”）类B的对象 如一个Order对象就包含了一些Item对象 4.3 继承（inheritance）一个更特殊的类与一个更一般的类之间的关系 也就是前面提到的扩展，比如现在我们定义一个加急订单RushOrder类，那么它是一个（”is-a”)Order类 也就是有Order类继承而来。 下图展示了上述的三种关系。 二、使用预定义类我们通过可以Java中的预定于类来了解如何构造对象，以及如何使用类的方法。如下的例子： import java.util.Date; public class DateTest &#123; public static void main(String[] args) &#123; Date birthday = new Date(); System.out.println(birthday.toString()); &#125; &#125; 在Java中，要使用构造器(constructor)来构造新的实例，比如上面的代码中new Date()就构造了一个新的对象，这个对象被初始化为当前的日期和时间。 Tip需要注意的是，单独的定义Date birthday中的birthday并不是对象，对它进行操作编译器会报错。一定要初始化变量birthday。对象变量本身并不包含一个对象，而是引用一个对象，new操作符的返回值也是一个引用。 三、自定义类1. 对象与对象变量要想使用对象，就需要先构造对象，并指定其初始状态。在Java中，使用构造器（构造函数）来构造。 比如某公司有一个职员管理系统，其中有一个关于职员信息的类Employee 那么我们可以通过下面这个表达式构造一个新对象 Employee employee = new Employee(1, &quot;Allen&quot;, 10000); 其中employee是一个对象变量，我们用new Employee(int id, String name, int salary)构造了一个新对象，初始化该对象变量，要注意的是对象变量并没有包含一个对象，而是引用一个对象。 在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。 public class Employee &#123; private int id; private String name; private int salary; public Employee(int id, String name, int salary) &#123; this.id = id; this.name = name; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public int getSalary() &#123; return salary; &#125; public static void main(String[] args) &#123; Employee[] staff = new Employee[3]; staff[0] = new Employee(1, &quot;Allen&quot;, 10000); staff[1] = new Employee(2, &quot;Ben&quot;, 12000); staff[2] = new Employee(3, &quot;David&quot;, 15000); for (Employee e : staff) &#123; System.out.println(&quot;id=&quot; + e.getId() + &quot;,name=&quot; + e.getName() + &quot;,salary=&quot; + e.getSalary()); &#125; &#125; &#125; /** Output: id=1,name=Allen,salary=10000 id=2,name=Ben,salary=12000 id=3,name=David,salary=15000 */ 2. 构造函数构造函数，与类同名，将实例初始化为指定的初始状态 public Employee(int id, String name, int salary) &#123; this.id = id; this.name = name; this.salary = salary; &#125; Tip 构造函数根据参数的不同可以有多个， 构造函数没有返回值。 4. 封装的优点如下是一个访问器方法，又称为字段访问器 public int getId() &#123; return id; &#125; Tip为什么不直接将这些变量设为public公共访问呢？因为这样的话这些变量就可以轻易的被外界修改，受到破坏比如这里的职员id应该是只读的，不能够设置为public被外界随意更改。 4. final定义为final的实例字段必须在构造对象时初始化，否则编辑器会报错，顾名思义，final表示最终的，在初始化之后不能够再修改这个值。 private final String name = &quot;John&quot;; Tipfinal修饰符对于基本类型和不可变类，如String类适用，但是对于可变的类，如StringBuilder就会出现问题，因为它仅仅保证了引用不会指向另外一个对象，但是这个对象是可以更改的。 四、静态字段和静态方法1. 静态字段回到我们之前的Employee类中，如果我们需要一个变量来记录公司有多少雇员，就可以使用static修饰符，定义一个静态变量 private static int count; 静态变量是属于类的变量，而不属于单个对象，对于Employee类的所有实例，共享一个count。而对非静态的变量，每个对象都有一个自己的副本 2. 静态常量Math类中定义了一个静态常量PI public class Math &#123; public static final double PI = 3.1415926535897932846; &#125; 我们可以通过Math.PI来直接访问它，如果没有static，那么就需要创建Math类的对象来访问它，效率比较低。 3. 静态方法如果我们想要知道公司的雇员人数，就可以使用静态方法 public static int getCount() &#123; // 返回静态变量 return count; &#125; 使用静态方法的两种情况： 方法不需要访问对象状态 方法只需要访问类的静态字段（比如上面的例子）","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"Hexo部署到云服务器","slug":"Hexo/Hexo部署到云服务器","date":"2020-09-03T14:57:59.000Z","updated":"2020-09-03T14:57:59.000Z","comments":true,"path":"posts/e80e623c.html","link":"","permalink":"https://zhouzhuyan.com/posts/e80e623c.html","excerpt":"","text":"0. 准备工作博客的搭建和域名的绑定可以参考我以前的博客。使用Github pages + Hexo搭建个人博客Hexo个人博客绑定域名 由于博客是基于Github pages搭建的，所以在国内的访问速度比较慢，可以部署到云服务器上加快访问的速度，我使用的是腾讯云学生机。注意在国内使用云服务器部署网站需要对网站进行备案，详细步骤可以参考腾讯的官方文档。在备案完成后，就可以进行网站的部署了。 1. 配置gitTip我的服务器型号是CentOS 7.5 1.1 安装gityum install -y git 看到complete字样说明安装完成了，可以通过如下命令验证 git --version 出现版本则说明安装成功。 1.2 创建git账户adduser git passwd git 注意一定要有第二步passwd git，这是给git账户设置密码，否则账户不会使用。 1.3 设置免密登录git使用su命令切换至git用户，并进入用户git的根目录 su git cd 创建~/.ssh文件夹和~/.ssh/authorized_keys文件 mkdir ~/.ssh touch ~/.ssh/authorized_keys 将本地的id_rsa.pub文件中的公匙复制到authorized_keys文件中，在mac中，该文件的地址是/Users/你的用户名/.ssh/id_rsa.pub，可以在终端中使用如下命令打开.ssh文件夹，然后使用vs code打开该文件 open /Users/galahad/.ssh 复制其中的内容，然后打开authorized_keys文件 vi ~/.ssh/authorized_keys 按i进入插入模式，复制内容按esc键进入命令模式，输入:wq保存并退出最后对文件赋予对应的权限 chmod 600 /home/git/.ssh/authorized_keys chmod 700 /home/git/.ssh 这样就可以使得本地终端可以免密登录git用户，可以在本地终端使用ssh远程连接测试 ssh git@你的IP 如果仍需输入密码，那说明配置有问题，可以重新按照1.3的步骤再配置一遍，当然，1.3的部分不是必须的，这只是为了在本地提交文件到服务器的时候不用输入密码，省点儿力气。 1.4 配置git仓库在git用户的根目录下创建hexo存储的目录 mkdir -p projects/blog 再创建一个git仓库，并初始化一个仓库 mkdir repos cd repos git init --bare blog.git 之后，在blog.git文件夹下会产生一个hooks文件夹，在其中创建一个文件post-receive，在其中配置一个钩子 cd blog.git/hooks vi post-receive 将如下内容复制到其中 #!/bin/sh git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f 保存退出之后，赋予文件可执行权限 chmod +x post-receive 然后输入exit回到root用户下，输入如下命令 chown -R git:git /home/git/repos/blog.git 配置完仓库后，可以在本地使用git clone命令测试是否能够成功克隆仓库 git clone git@server_ip:/home/git/repos/blog.git 2 配置Nginx2.1 安装Nginxyum install -y nginx 启动nginx nginx 2.2 配置文件先暂停服务 nginx -s stop 进入nginx目录，编辑配置文件 cd /etc/nginx vi nginx.conf 注意要修改两个地方，一个是将user nginx改为user root第二个就是在server的位置，添加root解析路径/home/git/projects/blog/，如果你已经有了域名，那么在server_name后面添加上你的域名。其它保持不变。 server &#123; listen 80 default_server; listen [::]:80 default_server; server_name zhouzhuyan.com www.zhouzhuyan.com; root /home/git/projects/blog/; index index.html index.htm; &#125; 保存退出重新启动nginx systemctl restart nginx 2.3 检查检查nginx状态 systemctl status nginx 如果看到绿色的active就表示配置成功了。我在这里遇到了一个问题，它的状态显示红色的failed,，错误是98: Address already in use，80端口已经被占用，这个时候可以用如下命令检查一下是谁占用了80端口 netstat -ntpl 如果就是nginx的话，应该是由于之前的配置文件中，listen 80 default_server;监听ipv4的80端口，而listen [::]:80 default_server;监听的是ipv6的80端口，于是就重复占用了。可以在配置文件中这样更改 listen [::]:80 ipv6only=on default_server; 然后重启nginx应该就可以了。 3. Hexo本地配置hexo的站点配置文件_config.yml deploy: type: git repo: git@你的IP:/home/git/repos/blog.git branch: master 然后进行部署 hexo clean hexo g -d 4. 启用https由于nginx默认使用的是http，所以在网站访问的时候，会显示不安全，可以通过配置来开启https 4.1 申请SSL证书阿里云和腾讯云都提供免费的SSL证书下载，因为我的域名是在腾讯云云购买的，所以我就从腾讯云上下载了SSL证书 4.2 传输文件到服务器从腾讯云上下载证书到本地，会得到一个自己域名命名的文件夹，里面有Apache，Nginx，Tomcat，IIS的证书，由于我们使用的是nginx服务，所以只需要Nginx文件夹内的xxx.crt和xxx.key两个文件。在服务端创建文件夹存储证书 mkdir /home/git/SSL 我们可以使用scp命令将本地的文件传输到服务器 scp -r xxx/Nginx git@你的IP /home/git/SSL 4.3 配置nginx然后再次编辑nginx.conf文件，这里可以参考官方文档Nginx 服务器证书安装，文档写的很清晰，按照其中的步骤配置一下就可以完成了。之后我们就可以通过https访问网页，在网址旁边会出现一把锁。 参考：[1]HJX.将Hexo部署到阿里云轻量级服务器(保姆级教程)[EB/OL].https://hjxlog.com/posts/20191130a1.html,2019-11-30.[2]Dreamy.TZK.将Hexo部署到云服务器[EB/OL].https://cloud.tencent.com/developer/article/1632020,2020-05-25.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"策略模式","slug":"设计模式/策略模式","date":"2020-09-02T04:29:06.000Z","updated":"2020-09-02T04:29:06.000Z","comments":true,"path":"posts/72e3b671.html","link":"","permalink":"https://zhouzhuyan.com/posts/72e3b671.html","excerpt":"","text":"策略模式 问题：假设有一个模拟鸭子的游戏，游戏中拥有各种鸭子，我们设计了一个鸭子的超类，并且让各种鸭子，比如红头鸭，橡皮鸭等，继承它。现在，我们需要更新这个游戏，使得鸭子可以飞起来，该怎么做？ 使用继承？如果依然使用继承，在超类中添加一个fly()方法，会出现不适合该行为的子类也具有该行为的问题，比如橡皮鸭就不会飞，但继承的做法使得它也可以飞起来。 如果选择覆盖fly()方法，那么在后续的更新中，我们需要不断地检查可能需要覆盖的fly()方法。所以使用继承来提供行为，会造成代码在多个子类最终重复，复用性差，难以知道鸭子的全部行为，运行时的行为不容易改变等问题。 使用接口？如果抽象出一个Flyable接口，只有会飞的鸭子才实现这个接口呢？设想一下，如果我们有上百种会飞的鸭子，那么就会造成大量的代码重复，每个子类中都要实现一次fly()方法，而且代码无法复用，如果我们需要修改这个方法，想象一下，这简直就是一场灾难。 策略模式实现软件开发过程中总是伴随着变更。设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码放在一起。也就是说我们把会变化的部分取出并封装起来，以便以后的改动和扩充。 分离变化与不变的部分在鸭子类中，我们可以发现fly()和quack()两个方法经常需要修改，那么我们就可以建立两组远离Duck类的类，一个与fly相关，一个与quack相关，每一组类实现各自的动作，比如让一个类实现“呱呱叫”，一个类实现“吱吱叫”，还有一个类实现“安静” 设计行为设计原则 针对接口编程，而不是针对实现编程用接口代表每个行为，鸭子类不会实现Flying的接口，而是制造一组专门的类来实现FlyBahavior public interface FlyBehavior &#123; public void fly(); &#125; 实现行为现在有一个FlyBehavior接口，还有对应的类，负责实现具体的行为。 public class FlyWithWings implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(&quot;I&#x27;m flying.&quot;); &#125; &#125; public class FlyNoWay implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(&quot;I can&#x27;t fly&quot;); &#125; &#125; 整合行为鸭子将飞行的动作委托给别人处理，而不是在鸭子类内部定义飞行方法。在鸭子类中加入实例变量flyBahavior，声明为接口类型。 public abstract class Duck &#123; FlyBehavior flyBehavior; public abstract void display(); public void performFly() &#123; flyBehavior.fly(); &#125; &#125; 每个鸭子对象都会动态的设置这些变量以在运行时引用正确的类型。 public class MallardDuck extends Duck &#123; public MallardDuck() &#123; flyBehavior = new FlyWithWings(); // 使用FlyWithWings作为FlyBehavior类型 &#125; @Override public void display() &#123; System.out.println(&quot;I&#x27;m a real Mallard duck.&quot;); &#125; &#125; 测试 public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck mallard = new MallardDuck(); mallard.performFly(); &#125; &#125; // Output: I&#x27;m flying. 动态设定行为如果想要在运行时改变鸭子的行为，只需要调用鸭子的setter方法就可以了。我们在鸭子类中增加设定方法 public void setFlyBehavior(FlyBehavior fb) &#123; flyBehavior = fb; &#125; 创造一个新的类模型鸭 public class ModelDuck extends Duck &#123; public ModelDuck() &#123; flyBehavior = new FlyNoWay(); &#125; @Override public void display() &#123; System.out.println(&quot;I&#x27;m a model duck.&quot;); &#125; &#125; 建立一个新的FlyBehavior类型 public class FlyRocketPowered implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(&quot;I&#x27;m flying with a rocket.&quot;); &#125; &#125; 测试调用setter方法，改变了模型鸭的飞行行为 public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck model = new ModelDuck(); model.performFly();; model.setFlyBehavior(new FlyRocketPowered()); model.performFly(); &#125; &#125; /* Output: I can&#x27;t fly; I&#x27;m flying with a rocket. */ 每一个鸭子都有一个(HAS-A)FlyBahavior，将飞行委托给它处理。设计原则 多用组合，少用继承使用组合建立系统具有很大的弹性，可以将算法族封装成类，还可以在运行时动态地改变行为。 策略模式小结意图定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。使得算法可以独立于它的客户变化。 适用 许多相关的类仅仅只是行为有差别，比如鸭子类中的飞行 需要使用一个算法的不同变体 算法使用客户不应该知道的数据 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现（switch或if） 结构与参与者 Strategy (策略)定义所有支持的算法的公共接口，Context使用这个接口来调用ConcreteStrategy定义的算法，比如FlyBehavior就是一个策略ConcreteStrategy(具体策略)以Strategy接口实现某具体的算法，比如FlyWithWings,FlyNoWay等Context (上下文) 用一个ConcreteStrategy对象来配置 维护一个对Strategy对象的引用 可定义一个接口让Strategy来访问它的数据比如Duck类 效果优点 相关算法系列 Strategy类层次为Context定义了一系列可供复用的算法或行为 替代继承的方法 使用继承可以直接生成一个Context的子类，给它不同的行为，但这样会使得Context难以理解，维护和扩展，不能动态改变算法。而将算法封装在独立的Strategy类中使得我们可以独立于Context改变它，易于理解，修改和扩展。 消除可一些条件语句 含有许多条件语句的代码通常需要使用策略模式 实现的选择 策略模式可以提供相同行为的不同实现供客户选择 缺点 客户必须了解不同的策略 需要向客户暴露具体问题，所以只有当不同行为的变体与客户有关时，才使用策略模式 Strategy和Context之间的通信开销 增加了对象的数目","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhouzhuyan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"策略模式","slug":"策略模式","permalink":"https://zhouzhuyan.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"Hexo个人博客绑定域名和配置SSL证书","slug":"Hexo/Hexo个人博客绑定域名和配置SSL证书","date":"2020-04-09T13:29:25.000Z","updated":"2020-04-09T13:29:25.000Z","comments":true,"path":"posts/2cd2c226.html","link":"","permalink":"https://zhouzhuyan.com/posts/2cd2c226.html","excerpt":"Hexo 个人博客绑定域名和配置SSL证书在完成个人博客的搭建以后，我们可以通过一个https://xxx.github.io形式的链接在访问我们的个人博客网站，那么如果想拥有一个个性的域名，该如何操作呢？","text":"Hexo 个人博客绑定域名和配置SSL证书在完成个人博客的搭建以后，我们可以通过一个https://xxx.github.io形式的链接在访问我们的个人博客网站，那么如果想拥有一个个性的域名，该如何操作呢？ 一、 绑定域名1. 购买域名可以在阿里云或者腾讯云上购买，不同形式的有不同的价格，根据自己的情况购买即可。我在腾讯云上购买了我现在的域名zhouzhuyan.com 注意：如果不使用国内的服务器的话不用备案，只要完成实名认证就可以了。 现在实名认证，审核都很快，虽然说一个工作日审批，但是我的话几分钟成功了。在域名的状态显示正常以后，就可以使用了。 2. 域名解析这个时候，网站时访问不了的，因为还需要去解析你的域名，将你的域名指向你的个人网站。 到腾讯云控制台的域名管理界面，找到你的域名，点击解析，选择添加记录 主机记录 记录类型 线路类型 记录值 www CNAME 默认 你的Github项目仓库名 @ CNAME 默认 你的Github项目仓库名 两个主机记录是为了让你的网站在有www和没有的情况下都可以访问，仓库名可以在Github仓库的Settings里面找到。解析需要10分钟，耐心等待。 3. 在项目中更换到Github中找到自己的网站所在的仓库，进入Settings界面 在Custom domain里面填写自己的域名，选择save，这样就会出现上图的形式，显示Your site is published at https://你的域名，勾选Enforce HTTPS 4. 创建CNAME文件进入你的Hexo本地文件所在的根目录，找到\\source目录，在里面创建一个文件CNAME，注意它是没有类型的，不是.txt。 在里面加入你的域名，注意不要在前面加入https www这样的前缀，就是你的域名。 然后hexo d -g部署你的网站，等待一段时间后，就可以通过你的个性域名访问网站了。 二、 SSL安全证书注册好域名后，用google访问时，可能会出现您访问的不是安全链接的提示，或者能够正常访问，但是域名旁边显示的是一个感叹号，表示不安全，这是因为我们还没有申请安全证书，在申请了证书之后，域名旁边显示的就是一把锁，表示安全。 腾讯云和阿里云都提供免费的SSL证书下载，具体安装也有相关的文档，按照步骤操作就行。 腾讯云Nginx服务器证书安装 Mac下nginx的使用 在证书安装好了以后，可以看到域名解析里面多出了一条TXT类型的解析。 在Chrome浏览器中，打开网站后如果仍然显示不安全，即没有出现锁的图标，右击选择检查元素，进入开发者模式，看Security里面有什么问题。 踩坑：我发现我用阿里云图床的图片引用的是http头，把它改为https，锁就出现了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"C++字符串,向量和数组","slug":"C++/字符串-向量和数组","date":"2020-04-03T14:03:24.000Z","updated":"2020-04-03T14:03:24.000Z","comments":true,"path":"posts/869e4b19.html","link":"","permalink":"https://zhouzhuyan.com/posts/869e4b19.html","excerpt":"二、字符串，向量和数组作用域操作符:: 含义：编译器应从操作符左侧的作用域中寻找右边那个名字 比如std::cin是要使用命名空间std中的cin 这样做是为了避免某些名字被重复使用 使用using声明可以更加简便的使用命名空间中的成员。","text":"二、字符串，向量和数组作用域操作符:: 含义：编译器应从操作符左侧的作用域中寻找右边那个名字 比如std::cin是要使用命名空间std中的cin 这样做是为了避免某些名字被重复使用 使用using声明可以更加简便的使用命名空间中的成员。 1. String类型表示可变长的字符串 1.1 定义和初始化 使用需要头文件和命名空间 #include&lt;string&gt; using std::string; 初始化 string s1; // 空字符串 string s2 = s1; // s2是s1的副本 string s3 = &quot;abc&quot;; string s4(10, &#x27;c&#x27;); // 十个c 1.2 string对象上的操作 使用getline读取一整行 string line; getline(cin, line); 当读取到换行符时结束，并将读到的内容存入string中，但是不存换行符 empty和size操作 str.empty()根据字符串是否为空返回一个布尔值 str.size()返回字符串长度 使用visual studio编程的时候，碰到过一个warning，将无符号数赋值给了有符号数。 这是由于size函数的返回值类型引起的，它是一个string::size_type类型的值，是无符号类型的， 可以用auto来推断变量的值 auto len = str.size(); 比较，赋值，相加 string s1 = &quot;abc&quot;; string s2 = &quot;xcvd&quot;; // s1 &lt; s2 比较第一个不同的字符 string s3 = s1; // 赋值 string s4 = s1 + s2; // abcxcvd 处理string中的字符 #include&lt;cctype&gt; isalnum(c); isalpha(c); islower(c); isupper(c); ispunct(c); // 是标点符号为真 2. Vector类型可变长数组，类似于Java中的ArrayList 2.1 初始化vector&lt;T&gt; v; vector&lt;T&gt; v1 = &#123;a, b, c&#125;; // 注意是花括号 vector&lt;T&gt; v2&#123;a, b&#125;; // 花括号，两个元素 vector&lt;int&gt; v3(10, 1); // 圆括号 10个元素，每个初始化为1 2.2 操作vector&lt;int&gt; v; v.push_back(1); // 添加1 v.pop_back(); // 去掉最后一个数据 v.empty(); v.size(); v[n]; // 注意下标只能访问，但是不能够添加元素 3. 迭代器访问元素的作用 string s = &quot;abcde&quot;; if (s.begin() != s.end()) &#123; // 确保s非空 &#125; 4. 数组4.1 指针和数组int ia[] = &#123;1, 2, 3, 4, 5&#125;; auto p(ia); // 整型指针，指向ia的第一个元素 p++; // 指向第一个元素","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]},{"title":"Hexo-Permalink简化","slug":"Hexo/Hexo-Permalink简化","date":"2020-04-03T12:59:43.000Z","updated":"2020-04-03T12:59:43.000Z","comments":true,"path":"posts/838443af.html","link":"","permalink":"https://zhouzhuyan.com/posts/838443af.html","excerpt":"Permalink简化在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章 阮一峰 关于url编码 有两种方法优化。","text":"Permalink简化在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章 阮一峰 关于url编码 有两种方法优化。 方法一：自定义首先，在scaffolds的post.md中，加入urlname元素。 title: &#123;&#123; title &#125;&#125; urlname: date: &#123;&#123; date &#125;&#125; tags: categories: 然后，在配置文件_config.yml中，将永久链接permalink的形式改为 permalink: :category/:urlname/ 也就是类别加上自定义的url链接。 每次写文章时，可以自己设计该页的url，使得它变得简单，同时也利于区分。 但是，这种修改方法的链接会随着文件目录的改变而改变， 比如一篇文章HelloWorld.md本来放在_posts目录下，链接为https://xxx/_posts/HelloWorld.md 之后归类到_posts/A目录下，那么链接变为https://xxx/_posts/A/HelloWorld.md 这样不太利于分享，所以推荐使用第二种方法。 方法二：插件使用hexo-abbrlink这个插件 安装 npm install hexo-abbrlink --save 设置 在_config.yml文件中修改永久链接格式 permalink: posts/:abbrlink.html abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex posts部分是可以更改的，也可以仿照方法一添加一个关键词便于识别 permalink: :keywords/:abbrlink.html 生成 在根目录创建Gruntfile.js文件，让插件到source/_posts/下读取所有的.md文件，把文件中的@@abbrlink替换成文件内容的hash值。 module.exports = function(grunt) &#123; grunt.initConfig(&#123; rewrite: &#123; abbrlink: &#123; src: &#x27;source/_posts/**/*.md&#x27;, editor: function(contents, filepath)&#123; const crypto = require(&#x27;crypto&#x27;); const hash = crypto.createHash(&#x27;sha256&#x27;); hash.update(contents); var hashValue = hash.digest(&#x27;hex&#x27;); return contents.replace(/@@abbrlink/g, hashValue.substring(0, 16)); &#125; &#125;, &#125;, &#125;); grunt.loadNpmTasks(&#x27;grunt-rewrite&#x27;); &#125;; 这种方法生成的链接是不带目录的，直接就是第二步设置中permalink的样式，所以也没有了被改变的风险。 参考 http://blog.jvaeyhcd.wang/posts/05c9df7e0c47bd64.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"C++变量和基本类型","slug":"C++/变量和基本类型","date":"2020-04-03T12:44:47.000Z","updated":"2020-04-03T12:44:47.000Z","comments":true,"path":"posts/96db5496.html","link":"","permalink":"https://zhouzhuyan.com/posts/96db5496.html","excerpt":"变量和基本类型1. 复合类型(Compound type)基于其它类型定义的类型 1.1 引用(Reference)引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。","text":"变量和基本类型1. 复合类型(Compound type)基于其它类型定义的类型 1.1 引用(Reference)引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。 (在这里，引用指的是左值引用) int ival = 1024; int &amp;refval = ival; // refval指向ival，是ival的另外一个名字 int &amp;refVal2; // 报错；引用必须被初始化 定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。（与初始化变量时不同的） 无法令引用重新绑定到另一个对象，所以引用必须被初始化 引用即别名，它不是对象，而是为了一个已经存在的对象起了另外一个名字 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的 refVal = 2; // 把2赋值给与refVal绑定的对象上，这里就是绑定到iVal上 int ii = refVal; 除了两种特殊情况，其它所有引用的类型都要与之绑定的对象严格匹配。不能够与字面值或表达式的计算结果绑定。 int &amp;refVal4 = 10; // 错误：引用对象初始值必须是一个对象 double dval = 3.14; int &amp;refVal5 = dval; // 错误：此处引用类型的初始值必须是int型对象 1.2 指针指针是指向另外一种类型的符合类型，与引用类似，指针实现了对其它对象的间接访问。 不同： 指针本身是一个对象 指针无需在定义时赋初值 int *ip1; // ip1是指向int对象的指针 获取对象的地址指针存放某个对象的地址。 int ival = 42; int *p = &amp;ival; // p是存放变量ival的地址，或者说p是指向引用的指针。 指针值指针的值（即地址）应该属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针 无效指针 利用指针访问对象如果指针指向了一个对象，可以使用解引用符（操作符*）来访问对象 int ival = 42; int *p = &amp;ival; cout &lt;&lt; *p // 输出42 *p = 0; cout &lt;&lt; *p // 输出0，为*p赋值实际上是为p所指的对象赋值 空指针int *p1 = nullptr; int *p2 = 0; int *p3 = NULL; // 需要头文件cstdlib void*指针用于存放任意对象的地址，不能直接操作void*指针所指的对象 指向指针的指针指向指针的引用指针是对象，所以存在对指针的引用 int i = 42; int *p; int *&amp;r = p; // r是一个对p的引用 r = &amp;i; // r引用了一个指针，因此给r赋值&amp;就是令p指向i *r = 0; // 将i的值改为0 2. const限定符值不能被改变，所以const对象必须被初始化 const int bufSize = 512; // 输入缓冲区大小 如果要在多个文件之间共享const，必须在变量定义前加extern关键字 2.1 对const的引用对常量的引用，不能够修改其绑定的对象 对const的引用可以使一个并非const的对象，但是不能通过其改变值 const int ci = 1024; const int &amp;r1 = ci; // 正确 r1 = 42; // 错误：r1是对常量的引用 int &amp;r2 = ci; // 错误：非常量引用指向一个常量对象 int i = 42； const int &amp;r1 = i; // 允许将const int&amp;绑定到一个普通的int上 r1 = 10; // 错误 3. 处理类型3.1 类型别名某种类型的同义词，使得复杂的类型名字变得简单，易于理解和使用。 typedef double wages; // wages是double的同义词 using SI = Sales_item; // SI是Sales_item的同义词 3.2 auto类型说明符让编译器分析表达式所属的类型，必须有初始值 auto item = val1 + val2; // 由val1和val2相加的结果推断item的类型 // auto一条声明语句只能有一个基础数据类型 auto i = 0, *p = &amp;i; // 正确 auto sz = 0, pi = 3.14; // 错误，sz和pi的类型不一致 4. 自定义数据结构将一组相关的数据元素组织起来然后使用他们的策略和方法 struct Sales_data &#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0; &#125; Sales_data accum;","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]},{"title":"使用Github pages+Hexo 搭建个人博客","slug":"Hexo/使用Github-pages-Hexo-搭建个人博客","date":"2020-04-01T17:56:42.000Z","updated":"2020-04-01T17:56:42.000Z","comments":true,"path":"posts/ae6c038e.html","link":"","permalink":"https://zhouzhuyan.com/posts/ae6c038e.html","excerpt":"Github pages + Hexo 搭建个人博客2019年11月19日，我决定开始写博客，首先要用github pages+hexo搭建一个个人博客，其中的过程我就记录在这里面。","text":"Github pages + Hexo 搭建个人博客2019年11月19日，我决定开始写博客，首先要用github pages+hexo搭建一个个人博客，其中的过程我就记录在这里面。 准备工作 注册一个 GitHub 账户 安装 Node.js下载链接 https://nodejs.org/en/download/ 下面这个是中文网，对于国内用户来说下载速度非常快。 http://nodejs.cn/download/ 推荐菜鸟教程关于node的安装教程以及简易的语法介绍https://www.runoob.com/nodejs/nodejs-install-setup.html 安装git markdown语法学习https://www.jianshu.com/p/191d1e21f7ed git语法学习推荐廖雪峰的git教程https://www.liaoxuefeng.com/wiki/896043488029600 安装在终端检查node和npm的版本情况 node -v npm -v 然后输入命令安装hexo npm install -g hexo-cli 我使用的是Mac电脑，在这一步出现了问题，终端显示如下 rollbackFailedOptional verb npm-session 然后我又等了一会儿，终端又报错了。 npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules npm ERR! code EACCES npm ERR! syscall access npm ERR! path /usr/local/lib/node_modules npm ERR! errno -13 npm ERR! Error: EACCES: permission denied, access &#x27;/usr/local/lib/node_modules&#x27; npm ERR! [Error: EACCES: permission denied, access &#x27;/usr/local/lib/node_modules&#x27;] &#123; npm ERR! stack: &quot;Error: EACCES: permission denied, access &#x27;/usr/local/lib/node_modules&#x27;&quot;, npm ERR! errno: -13, npm ERR! code: &#x27;EACCES&#x27;, npm ERR! syscall: &#x27;access&#x27;, npm ERR! path: &#x27;/usr/local/lib/node_modules&#x27; npm ERR! &#125; npm ERR! npm ERR! The operation was rejected by your operating system. npm ERR! It is likely you do not have the permissions to access this file as the current user npm ERR! npm ERR! If you believe this might be a permissions issue, please double-check the npm ERR! permissions of the file and its containing directories, or try running npm ERR! the command again as root/Administrator. 根据官方文档，如果在尝试安装 Hexo 的过程中出现 EACCES权限错误，要遵循由npmjs发布的指导修复该问题。强烈建议不要使用 root、sudo 等方法覆盖权限。根据要求，下载了nvm，并且在终端利用nvm下载了最新版本的node和更新了npm后，hexo下载成功了。（以下是下载和使用nvm的教程链接）https://github.com/nvm-sh/nvm. 建站输入以下命令hexo就会出现在指定的文件夹中 hexo init &lt;folder&gt; cd &lt;folder&gt; npm install 如果出现错误 -bash: syntax error near unexpected token `newline&#x27; 这是占位符的问题，将第一行命令的&lt;&gt;去除，再重新输入即可。 到此，建站的基本操作就完成了。 界面的设计等就可以由自己来操作了。放一个hexo的官方网站供大家参考。https://hexo.io/zh-cn/docs/configuration 创建Github远程仓库注意仓库名为github的用户名.github.io，勾选readme 创建之后，进入仓库，点击Settings按钮，然后翻到GitHub Pages的部分，点击网页链接，就能够看到一个简易的网页了。 部署hexo进入本地的hexo文件，找到 _config.yml，打开后翻到最后，修改成 deploy: type: git repo: gitHub: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git branch: master repo后面的内容要修改成自己github仓库的SSH密匙。 然后在终端中输入 npm install hexo-deployer-git --save 开始安装hexo-deploy-git，安装完成后，开始部署，在终端中输入 hexo deploy 部署完成。 测试这个时候，再次进入刚刚进入过的网页链接，就会看到一个船新版本的界面，也就是本地的hexo库已经部署到github上了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"Hexo写作","slug":"Hexo/Hexo写作","date":"2020-04-01T15:58:14.000Z","updated":"2020-04-01T15:58:14.000Z","comments":true,"path":"posts/c4064b2b.html","link":"","permalink":"https://zhouzhuyan.com/posts/c4064b2b.html","excerpt":"Hexo写作本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。","text":"Hexo写作本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。 1. Hexo基本命令hexo g = hexo generate #生成 hexo s = hexo server #启动本地预览 hexo d = hexo deploy #远程部署 hexo n &quot;文章标题&quot; = hexo new &quot;文章标题&quot; #新建一篇博文 2. 整体配置\\hexo\\_config.yml # Site title: # 网站名，标签页显示 subtitle: # 副标题，网站名下显示 description: # 网站描述，便于搜索 keywords: author: # 作者 language: zh-CN # 中文 timezone: Asia/Shanghai # 时区 3. 更换主题推荐使用melody hexo-theme-melody快速开始) 这个主题就是我现在网站使用的主题，它有完整的中文教程，功能齐全。按照教程配置就可以了。 4. 写作步骤 新建文章 hexo new &quot;title&quot; 写作 \\hexo\\source\\_post中找到title.md，使用typora打开 注意文章的tags格式是[] 在信息栏填写top_img信息可以自定义该页图片情况，如false表示不显示 文章中&lt;!-- more --&gt;之前的部分会显示在主页上，并出现Read more按钮，点击阅读更多内容 预览 hexo s hexo s --debug // 在命令行生成debug信息 同步到远程 hexo d -g 5. 问题 Template render error: (unknown path) 在命令行输入hexo -g后报错，原因在于文章内容中有{}时，如果它没有被代码块包括，解析会出现错误，所以需要写成 &#123;% raw %&#125; 本地预览与远程显示不一致 删除缓存 hexo clean 在网页上刷新","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"C++基本语法","slug":"C++/学习cpp","date":"2020-01-27T03:49:27.000Z","updated":"2020-01-27T03:49:27.000Z","comments":true,"path":"posts/6b599344.html","link":"","permalink":"https://zhouzhuyan.com/posts/6b599344.html","excerpt":"C++学习笔记本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。","text":"C++学习笔记本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。 一、 变量1. 用sizeof运算符求某一类型或变量占据的字节数#include&lt;iostream&gt; using namespace std; int main() &#123; int a; cout &lt;&lt; sizeof(a) &lt;&lt; endl; // sizeof运算符可以求变量占据的字节数 cout &lt;&lt; a &lt;&lt; endl; // 未初始化的变量，其值是不确定的 int b = 1; cout &lt;&lt; b &lt;&lt; endl; &#125; 2. 数据类型的自动转换1. 数int a = 11.34; // 11.34被自动转化为11后赋值给a int b = 30; double d = b; // d的值是30.0 2. 字符类型与整型int k = &#x27;a&#x27;; printf(&quot;%d&quot;, k); // 输出97，即a的ASCII码 int n = 98; char k = n; printf(&quot;%c&quot;, k); // 输出b 3. 输入和输出1. scanf和printf#include&lt;iostream&gt; #include&lt;cstdio&gt; //使用scanf和printf时需要使用该库 int main() &#123; int n; char c; float m; scanf(&quot;%d%c%f&quot;, &amp;n, &amp;c, &amp;m); printf(&quot;%d %c %f\\n&quot;, n, c, m); return 0; &#125; 用scanf可以一次读入多个不同类型的变量，输入各项用空格隔开 注意在输入字符时，不会跳过空格（空格也会被当做字符读入） 输入其它数据时，会跳过空格 2. cin和cout#include&lt;iostream&gt; using namespace std; int main() &#123; int c; while ((c=cin.get()) != EOF) &#123; cout &lt;&lt; (char) c; &#125; return 0; &#125; 使用cin读入所有字符，包括空格和回车，EOF Mac（ctrl+D停止输入，ctrl+C停止程序) windows ctrl+Z停止 3. cin&amp;cout / scanf&amp;printf 比较 cin，cout速度慢，输入输出数据量大时用scanf/printf 一个程序不要同时出现cin和scanf，cout和prinf 4. 运算 加、减、乘运算的溢出 二、函数1. 数组作为函数的参数传递数组作为函数的参数时，是传引用的，即形参数组改变了，实参数组也会改变 二维数组作为函数的形参时，必须写明函数有多少列，不要写明有多少行 void PrintArray(int a[][5]) &#123; cout &lt;&lt; a[4][3]; &#125; 必须要写明列数，编译器才能够根据下标算出元素的地址 $\\color&#123;#F00&#125;&#123;a[i][j]的地址 = 数组首地址 + i \\times N \\times sizeof(a[0][0]) + j \\times sizeof(a[0][0])&#125;$ (N是数组列数) 形参数组的首地址就是实参数组的首地址 三、字符串1. 字符串的形式（1）字符串常量用双引号括起来的，如”China”, “C++ program”. 字符串常量占据内存的字节数等于字符中字符数目加1，结尾多出字符’\\0’. 但是字符串的长度不包含'\\0' “”也是合法的·1字符串常量，称为空串，仍然占据一个字节的内存空间，存放’\\0’ （2）存放于字符数组中，以’\\0’结尾用一维char数组存放字符串，结尾是’\\0’，数组元素个数至少为字符串长度+1。 用cin、scanf将字符串读入字符数组时，会自动在字符数组中字符串的末尾加上’\\0’。 （3）string对象。string是C++标准模板库里的一个类，专门用于处理字符串","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]}],"categories":[{"name":"Spring","slug":"Spring","permalink":"https://zhouzhuyan.com/categories/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"https://zhouzhuyan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"数据库","slug":"数据库","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"},{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://zhouzhuyan.com/tags/docker/"},{"name":"Spring","slug":"Spring","permalink":"https://zhouzhuyan.com/tags/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"https://zhouzhuyan.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"数据库","slug":"数据库","permalink":"https://zhouzhuyan.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Neo4j","slug":"Neo4j","permalink":"https://zhouzhuyan.com/tags/Neo4j/"},{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://zhouzhuyan.com/tags/Hadoop/"},{"name":"Spark","slug":"Spark","permalink":"https://zhouzhuyan.com/tags/Spark/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://zhouzhuyan.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"},{"name":"线程","slug":"线程","permalink":"https://zhouzhuyan.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"递归","slug":"递归","permalink":"https://zhouzhuyan.com/tags/%E9%80%92%E5%BD%92/"},{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"},{"name":"策略模式","slug":"策略模式","permalink":"https://zhouzhuyan.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]}