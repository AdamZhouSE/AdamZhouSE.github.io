{"meta":{"title":"Blog of Adam Zhou","subtitle":"Art is long, but life is short.","description":"Take notes and write articles about Software Engineering","author":"ZZY","url":"https://zhouzhuyan.com","root":"/"},"pages":[{"title":"About me","date":"2020-04-02T05:26:58.000Z","updated":"2020-04-07T20:49:24.961Z","comments":false,"path":"about/index.html","permalink":"https://zhouzhuyan.com/about/index.html","excerpt":"","text":"2020开了博客，好好学习，多写文章，做一条有梦想的咸鱼！ 2018南京大学软件工程本科"},{"title":"Category","date":"2020-04-01T14:21:43.000Z","updated":"2020-04-07T20:49:37.029Z","comments":false,"path":"categories/index.html","permalink":"https://zhouzhuyan.com/categories/index.html","excerpt":"","text":""},{"title":"Link","date":"2020-04-09T06:26:44.000Z","updated":"2020-04-09T06:45:54.533Z","comments":true,"path":"link/index.html","permalink":"https://zhouzhuyan.com/link/index.html","excerpt":"","text":"我的博客资料name: ZZY link: https://zhouzhuyan.com avatar: https://zhouzhuyan.com/avatar.png descr: 把全盛的爱都活过，把全盛的我都活过"},{"title":"Messageboard","date":"2020-04-06T11:34:55.000Z","updated":"2020-04-06T11:38:07.315Z","comments":true,"path":"messageboard/index.html","permalink":"https://zhouzhuyan.com/messageboard/index.html","excerpt":"","text":"欢迎留言~"},{"title":"Projects","date":"2020-04-02T05:29:14.000Z","updated":"2020-04-06T07:41:29.135Z","comments":false,"path":"projects/index.html","permalink":"https://zhouzhuyan.com/projects/index.html","excerpt":"","text":""},{"title":"Tag","date":"2020-04-01T17:35:18.000Z","updated":"2020-04-09T06:45:31.971Z","comments":false,"path":"tags/index.html","permalink":"https://zhouzhuyan.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"概率论的基本概念","slug":"概率论的基本概念","date":"2020-04-09T15:23:48.000Z","updated":"2020-04-09T16:29:41.128Z","comments":true,"path":"posts/36736857.html","link":"","permalink":"https://zhouzhuyan.com/posts/36736857.html","excerpt":"本文介绍了概率论的基本概念，包括概率的定义，概率的计算，同时还有随机测试的简单介绍。 重点 概率的定义 条件概率 乘法公式 全概率公式 贝叶斯公式","text":"本文介绍了概率论的基本概念，包括概率的定义，概率的计算，同时还有随机测试的简单介绍。 重点 概率的定义 条件概率 乘法公式 全概率公式 贝叶斯公式 一、概率的定义当我们还不能用数学符号描述一件事情，那么说明我们还没有想清楚这件事。 所以，我们需要建立元素到数据的映射 graph LR A[物理世界] -->|映射| B[数据集合] 1. 基本概念1.1 随机实验 可以在相同的条件下重复进行 每次实验结果不止一个，并且事先明确实验的所有可能结果 进行一次实验前不能够确定那一个结果会出现 例：抛一枚硬币，观察正面H与反面T出现的情况 1.2 样本空间随机试验$E$的所有可能结果组成的集合称为$E$的样本空间，记为$\\Omega$ 样本空间中的每个元素，即$E$的每个结果，称为样本点，记为$e$ 1.3 随机事件样本空间$\\Omega$的任意子集$A$称为随机事件 观察到样本点$e$，若$e\\in A$，则称这一事件发生。 基本事件：由一个样本点组成的单点集 复合事件：由两个或两个以上样本点组成的集合 必然事件：全集$\\Omega$ 不可能事件：空集$\\emptyset$ 2. 事件的集合运算 包含：$A\\subset B$，事件B包含事件A，则事件A发生必然导致事件B发生 相等：$A=B$，即$A\\subset B$且$B\\subset A$ 和：$A\\bigcup B$，即A和B至少有一个发生 差：$A-B$，即事件A发生且事件B不发生 积：$A\\bigcup B$，记作$AB$，即事件A和事件B都发生 互不相容：$AB = \\emptyset$，即A和B不能同时发生 互逆：$A\\bigcup B=\\Omega$ 且$AB = \\emptyset$，A和B互逆，通常B记为$\\overline{A}$ 2.1 复杂事件的集合运算 A发生而B和C都不发生：$A\\overline{B} \\overline{C}=A-B-C=A-(B\\bigcup C)$ A与B都发生而C不发生：$AB\\overline{C}=AB-C=AB-ABC$ 三个事件都发生：$ABC$ 三个事件恰好有一个发生：$A\\overline{B}\\overline{C}+\\overline{A}B\\overline{C}+\\overline{A}\\overline{B}C$ 三个事件至少发生一个：$A\\bigcup B\\bigcup C$ 2.2 常用定律 交换律 结合律 分配率：$A\\, \\bigcup \\,(B\\bigcap C)=(A\\bigcup B)\\bigcap (A\\bigcup C)$ $A\\, \\bigcap \\,(B\\bigcup C)=(A\\bigcap B)\\,\\bigcup \\,(A\\bigcap C)$ 德摩根定律：$\\overline{A\\bigcup B}=\\overline{A}\\bigcap\\overline{B}$ $\\overline{A\\bigcap B}=\\overline{A}\\bigcup\\overline{B}$ 3. 频率描述了事件发生的频繁程度 定义 重复观察n次事件A发生的次数$n_A$称为A的频数 比值$\\frac{n_A}{n}$称为事件A发生的频率，并记为$f_n(A)$ 性质 $0\\,\\leq\\, f_n(A)\\, \\leq\\, 1$ $f_n(\\Omega)=1$ 若$A_1,\\cdots,A_k$两两互不相容，则 f_n(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=f_n(A_1)+\\cdots+f_n(A_k) 收敛性 当n足够大，$f_n(A)$收敛于某个常数，这个常数就是概率（证明见后续） 我们应该都听说过德摩根抛硬币的故事，对一个事件进行大量的实验可以得到频率，但是我们不可能对所有事件都做类似的事情，所以就有了概率 4. 概率表征事件发生的可能性大小 定义 $\\Omega$为样本空间，对于每一事件A赋予一实数$P(A)$，若P(A)满足下列条件则被称为概率： 非负性：$0\\leq P(A)\\leq 1$ 规范性：$P(\\Omega)=1$ 可列可加性：$A_1,\\cdots,A_n$互不相容，则$P(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=P(A_1)+\\cdots+P(A_k)$ 性质 $P(\\emptyset)=0$ $P(\\overline{A})=1-P(A)$ 若$A\\subset B$，则有$P(A)\\leq P(B),\\quad P(B-A)=P(B)-P(A)$ 对于任意两个事件A和B，$P(A\\bigcup B)=P(A)+P(B)-P(A+B)$ 4.1 古典概型(等可能概型)定义 若$\\Omega$是**有限样本空间，其样本点为$e_1,\\cdots e_n$，在有限样本空间中引进概率。 1/n称为事件${e_i}$的概率，记为$P({e_i})$ P(\\{e_1\\})+\\cdots +P(\\{e_n\\})=P(\\Omega)=1从定义中不难发现古典概型的两个特点： 样本空间包含有限个元素 试验中每个基本事件发生的可能性相同 注：基本事件是两两不相容的 若事件A包含k个基本事件，则有 P(A)=\\sum_{i=1}^kP(\\{e_{i_k}\\})=\\frac{k}{n}4.2 几何概型数据从有限集合推广到无限集合 例：约会问题 两人约定7点到8点在某地会面，先到者等候另一人20分钟，过时就离去，试求这两人会面的概率。 解：以$x,y$分别表示两人到达的时刻，则会面的充要条件为$|x-y|\\leq20$，这就是一个几何概率的问题，可能的结果全体是边长60的正方形里面的点，结果为 P(A)=\\frac{60^2-40^2}{60^2}从上面的例子不难看出，样本空间从原来的有限的个数，变成了无限的点。 如果要在半径为1的圆内随机地取一条弦，问弦长超过$\\sqrt{3}$的概率是多少？ 3种思路有3种不同的答案 在数据映射中，我们需要遵循物理世界到数据集合的某种结构保持 二、概率的计算1. 条件概率事件A发生的条件下事件B发生的概率 1.1 定义设A，B是两事件，且$P(A)&gt;0$，称 P(B|A)=\\frac{P(AB)}{P(A)}为在事件A发生的条件下事件B发生的条件概率 条件概率符合概率定义中的3个条件 非负性 规范性 可列可加性：$B_1,\\cdots,B_n$两两互不相容 P(\\bigcup_{i=1}^\\infty B_i\\,\\mid\\,A)=\\sum_{i=1}^\\infty P(B_i\\mid A)同时也可以使用概率的性质 P(B_1\\bigcup B_2)=P(B_1\\mid A)+P(B_2\\mid A)-P(B_1B_2\\mid A)注意这里是对任意事件$B_1,B_2$，两者不一定互不相容，如果互不相容，那么$P(B_1B_2)=\\emptyset$，与可列可加性不矛盾。 1.2 乘法公式P(AB)=P(A)P(B|A)推广：一般地，我们有： P(A_1A_2\\cdots A_n)=P(A_1)P(A_2\\mid A_1)\\cdots P(A_n\\mid A_1A_2\\cdots A_{n-1})大多数应用中，我们会直接获取条件概率，通过它进行计算 1.3 完备事件组设$B_1,\\cdots,B_n$是样本空间$\\Omega$的一个事件组，若满足 $B_i\\bigcap B_j=\\emptyset$ ，对于任意$i\\neq j$ $\\bigcup_iB_i=\\Omega$ 则$B_1,\\cdots,B_n$称为一个完备事件组 1.4 全概率公式设$B_1,\\cdots,B_n$是样本空间$\\Omega$的一个完备事件组，且$P(B_i)&gt;0(i=1,2,\\cdots,n)$，则对于任一随机事件A，有 P(A)=\\sum_{i=1}^nP(B_i)P(A\\mid B_i)当$P(A)$不易求得时，利用此公式 1.5 贝叶斯公式设实验E的样本空间为$\\Omega$，$A$为$\\Omega$的事件，$B_1,\\cdots,B_n$为$S$的一个划分，且$P(A)&gt;0,P(B_i)&gt;0$，则 P(B_i\\mid A)=\\frac{P(A\\mid B_i)P(B_i)}{\\sum_{j=1}^nP(A\\mid B_j)P(B_j)},i=1,2,\\cdots,n如：设$A,B$为两事件，$P(B)&gt;0$，则 P(A\\mid B)=\\frac{P(B\\mid A)\\times P(A)}{P(B)}贝叶斯定理往往与全概率公式同时使用。全概率公式用于”由因求果“的问题，而贝叶斯定理用于”执果寻因“问题。 常用：令$n=2$，那么全概率公式和贝叶斯公式分别为： P(A)=P(A\\mid B)P(B)+P(A\\mid \\overline{B})P(\\overline{B})P(B\\mid A)=\\frac{P(AB)}{P(A)}=\\frac{P(A\\mid B)P(B)}{P(A\\mid B)P(B)+P(A\\mid \\overline{B})P(\\overline{B})}1.6 独立性定义：设$A,B$是两事件，如果满足等式 P(AB)=P(A)P(B)则称事件$A$和事件$B$相互独立 定理：设$A,B$是两事件，且$P(A)&gt;0$，若$A,B$相互独立，则$P(B\\mid A)=P(B)$，反之亦然 定理：若事件$A,B$相互独立，则下列各对事件也相互独立，$A\\&amp;\\overline{B},B\\&amp;\\overline{A},\\overline{A}\\&amp;\\overline{B}$ 定义：设$A,B,C$是三个事件，如果满足等式 P(AB)=P(A)P(B),\\\\ P(BC)=P(B)P(C)\\\\P(AC)=P(A)P(C)\\\\P(ABC)=P(A)P(B)P(C)则称事件$A,B,C$相互独立 三、随机测试示例实际应用中使用概率论 1. 随机测试初步假设有一个计算多项式乘法的程序。 程序可能采用左右两边的某一方式实现： (x+1)(x-2)(x+3)(x-4)(x+5)(x-6)=x^6-7x^3+25思考： 如何验证左右两边的多项式相等 假设有一个超大规模的多项式呢？ F(X)?\\equiv G(x)1.1 规范化两个多项式相等当且仅当他们的规范式中所有的对应系数相等， 那么把$F(x)$变换为规范式，有$O(d^2)$的复杂度 1.2 随机测试-初步设$F(X),G(x)$的最高阶为的$d$，随机算法首先是从${1,\\cdots,100d}$中均匀随机（等可能）地选择一个整数$r$，然后计算两个式子的值，进行判断。有$O(d)$的复杂度，大大提高了速度。 当然，这种算法可能会给出错误的答案。 $F(x)\\neq G(x), F(r)=G(r)$，算法检测结果错误 错误的概率是多少？可以接受吗？ 当$r$是方程$F(x)-G(x)=0$的根时，必然会出现错误结果。 $F(x)-G(x)$的次数不高于$d$，由代数的基本定理可知，$F(x)-G(x)=0$不可能多于$d$个根。 那么在${1,\\cdots,100d}$中，给出错误答案的概率不会高于$\\frac{1}{100}$ 2. 随机测试改进如何改进算法正确率？ 很容易想到两个方向，扩大检测范围，重复多次检测 2.1 扩大范围在更大的范围进行取值，比如在${1,\\cdots,1000d}$中进行检测，那么错误答案概率不会超过$\\frac{1}{1000}$ 2.2 重复检测重复多次进行随机检测 有放回抽样 $k$次有放回抽样错误率为 P(E_1\\,\\bigcap\\cdots\\bigcap\\,E_k)=\\prod_{i=1}^kP(E_i)\\leq(\\frac{1}{100})^k可以看到，错误率指数级降低 无放回抽样 总结： 无放回比有放回准确率高 有放回实现比无放回简单 当$d+1$次无放回抽样后，能够确保准确性，但是算法复杂度提升到$O(d^2)$ 四、总结1. 概率的定义$\\Omega$为样本空间，对于每一事件A赋予一实数$P(A)$，若P(A)满足下列条件则被称为概率： 非负性：$0\\leq P(A)\\leq 1$ 规范性：$P(\\Omega)=1$ 可列可加性：$A_1,\\cdots,A_n$互不相容，则$P(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=P(A_1)+\\cdots+P(A_k)$ 2. 条件概率P(B|A)=\\frac{P(AB)}{P(A)}3. 乘法公式P(A_1A_2\\cdots A_n)=P(A_1)P(A_2\\mid A_1)\\cdots P(A_n\\mid A_1A_2\\cdots A_{n-1})4. 全概率公式P(A)=P(A\\mid B_1)P(B_1)+\\cdots+P(A\\mid B_n)P(B_n)5. 贝叶斯公式P(A\\mid B)=\\frac{P(B\\mid A)P(A)}{P(B)}参考： 中国大学MOOC-南京大学-数据科学基础 《概率论与数理统计》浙江大学第四版","categories":[{"name":"数据科学","slug":"数据科学","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://zhouzhuyan.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"Hexo个人博客绑定域名和配置SSL证书","slug":"Hexo个人博客绑定域名和配置SSL证书","date":"2020-04-09T13:29:25.000Z","updated":"2020-04-09T13:40:26.540Z","comments":true,"path":"posts/2cd2c226.html","link":"","permalink":"https://zhouzhuyan.com/posts/2cd2c226.html","excerpt":"Hexo 个人博客绑定域名和配置SSL证书在完成个人博客的搭建以后，我们可以通过一个https://xxx.github.io形式的链接在访问我们的个人博客网站，那么如果想拥有一个个性的域名，该如何操作呢？","text":"Hexo 个人博客绑定域名和配置SSL证书在完成个人博客的搭建以后，我们可以通过一个https://xxx.github.io形式的链接在访问我们的个人博客网站，那么如果想拥有一个个性的域名，该如何操作呢？ 一、 绑定域名1. 购买域名可以在阿里云或者腾讯云上购买，不同形式的有不同的价格，根据自己的情况购买即可。我在腾讯云上购买了我现在的域名zhouzhuyan.com 注意：如果不使用国内的服务器的话不用备案，只要完成实名认证就可以了。 现在实名认证，审核都很快，虽然说一个工作日审批，但是我的话几分钟成功了。在域名的状态显示正常以后，就可以使用了。 2. 域名解析这个时候，网站时访问不了的，因为还需要去解析你的域名，将你的域名指向你的个人网站。 到腾讯云控制台的域名管理界面，找到你的域名，点击解析，选择添加记录 主机记录 记录类型 线路类型 记录值 www CNAME 默认 你的Github项目仓库名 @ CNAME 默认 你的Github项目仓库名 两个主机记录是为了让你的网站在有www和没有的情况下都可以访问，仓库名可以在Github仓库的Settings里面找到。解析需要10分钟，耐心等待。 3. 在项目中更换到Github中找到自己的网站所在的仓库，进入Settings界面 在Custom domain里面填写自己的域名，选择save，这样就会出现上图的形式，显示Your site is published at https://你的域名，勾选Enforce HTTPS 4. 创建CNAME文件进入你的Hexo本地文件所在的根目录，找到\\source目录，在里面创建一个文件CNAME，注意它是没有类型的，不是.txt。 在里面加入你的域名，注意不要在前面加入https www这样的前缀，就是你的域名。 然后hexo d -g部署你的网站，等待一段时间后，就可以通过你的个性域名访问网站了。 二、 SSL安全证书注册好域名后，用google访问时，可能会出现您访问的不是安全链接的提示，或者能够正常访问，但是域名旁边显示的是一个感叹号，表示不安全，这是因为我们还没有申请安全证书，在申请了证书之后，域名旁边显示的就是一把锁，表示安全。 腾讯云和阿里云都提供免费的SSL证书下载，具体安装也有相关的文档，按照步骤操作就行。 腾讯云Nginx服务器证书安装 Mac下nginx的使用 在证书安装好了以后，可以看到域名解析里面多出了一条TXT类型的解析。 在Chrome浏览器中，打开网站后如果仍然显示不安全，即没有出现锁的图标，右击选择检查元素，进入开发者模式，看Security里面有什么问题。 踩坑：我发现我用阿里云图床的图片引用的是http头，把它改为https，锁就出现了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"Hexo-melody主题扩展","slug":"Hexo-melody主题扩展","date":"2020-04-05T15:13:13.000Z","updated":"2020-04-09T13:56:10.288Z","comments":true,"path":"posts/6663916b.html","link":"","permalink":"https://zhouzhuyan.com/posts/6663916b.html","excerpt":"在搭建博客的时候，在github上逛了不少主题，最符合我审美的就是我现在正在用的melody，不过还是有一些美中不足的地方，但我并没有大佬的水平重新写一个，所以选择在原方案上稍微改动一下，实现一些自己的想法。","text":"在搭建博客的时候，在github上逛了不少主题，最符合我审美的就是我现在正在用的melody，不过还是有一些美中不足的地方，但我并没有大佬的水平重新写一个，所以选择在原方案上稍微改动一下，实现一些自己的想法。 1. 建立utterances评论系统melody主题一共支持5个评论系统， Disqus：要翻墙，不支持markdown Laibili: 虽然支持的账号多，但是不太稳定，跳转到第三方的网页登录让人没有了评论的欲望 Gitment和Gitalk 这两者要求把GitHub 注册的 OAuth Application 的 Client ID、Client Secret 以明文形式写进前端代码里，这样别人直接查看源代码就可以得到我们的密码，而这是不能够公开的，会有很大的安全隐患，具体可以看这篇博客Gitment 安全性争议 valine：不好看 然后我发现了utterances，也是基于issue建立的，但是控制了权限，不需要读写代码，前端没有要求你填写密码，而是填写你的仓库名，保证安全性，同时也支持markdown语法，而且很好看~~~ 不过melody暂时并不支持这个系统，需要自己手动添加，这个操作并不难。 1.1 安装首先，进入utterances安装该app，指定博客所在的repo 然后就可以得到需要添加的代码，注意这里src不可以改变，repo是拥有者/仓库名，issue-term和 theme都可以自己指定。 1.2 配置utterances.pug然后进入themes\\melody\\layout\\includes\\comments目录，新建一个utterances.pug文件，并在里面加入指定的内容，格式如下 if theme.utterances &amp;&amp; theme.utterances.enable script(src=&quot;https://utteranc.es/client.js&quot;,repo=&quot;用户名/仓库名&quot;,issue-term=&apos;title&apos;,label=&apos;utterances&apos;,theme=&apos;github-light&apos;,crossorigin=&apos;anonymous&apos;,async) pug的形式与html稍有不同，可以自行搜索一下，改变成上面的样式就可以了。 这里有个小坑，就是repo里面填的是own/repo，也就是用户名加上仓库名，而不仅仅是仓库名，否则就检索不到了。 1.3 配置index.pug接着，就是在themes\\melody\\layout\\includes\\comments中，找到index.pug文件，会看到里面许多if-else的结构，把utterances也加上去就行 else if theme.utterances &amp;&amp; theme.utterances.enable include ./utterances.pug 1.4 配置主题配置文件最后一步，就是在主题配置文件里面加上utterances评论系统啦。 # Utterances# See: https://utteranc.es/utterances: enable: true 因为是自己的小改动，所以我直接在pug文件里面指定了相关内容，就没有像其它评论系统里面写引用，因此这里也只要enable一下就可以了。 1.5 启动","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"字符串,向量和数组","slug":"字符串-向量和数组","date":"2020-04-03T14:03:24.000Z","updated":"2020-04-05T04:13:32.132Z","comments":true,"path":"posts/869e4b19.html","link":"","permalink":"https://zhouzhuyan.com/posts/869e4b19.html","excerpt":"二、字符串，向量和数组作用域操作符:: 含义：编译器应从操作符左侧的作用域中寻找右边那个名字 比如std::cin是要使用命名空间std中的cin 这样做是为了避免某些名字被重复使用 使用using声明可以更加简便的使用命名空间中的成员。","text":"二、字符串，向量和数组作用域操作符:: 含义：编译器应从操作符左侧的作用域中寻找右边那个名字 比如std::cin是要使用命名空间std中的cin 这样做是为了避免某些名字被重复使用 使用using声明可以更加简便的使用命名空间中的成员。 1. String类型表示可变长的字符串 1.1 定义和初始化 使用需要头文件和命名空间 #include&lt;string&gt;using std::string; 初始化 string s1; // 空字符串string s2 = s1; // s2是s1的副本string s3 = \"abc\";string s4(10, 'c'); // 十个c 1.2 string对象上的操作 使用getline读取一整行 string line;getline(cin, line); 当读取到换行符时结束，并将读到的内容存入string中，但是不存换行符 empty和size操作 str.empty()根据字符串是否为空返回一个布尔值 str.size()返回字符串长度 使用visual studio编程的时候，碰到过一个warning，将无符号数赋值给了有符号数。 这是由于size函数的返回值类型引起的，它是一个string::size_type类型的值，是无符号类型的， 可以用auto来推断变量的值 auto len = str.size(); 比较，赋值，相加 string s1 = \"abc\";string s2 = \"xcvd\";// s1 &lt; s2 比较第一个不同的字符string s3 = s1; // 赋值string s4 = s1 + s2; // abcxcvd 处理string中的字符 #include&lt;cctype&gt;isalnum(c);isalpha(c);islower(c);isupper(c);ispunct(c); // 是标点符号为真 2. Vector类型可变长数组，类似于Java中的ArrayList 2.1 初始化vector&lt;T&gt; v;vector&lt;T&gt; v1 = &#123;a, b, c&#125;; // 注意是花括号vector&lt;T&gt; v2&#123;a, b&#125;; // 花括号，两个元素vector&lt;int&gt; v3(10, 1); // 圆括号 10个元素，每个初始化为1 2.2 操作vector&lt;int&gt; v;v.push_back(1); // 添加1v.pop_back(); // 去掉最后一个数据v.empty();v.size();v[n]; // 注意下标只能访问，但是不能够添加元素 3. 迭代器访问元素的作用 string s = \"abcde\";if (s.begin() != s.end()) &#123; // 确保s非空 &#125; 4. 数组4.1 指针和数组int ia[] = &#123;1, 2, 3, 4, 5&#125;;auto p(ia); // 整型指针，指向ia的第一个元素p++; // 指向第一个元素","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://zhouzhuyan.com/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]},{"title":"Hexo-Permalink简化","slug":"Hexo-Permalink简化","date":"2020-04-03T12:59:43.000Z","updated":"2020-04-04T14:45:26.611Z","comments":true,"path":"posts/838443af.html","link":"","permalink":"https://zhouzhuyan.com/posts/838443af.html","excerpt":"Permalink简化在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章 阮一峰 关于url编码 有两种方法优化。","text":"Permalink简化在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章 阮一峰 关于url编码 有两种方法优化。 方法一：自定义首先，在scaffolds的post.md中，加入urlname元素。 title: &#123;&#123; title &#125;&#125;urlname:date: &#123;&#123; date &#125;&#125;tags:categories: 然后，在配置文件_config.yml中，将永久链接permalink的形式改为 permalink: :category/:urlname/ 也就是类别加上自定义的url链接。 每次写文章时，可以自己设计该页的url，使得它变得简单，同时也利于区分。 但是，这种修改方法的链接会随着文件目录的改变而改变， 比如一篇文章HelloWorld.md本来放在_posts目录下，链接为https://xxx/_posts/HelloWorld.md 之后归类到_posts/A目录下，那么链接变为https://xxx/_posts/A/HelloWorld.md 这样不太利于分享，所以推荐使用第二种方法。 方法二：插件使用hexo-abbrlink这个插件 安装 npm install hexo-abbrlink --save 设置 在_config.yml文件中修改永久链接格式 permalink: posts/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex posts部分是可以更改的，也可以仿照方法一添加一个关键词便于识别 permalink: :keywords/:abbrlink.html 生成 在根目录创建Gruntfile.js文件，让插件到source/_posts/下读取所有的.md文件，把文件中的@@abbrlink替换成文件内容的hash值。 module.exports = function(grunt) &#123; grunt.initConfig(&#123; rewrite: &#123; abbrlink: &#123; src: 'source/_posts/**/*.md', editor: function(contents, filepath)&#123; const crypto = require('crypto'); const hash = crypto.createHash('sha256'); hash.update(contents); var hashValue = hash.digest('hex'); return contents.replace(/@@abbrlink/g, hashValue.substring(0, 16)); &#125; &#125;, &#125;, &#125;); grunt.loadNpmTasks('grunt-rewrite');&#125;; 这种方法生成的链接是不带目录的，直接就是第二步设置中permalink的样式，所以也没有了被改变的风险。 参考 http://blog.jvaeyhcd.wang/posts/05c9df7e0c47bd64.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"变量和基本类型","slug":"变量和基本类型","date":"2020-04-03T12:44:47.000Z","updated":"2020-04-04T14:44:34.579Z","comments":true,"path":"posts/96db5496.html","link":"","permalink":"https://zhouzhuyan.com/posts/96db5496.html","excerpt":"变量和基本类型1. 复合类型(Compound type)基于其它类型定义的类型 1.1 引用(Reference)引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。","text":"变量和基本类型1. 复合类型(Compound type)基于其它类型定义的类型 1.1 引用(Reference)引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。 (在这里，引用指的是左值引用) int ival = 1024;int &amp;refval = ival; // refval指向ival，是ival的另外一个名字int &amp;refVal2; // 报错；引用必须被初始化 定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。（与初始化变量时不同的） 无法令引用重新绑定到另一个对象，所以引用必须被初始化 引用即别名，它不是对象，而是为了一个已经存在的对象起了另外一个名字 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的 refVal = 2; // 把2赋值给与refVal绑定的对象上，这里就是绑定到iVal上int ii = refVal; 除了两种特殊情况，其它所有引用的类型都要与之绑定的对象严格匹配。不能够与字面值或表达式的计算结果绑定。 int &amp;refVal4 = 10; // 错误：引用对象初始值必须是一个对象double dval = 3.14;int &amp;refVal5 = dval; // 错误：此处引用类型的初始值必须是int型对象 1.2 指针指针是指向另外一种类型的符合类型，与引用类似，指针实现了对其它对象的间接访问。 不同： 指针本身是一个对象 指针无需在定义时赋初值 int *ip1; // ip1是指向int对象的指针 获取对象的地址指针存放某个对象的地址。 int ival = 42;int *p = &amp;ival; // p是存放变量ival的地址，或者说p是指向引用的指针。 指针值指针的值（即地址）应该属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针 无效指针 利用指针访问对象如果指针指向了一个对象，可以使用解引用符（操作符*）来访问对象 int ival = 42;int *p = &amp;ival;cout &lt;&lt; *p // 输出42*p = 0;cout &lt;&lt; *p // 输出0，为*p赋值实际上是为p所指的对象赋值 空指针int *p1 = nullptr;int *p2 = 0;int *p3 = NULL; // 需要头文件cstdlib void*指针用于存放任意对象的地址，不能直接操作void*指针所指的对象 指向指针的指针指向指针的引用指针是对象，所以存在对指针的引用 int i = 42;int *p;int *&amp;r = p; // r是一个对p的引用r = &amp;i; // r引用了一个指针，因此给r赋值&amp;就是令p指向i*r = 0; // 将i的值改为0 2. const限定符值不能被改变，所以const对象必须被初始化 const int bufSize = 512; // 输入缓冲区大小 如果要在多个文件之间共享const，必须在变量定义前加extern关键字 2.1 对const的引用对常量的引用，不能够修改其绑定的对象 对const的引用可以使一个并非const的对象，但是不能通过其改变值 const int ci = 1024;const int &amp;r1 = ci; // 正确r1 = 42; // 错误：r1是对常量的引用int &amp;r2 = ci; // 错误：非常量引用指向一个常量对象int i = 42；const int &amp;r1 = i; // 允许将const int&amp;绑定到一个普通的int上r1 = 10; // 错误 3. 处理类型3.1 类型别名某种类型的同义词，使得复杂的类型名字变得简单，易于理解和使用。 typedef double wages; // wages是double的同义词using SI = Sales_item; // SI是Sales_item的同义词 3.2 auto类型说明符让编译器分析表达式所属的类型，必须有初始值 auto item = val1 + val2; // 由val1和val2相加的结果推断item的类型// auto一条声明语句只能有一个基础数据类型auto i = 0, *p = &amp;i; // 正确auto sz = 0, pi = 3.14; // 错误，sz和pi的类型不一致 4. 自定义数据结构将一组相关的数据元素组织起来然后使用他们的策略和方法 struct Sales_data &#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0;&#125;Sales_data accum;","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://zhouzhuyan.com/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]},{"title":"Head First Pattern读书笔记(一)","slug":"Head-First-Pattern读书笔记-一","date":"2020-04-02T06:37:55.000Z","updated":"2020-04-04T14:44:00.687Z","comments":true,"path":"posts/9883ff8.html","link":"","permalink":"https://zhouzhuyan.com/posts/9883ff8.html","excerpt":"Head First 设计模式 读书笔记本文介绍了策略模式","text":"Head First 设计模式 读书笔记本文介绍了策略模式 一、 设计模式入门如果有一个鸭子的类如下 class Duck &#123; quack(); swim(); dispaly(); // 每一种鸭子不同，display()抽象 // 其它方法&#125; 现在需要增加一个功能，让鸭子会飞。 如果直接添加一个fly()方法，则所有子类都具备该方法，那么会出现会飞的橡皮鸭。 **涉及维护问题，为了\"复用\"目的而使用继承，并不合适** 可能的解决方案： 继承：把在橡皮鸭的fly()方法覆盖 问题：如果再加入诱饵鸭，不会飞也不会叫，每次更新加入更多的鸭子…… 于是每当有新的子类，就要检查fly()方法 我们发现了以下缺点 代码在多个子类中重复 运行时的状态不易改变 很难知道所有鸭子的行为 改变会牵一发而动全身，造成不想要的改变 接口：把fly()从超类中取出，放入Flyable接口，使得会飞的鸭子实现接口。 问题：重复代码变多，代码无法复用（如果有100个duck子类都要修改飞行的行为？？？） 1. 软件开发的不变真理——改变不管一开始软件设计的有多好，一段时间后，总是需要成长和改变。 2. 设计模式入门继承的问题：让所有鸭子都有某些行为，不恰当 接口的问题：Java接口不具有实现代码，所以继承接口无法实现代码的复用。修改量大。 解决方案**设计原则** 找到可能需要变化的地方，独立出来，不要和不需要变化的代码混在一起。 把会变化的部分取出封装起来，改动和扩充时不会影响不需要变化的部分。 核心：系统中某部分的改变不影响其他部分 结果：改动引起的可能错误减少，系统更有弹性 分开变化和不会变化的部分对于Duck，分离fly与quack，建立两组类，分别实现各自的动作 比如一组类中可以有“呱呱叫”，“吱吱叫”，“安静” 设计鸭子的行为一切要由弹性。鸭子类中包含设定行为的方法，这样可以动态的改变实例的行为 **设计原则** 针对接口编程，而不是针对实现编程 利用接口代表每个行为，由行为类而不是Duck类实现行为接口 比较： ​ 以前行为来自Duck超类，依赖于实现，无法更改行为 ​ 现在使用接口表是的行为，特定的具体行为编写在了行为类中。 比如，FlyBehavior接口,以及它对应的类，负责实现具体的行为： ​ 实现复用，新增行为不会影响到已有的类 针对接口编程的真正意思是针对超类型编程，这里的接口可以是interface构造，也可以是超类型编程。 关键在于多态。 整合鸭子的行为动态设定行为见代码 封装行为的大局观鸭子的一组行为 —&gt; 一族算法（代表鸭子能做的事） 每一个鸭子都有一个（HAS-A）FlyBehavior和一个QuackBehavior，将飞行和叫声委托给它代为处理。 将两个类结合起来使用——组合 **设计原则** 多用组合，少用继承 使用继承具有很大的弹性，不仅可以将算法族封装成类，还可以在运行时动态地改变行为。 第一个设计模式：策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。 3. 工具 基础 原则 模式 抽象 封装变化 策略模式 封装 多用组合，少用继承 多态 针对接口编程，不针对实现编程 继承","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://zhouzhuyan.com/categories/Design-Pattern/"}],"tags":[{"name":"Strategy","slug":"Strategy","permalink":"https://zhouzhuyan.com/tags/Strategy/"}]},{"title":"使用Github pages+Hexo 搭建个人博客","slug":"使用Github-pages-Hexo-搭建个人博客","date":"2020-04-01T17:56:42.000Z","updated":"2020-04-04T14:45:15.001Z","comments":true,"path":"posts/ae6c038e.html","link":"","permalink":"https://zhouzhuyan.com/posts/ae6c038e.html","excerpt":"Github pages + Hexo 搭建个人博客2019年11月19日，我决定开始写博客，首先要用github pages+hexo搭建一个个人博客，其中的过程我就记录在这里面。","text":"Github pages + Hexo 搭建个人博客2019年11月19日，我决定开始写博客，首先要用github pages+hexo搭建一个个人博客，其中的过程我就记录在这里面。 准备工作 注册一个 GitHub 账户 安装 Node.js下载链接 https://nodejs.org/en/download/ 下面这个是中文网，对于国内用户来说下载速度非常快。 http://nodejs.cn/download/ 推荐菜鸟教程关于node的安装教程以及简易的语法介绍https://www.runoob.com/nodejs/nodejs-install-setup.html 安装git markdown语法学习https://www.jianshu.com/p/191d1e21f7ed git语法学习推荐廖雪峰的git教程https://www.liaoxuefeng.com/wiki/896043488029600 安装在终端检查node和npm的版本情况 node -vnpm -v 然后输入命令安装hexo npm install -g hexo-cli 我使用的是Mac电脑，在这一步出现了问题，终端显示如下 rollbackFailedOptional verb npm-session 然后我又等了一会儿，终端又报错了。 npm WARN checkPermissions Missing write access to /usr/local/lib/node_modulesnpm ERR! code EACCESnpm ERR! syscall accessnpm ERR! path /usr/local/lib/node_modulesnpm ERR! errno -13npm ERR! Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;npm ERR! [Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;] &#123;npm ERR! stack: &quot;Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;&quot;,npm ERR! errno: -13,npm ERR! code: &apos;EACCES&apos;,npm ERR! syscall: &apos;access&apos;,npm ERR! path: &apos;/usr/local/lib/node_modules&apos;npm ERR! &#125;npm ERR! npm ERR! The operation was rejected by your operating system.npm ERR! It is likely you do not have the permissions to access this file as the current usernpm ERR! npm ERR! If you believe this might be a permissions issue, please double-check thenpm ERR! permissions of the file and its containing directories, or try runningnpm ERR! the command again as root/Administrator. 根据官方文档，如果在尝试安装 Hexo 的过程中出现 EACCES权限错误，要遵循由npmjs发布的指导修复该问题。强烈建议不要使用 root、sudo 等方法覆盖权限。根据要求，下载了nvm，并且在终端利用nvm下载了最新版本的node和更新了npm后，hexo下载成功了。（以下是下载和使用nvm的教程链接）https://github.com/nvm-sh/nvm. 建站输入以下命令hexo就会出现在指定的文件夹中 hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 如果出现错误 -bash: syntax error near unexpected token `newline' 这是占位符的问题，将第一行命令的&lt;&gt;去除，再重新输入即可。 到此，建站的基本操作就完成了。 界面的设计等就可以由自己来操作了。放一个hexo的官方网站供大家参考。https://hexo.io/zh-cn/docs/configuration 创建Github远程仓库注意仓库名为github的用户名.github.io，勾选readme 创建之后，进入仓库，点击Settings按钮，然后翻到GitHub Pages的部分，点击网页链接，就能够看到一个简易的网页了。 部署hexo进入本地的hexo文件，找到 _config.yml，打开后翻到最后，修改成 deploy: type: git repo: gitHub: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git branch: master repo后面的内容要修改成自己github仓库的SSH密匙。 然后在终端中输入 npm install hexo-deployer-git --save 开始安装hexo-deploy-git，安装完成后，开始部署，在终端中输入 hexo deploy 部署完成。 测试这个时候，再次进入刚刚进入过的网页链接，就会看到一个船新版本的界面，也就是本地的hexo库已经部署到github上了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"Hexo写作","slug":"Hexo写作","date":"2020-04-01T15:58:14.000Z","updated":"2020-04-07T20:52:13.983Z","comments":true,"path":"posts/c4064b2b.html","link":"","permalink":"https://zhouzhuyan.com/posts/c4064b2b.html","excerpt":"Hexo写作本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。","text":"Hexo写作本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。 1. Hexo基本命令hexo g = hexo generate #生成hexo s = hexo server #启动本地预览hexo d = hexo deploy #远程部署hexo n \"文章标题\" = hexo new \"文章标题\" #新建一篇博文 2. 整体配置\\hexo\\_config.yml # Sitetitle: # 网站名，标签页显示subtitle: # 副标题，网站名下显示description: # 网站描述，便于搜索keywords:author: # 作者language: zh-CN # 中文timezone: Asia/Shanghai # 时区 3. 更换主题推荐使用melody hexo-theme-melody快速开始) 这个主题就是我现在网站使用的主题，它有完整的中文教程，功能齐全。按照教程配置就可以了。 4. 写作步骤 新建文章 hexo new \"title\" 写作 \\hexo\\source\\_post中找到title.md，使用typora打开 注意文章的tags格式是[] 在信息栏填写top_img信息可以自定义该页图片情况，如false表示不显示 文章中&lt;!-- more --&gt;之前的部分会显示在主页上，并出现Read more按钮，点击阅读更多内容 预览 hexo s 同步到远程 hexo d -g 5. 问题 Template render error: (unknown path) 在命令行输入hexo -g后报错，原因在于文章内容中有{}时，如果它没有被代码块包括，解析会出现错误，所以需要写成 &#123;% raw %&#125; 本地预览与远程显示不一致 删除缓存 hexo clean 在网页上刷新","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"C++基本语法","slug":"学习cpp","date":"2020-01-27T03:49:27.000Z","updated":"2020-04-06T16:40:48.049Z","comments":true,"path":"posts/6b599344.html","link":"","permalink":"https://zhouzhuyan.com/posts/6b599344.html","excerpt":"C++学习笔记本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。","text":"C++学习笔记本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。 一、 变量1. 用sizeof运算符求某一类型或变量占据的字节数#include&lt;iostream&gt;using namespace std;int main() &#123; int a; cout &lt;&lt; sizeof(a) &lt;&lt; endl; // sizeof运算符可以求变量占据的字节数 cout &lt;&lt; a &lt;&lt; endl; // 未初始化的变量，其值是不确定的 int b = 1; cout &lt;&lt; b &lt;&lt; endl;&#125; 2. 数据类型的自动转换1. 数int a = 11.34; // 11.34被自动转化为11后赋值给aint b = 30;double d = b; // d的值是30.0 2. 字符类型与整型int k = 'a';printf(\"%d\", k); // 输出97，即a的ASCII码int n = 98;char k = n;printf(\"%c\", k); // 输出b 3. 输入和输出1. scanf和printf#include&lt;iostream&gt;#include&lt;cstdio&gt; //使用scanf和printf时需要使用该库int main() &#123; int n; char c; float m; scanf(\"%d%c%f\", &amp;n, &amp;c, &amp;m); printf(\"%d %c %f\\n\", n, c, m); return 0;&#125; 用scanf可以一次读入多个不同类型的变量，输入各项用空格隔开 注意在输入字符时，不会跳过空格（空格也会被当做字符读入） 输入其它数据时，会跳过空格 2. cin和cout#include&lt;iostream&gt;using namespace std;int main() &#123; int c; while ((c=cin.get()) != EOF) &#123; cout &lt;&lt; (char) c; &#125; return 0;&#125; 使用cin读入所有字符，包括空格和回车，EOF Mac（ctrl+D停止输入，ctrl+C停止程序) windows ctrl+Z停止 3. cin&amp;cout / scanf&amp;printf 比较 cin，cout速度慢，输入输出数据量大时用scanf/printf 一个程序不要同时出现cin和scanf，cout和prinf 4. 运算 加、减、乘运算的溢出 二、函数1. 数组作为函数的参数传递数组作为函数的参数时，是传引用的，即形参数组改变了，实参数组也会改变 二维数组作为函数的形参时，必须写明函数有多少列，不要写明有多少行 void PrintArray(int a[][5]) &#123; cout &lt;&lt; a[4][3];&#125; 必须要写明列数，编译器才能够根据下标算出元素的地址 $\\color&#123;#F00&#125;&#123;a[i][j]的地址 = 数组首地址 + i \\times N \\times sizeof(a[0][0]) + j \\times sizeof(a[0][0])&#125;$ (N是数组列数) 形参数组的首地址就是实参数组的首地址 三、字符串1. 字符串的形式（1）字符串常量用双引号括起来的，如”China”, “C++ program”. 字符串常量占据内存的字节数等于字符中字符数目加1，结尾多出字符’\\0’. 但是字符串的长度不包含'\\0' “”也是合法的·1字符串常量，称为空串，仍然占据一个字节的内存空间，存放’\\0’ （2）存放于字符数组中，以’\\0’结尾用一维char数组存放字符串，结尾是’\\0’，数组元素个数至少为字符串长度+1。 用cin、scanf将字符串读入字符数组时，会自动在字符数组中字符串的末尾加上’\\0’。 （3）string对象。string是C++标准模板库里的一个类，专门用于处理字符串","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://zhouzhuyan.com/categories/C/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]}],"categories":[{"name":"数据科学","slug":"数据科学","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"},{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"},{"name":"基础","slug":"C/基础","permalink":"https://zhouzhuyan.com/categories/C/%E5%9F%BA%E7%A1%80/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://zhouzhuyan.com/categories/Design-Pattern/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://zhouzhuyan.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"},{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"},{"name":"Strategy","slug":"Strategy","permalink":"https://zhouzhuyan.com/tags/Strategy/"}]}