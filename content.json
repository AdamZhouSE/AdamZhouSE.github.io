{"meta":{"title":"Blog of Adam","subtitle":"Today is a gift, that is why it is called the present.","description":"Take notes and write articles about Software Engineering","author":"ZZY","url":"https://zhouzhuyan.com","root":"/"},"pages":[{"title":"About me","date":"2020-04-02T05:26:58.000Z","updated":"2020-04-02T05:26:58.000Z","comments":false,"path":"about/index.html","permalink":"https://zhouzhuyan.com/about/index.html","excerpt":"","text":"Introduction 重度b站用户，动漫，日剧，美剧，游戏，时政，生活区，电影，克苏鲁跑团，什么都看一点。 正在练习长跑，目标是跑一次半马 早睡早起，多读书，多运动，做一个不会猝死的攻城狮。 Experience 2020 开了博客，好好学习，天天向上 2018 南京大学软件工程"}],"posts":[{"title":"商业模式类型","slug":"需求与商业模式分析/商业模式类型","date":"2020-11-13T15:01:52.000Z","updated":"2020-11-13T15:01:52.000Z","comments":true,"path":"posts/dc6b170d.html","link":"","permalink":"https://zhouzhuyan.com/posts/dc6b170d.html","excerpt":"建筑中的式样就是将原型和原型的再现抽象为建筑设计的概念。","text":"商业模式类型本文将介绍5种商业模式类型 分拆商业模式 长尾商业模式 开放式的商业模式 多边商业模式 免费商业模式 1. 分拆商业模式对于分拆商业模式，首先需要了解一些基本概念。 我们认为企业内部有3类规则： 经济 竞争 文化 存在3种不同的基本业务类型以及它们对应的价值信条： 客户关系型业务——亲近顾客 产品创新型业务——产品领先 基础设施型业务——运营卓越 每种类型的业务都有不同的驱动因素，虽然它们可能同时存在于一家公司，但是由于彼此之间的冲突，需要进行分拆。 新产品开发 客户关系管理 基础设施管理 经济 速度是关键，越早获得的溢价越高 获取成本高，提高客单价，范围经济 大规模生产降低单位成本，规模是关键 竞争 针对人才，门槛低，小玩家多 针对范围竞争，寡头占领市场(7:3:1) 针对规模竞争，寡头占领市场(8:2) 文化 以员工为核心，鼓励创新人才 高度面向服务，客户至上心态 关注成本，统一标准，可预测性和有效性 分拆商业模式的一个典型的例子是可口可乐。 新产品 追求健康化：适应无糖的趋势 Costa咖啡，运动饮料，不再局限于可乐 客户关系 本地品牌收购 产品运营：diet coke到zero零度，摆脱女性专属的形象 外包装营销：小瓶，时尚罐和小罐 基础运营 调整灌装线：外包灌装 2. 多边平台商业模式多边平台将两个或更多独立但相互依存的客户群体连接在一起。 只有相关客户群体同时存在的时候，平台才具有价值。平台通过促进不同群体之间的互动而创造价值。比如信用卡连接商家和持卡人，计算机操作系统连接硬件厂商，应用开发商和用户。 单个用户群体的价值本质上取决于平台中另一群体的用户数量，这就产生了一个难题：“先有鸡还是先有蛋“。需要弄清楚哪一“边”能够更好的吸引其它“边”，从而提供免费服务甚至补贴，比如B站：观众免费，补贴Up主。 多边平台的价值提升在于它所吸引的用户数量的增加，这一现象也叫做网络效应。 3. 免费商业模式在免费商业模式中，至少有一个关键的客户群体可以持续免费地享受服务。 三种可行的免费商业模式：（至少一个群体将得到免费的商品） 广告模式：基于多边平台的免费商品 免费增值：免费的基本服务，可选的增值服务 诱饵&amp;陷阱：以免费或很便宜的初始价格吸引客户，并引导其重复购买 好的产品和服务以及高流量会吸引广告商，进而补贴产品和服务。但是要考虑广告费能否支撑起产品服务质量，现在的情况是巨头吞噬广告费的产品太多，流量红利已见底。 4. 诱饵&amp;陷阱模式通过廉价的，有吸引力的初始产品或服务，来促进相关产品未来的重复购买。 典型的例子有吉列剃须刀，刀柄加上频繁替换的刀片。 产品与后续产品之间要有紧密连接，从而使得极小收益的初始购买为后续高收益产品或服务的重复购买创造可能。关注后续产品交付，需要强大品牌支撑 5. 长尾商业模式核心是多样少量，进行极致的客户细分。 专注满足非主流市场需要以获得媲美主流产品的收益 信息技术与运营管理方法的改善使得定制化价值主张可以面向大量新客户，并且成本低廉。 参考： 《商业模式新生代》","categories":[{"name":"需求与商业模式分析","slug":"需求与商业模式分析","permalink":"https://zhouzhuyan.com/categories/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"商业模式","slug":"商业模式","permalink":"https://zhouzhuyan.com/tags/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/"}]},{"title":"虚拟化技术","slug":"云计算/虚拟化技术","date":"2020-10-29T11:48:36.000Z","updated":"2020-10-29T11:48:36.000Z","comments":true,"path":"posts/aa435277.html","link":"","permalink":"https://zhouzhuyan.com/posts/aa435277.html","excerpt":"虚拟化意味着对计算机资源的抽象。在云计算中，虚拟化技术可以用来对数据中心的各种资源进行虚拟化和管理，是实现云计算的关键技术。可以实现服务器虚拟化、存储虚拟化、网络虚拟化和桌面虚拟化。","text":"虚拟化技术虚拟化意味着对计算机资源的抽象。在云计算中，虚拟化技术可以用来对数据中心的各种资源进行虚拟化和管理，是实现云计算的关键技术。可以实现服务器虚拟化、存储虚拟化、网络虚拟化和桌面虚拟化。 1. 虚拟化技术简介1.1 核心思想虚拟化技术的核心思想是利用软件或固件管理程序构成虚拟化层，把物理资源映射为虚拟资源。在虚拟资源上可以安装和部署多个虚拟机，实现多用户共享物理资源。 1.2 虚拟化的实现添加一个称为虚拟化层的软件，管理客户操作系统，使其能够独立于主机操作系统同时运行在同一个硬件上。 2. 数据中心虚拟化云计算中运用虚拟化技术主要体现在对数据中心的虚拟化上。 数据中心是云计算技术的核心，由于数据中心的规模不断增大，成本上升，管理日趋复杂，传统的数据中心网络采用的多种技术，业务之间的孤立性，使得其结构复杂，导致服务器之间存在操作系统和上层软件异构、接口和数据格式不统一等问题。 随着云计算的发展，传统数据中心逐渐过渡到虚拟化数据中心，即采用虚拟化技术将原来数据中心的物理资源进行抽象整合。满足虚拟数据中心网络高速、扁平、虚拟化的要求。它的作用如下： 实现资源的动态分配和调度，提高现有资源的利用率和服务可靠性 提供自动化的服务开通能力，降低运维成本 具有有效的安全机制和可靠性机制，满足公众客户和企业客户的安全需求 方便系统升级、迁移和改造 数据中心的虚拟化是通过服务器虚拟化、存储虚拟化和网络虚拟化实现的。服务器虚拟化在云计算中是最重要和最关键的。 服务器虚拟化：将一个或多个物理服务器虚拟成多个逻辑上的服务器，集中管理 存储虚拟化：把分布的异构存储设备统一为一个或几个大的存储池，方便用户使用和管理 网络虚拟化：在底层物理网络和网络用户之间增加一个抽象层，其向下对物理网络资源进行分割，向上提供虚拟网络 2.1 服务器虚拟化2.2.1 服务器虚拟化的层次1. 寄居虚拟化寄居虚拟化层一般称为虚拟机监控器（VMM）。VMM安装在已有的主机操作系统上。损耗大，没有独立的Hypervisor层。 2. 裸机虚拟化直接将VMM安装在服务器硬件设备中，也可以认为该架构中的VMM是一个操作系统，一般称为Hypervisor，实现从虚拟资源到物理资源的映射。 x86体系结构的处理器并不是完全支持虚拟化，因为某些x86特权指令在地特权级上下文执行时，不能产生自陷，导致VMM无法直接捕获特权指令。解决方案是基于动态指令转换或硬件辅助的完全虚拟化技术和半虚拟化技术。 2.2.2 服务器虚拟化的底层实现1. CPU的虚拟化 任意时刻一个物理CPU只能运行一个虚拟CPU 每个客户操作系统可以使用一个或多个虚拟CPU 在各个操作系统之间，虚拟CPU运行相互隔离，互不影响 CPU虚拟化需要解决正确运行和调度两个关键问题。 虚拟CPU的正确运行是要保证虚拟机指令正确运行，而且各个虚拟机之间不能相互影响。现有的实现技术包括模拟执行和监控执行。 调度问题是指VMM决定当前哪个虚拟CPU在物理CPU上运行，要保证隔离性、公平性和性能。 2. 内存虚拟化内存虚拟化技术把物理内存统一管理，包装成多个虚拟的物理内 存提供给若干虚拟机使用，每个虚拟机拥有各自独立的内存空间。 内存虚拟化的思路主要是分块共享，内存共享的核心是内存页面的写时复刻（Copy on Write） 虚拟内存的管理包括3种地址：机器地址、物理地址和虚拟地址。 3. I/O设备虚拟化把真实的设备统一管理起来，包装成多个虚拟设备给虚拟机使用。 I/O设备虚拟化同样是由VMM进行管理的，主要有全虚拟化、半虚拟化和软件模拟3种思路。其中软件模拟是主流。 2.2.3 虚拟机迁移将虚拟机实例从源宿主机迁移到目标宿主机，并且在目标宿主机上能够将虚拟机运行状态恢复到其在迁移之前的状态。从虚拟机迁移的源于目的的角度看，虚拟机迁移包括3类： 物理机到虚拟机 P2V （Physical-to-Virtual） 虚拟机到虚拟机 V2V 虚拟机到物理机 V2P 其中虚拟机到虚拟机的迁移是云计算关注的重点。 1. 虚拟机动态迁移实时迁移（Live Migration），就是保持虚拟机运行的同时，把它从一台计算机迁移到另一台计算机，并在目的计算机恢复运行的技术。动态实时迁移对云计算至关重要。 云计算中心物理服务器负载处于动态变化中，当无法提供额外的物理资源时，可以将占用热门物理资源的虚拟机迁移到其它物理服务器，以达到负载均衡 物理服务器定期升级的需要，升级前将虚拟机迁移到其他物理服务器，等升级完成再迁移回来 2. 迁移的步骤 预迁移：主机A选定一个目的计算机作为VM的新主机 预定资源：主机向主机B发送迁移请求，确认B是否有必须资源，有就预定这些资源 预复制：主机A以迭代的方式将VM的内存页复制到主机B上，第一轮迭代传送所有的页，后面的迭代只复制前一轮传送过程中被修改过的页面。 停机复制：停止主机A的VM，把它的网络连接重定向到B。传送CPU状态和前一轮传送过程中被修改过的页。此时，主机A与B有一致的VM映像 提交：主机B通知A成功收到VM映像，主机A确认消息，抛弃或销毁其上的VM 启动：启动B上的VM，迁移后使用B上的设备驱动，广播新的IP地址 3. 迁移的内容内存迁移是虚拟机迁移最困难的部分。 一个完整的内存迁移可以分为3个阶段： Push：在VM运行的同时，将它的一些内存页面通过网络复制到目的机器上，过程中被修改的页面需要重传，以保证内容的一致性。 Stop-and-Copy：VM停止工作，把剩下的页面复制到计算机上，然后在目的计算机启动新的VM Pull：新的虚拟机运行过程中，如果访问到未被复制的页面，就会出现页错误并从原来的VM处把该页复制过来 实际操作中没有必要同时包含上述3个阶段。下面是3种迁移策略的优劣比较： 网络资源的迁移 虚拟机这种系统级别的封装方式意味着迁移时VM的所有网络设备，包括协议状态(如TCP连接状态)以及IP地址都要随之一起迁移。 在局域网内，可以通过发送ARP重定向包，将VM的IP地址与目的机器的MAC地址相绑定， 之后的所有包就可以发送到目的机器上。 存储设备的迁移 迁移存储设备的最大障碍在于需要占用大量时间和网络带宽，通常的解决办法是以共享的方式共享数据和文件系统，而非真正迁移。 目前大多数集群使用NAS(Network Attached Storage，网络连接存储)作为存储设备共 享数据。 2.2.4 隔离技术虚拟机隔离是指虚拟机之间在没有授权许可的情况下，互相之间不可通信，不可联系的一种技术。 软件角度：互相隔离的虚拟机之间保持独立，如同一个完整的计算机 硬件角度：被隔离的虚拟机相当于一台物理机，有自己的CPU、内存、硬盘、I/O等，它与宿主机之间保持互相独立的状态 网络角度：被隔离的虚拟机如同物理机一样，既可以对外提供网络服务，也一样可以从外界接受网络服务 现有虚拟机隔离机制主要包括： 网络隔离 构建虚拟安全文件防护网 基于访问控制的逻辑隔离机制 通过硬件虚拟让每一个虚拟机无法突破虚拟机管理器给出的资源限制 硬件提供的内存保护机制 进程地址空间的保护机制，IP地址隔离 确保虚拟机之间的安全与可靠性 1. 内存隔离内存管理单元（MMU Memory Management Unit） 管理虚拟存储器、物理存储器的控制路线 负责将虚拟地址映射为物理地址 提供硬件机制的内存访问授权 以Xen为例，它在虚拟内存到机器内存之间引入了一层中间地址，Guest OS看到的是这层中间地址，而不是机器的实际地址。Guest OS感觉自己的物理地址从0开始，是连续的，但Xen将这层中间地址真正地映射到机器地址上却可以是不连续的，这样保证了所有的物理内存可被任意分配给不同的Guest OS。 虚拟机监控器使用分段和分页机制对自身的物理内存进行保护。x86体系结构提供了支 持分段机制的虚拟内存，这能够提供另一种形式的特权级分离。 每个段包括基址、段限和一些属性位。 2. 网络隔离目标：确保把有害的攻击隔离，在可信网络之外和保证可信网络内部信息不外泄的前提下，完成网间数据的安全交换。 关键：系统对通信数据的控制，即通过不可路由的协议完成网间数据交换 问题：通信硬件工作在网络最下层（物理层），不能感知交换数据的机密性、完整性、可用性、可控性、抗抵赖等安全要素。 解决方案：通过访问控制、身份认证、加密签名等安全机制来实现，这些机制都是通过软件实现的。 实现原理：通过专用通信设备、专有安全协议和加密验证机制及应用数据提取和鉴别认证技术，进行不同安全级别网络之间的数据交换。 效果： 彻底阻断了网络间的直接TCP/IP连接 保证了网间数据交 换的安全、可控 杜绝了由于操作系统和网络协议自身漏洞带来的安全风险 2.2 存储虚拟化存储虚拟化将系统中分散的存储资源整合起来。 提高了存储资源利用率 降低单位存储空间成本 降低存储管理的负担和复杂性 技术与效果 在虚拟层通过适用数据镜像、数据校验和多路径等技术，提高了数据的可靠性及系统的可用性 利用负载均衡、数据迁移、数据块重组等技术，提升系统的潜在性能 整合和重组底层物理资源，得到多种不同性能和可靠性的 新的虚拟设备，满足多种存储应用的需求 2.2.1 存储虚拟化的一般模型虚拟化存储系统在原有存储系统结构上增加了虚拟化层，将多个存储单元抽象成一个虚拟存储池。 它的优势如下： 减少存储系统的管理开销 实现存储系统数据共享 提供透明的高可靠性和可扩展性 2.2.2 存储虚拟化的实现方式1. 基于主机的存储虚拟化也称基于服务器的存储虚拟化或者基于系统卷管理器的存储虚拟化，其一般是通过逻辑卷管理来实现的。虚拟机为物理卷映射到逻辑卷提供了一个虚拟层。 虚拟机的主要功能如下： 数据存储共享 存储资源管理 数据复制及迁移 集群系统 远程备份 灾难恢复 2. 基于存储设备的存储虚拟化也称基于存储控制器的存储虚拟化。主要是在存储设备的磁盘、 适配器或者控制器上实现虚拟化功能。 有很多的存储设备的内部都有功能比较强的处理器，带有专门的嵌入式 统，可以在存储子系统的内部进行存储虚拟化，对外提供虚拟化磁盘。 3. 基于网络的存储虚拟化在网络设备上实现存 储虚拟化功能，包括基于互连设备和基于路由器两种方式。 4. 优劣比较 方式 优势 劣势 主机 性价比较高 性能较差、可扩展性差、不支持异构平台 存储设备 存储子系统与主机无关，对系统性能的影响比较小，较容易管理 对于包含异构存储设备的SAN存储系统，虚拟化方法的效果不好，设备规模有限并不能进行级联，可扩展性差 网络 在性能、效果和安全都要好一些 连接主机到存储网络的路由器出现故障导致与故障路由器连接在一起的主机受到影响，数据无法访问 2.3 网络虚拟化传统数据中心由于服务器之间操作系统和上层软件异构、接口于数据格式不统一，数据中心内网络传输效率低。使用云计算后，数据同步传送的大流量、备份的大流量、虚拟机迁移的大流量，采用统一的交换网络减少布线、维护工作量和扩容成本。引入虚拟化技术后，数据中心网络虚拟化分为核心层、接入层和虚拟机网络虚拟化三个层面 2.4 桌面虚拟化每个桌面镜像就是一个带有应用程序的操作系统，终端用户通过一个虚拟显示协议来访问他们的桌面系统。这样做 的目的就是使用户的使用体验同他们使用桌面上的PC一样。 引用： [1]刘鹏.云计算[M].电子工业出版社:北京,2015:250-268.","categories":[{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"虚拟化","slug":"虚拟化","permalink":"https://zhouzhuyan.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"mosh优化ssh","slug":"折腾/mosh优化ssh","date":"2020-09-26T08:51:52.000Z","updated":"2020-09-26T08:51:52.000Z","comments":true,"path":"posts/38412875.html","link":"","permalink":"https://zhouzhuyan.com/posts/38412875.html","excerpt":"最近使用ssh连接云服务器时，卡顿的现象很严重，输入一段内容要等一会儿才会显示完全，在网上找了半天，看到了一个ssh的替代品——mosh","text":"最近使用ssh连接云服务器时，卡顿的现象很严重，输入一段内容要等一会儿才会显示完全，在网上找了半天，看到了一个ssh的替代品——mosh 1. 什么是moshMosh最大的特点是基于UDP方式传输，支持在服务端创建一个临时的Key供客户端一次性连接，退出后失效；也支持通过SSH的配置进行认证，但数据传输本身还是自身的UDP方式。 另外，Mosh还有两个我觉得非常有用的功能 会话的中断不会导致当前正在前端执行的命令中断，相当于你所有的操作都是在screen命令中一样在后台执行。 会话在中断过后，不会立刻退出，而是启用一个计时器，当网络恢复后会自动重新连接，同时会延续之前的会话，不会重新开启一个。 2. 服务端配置我的Linux服务器版本是Ubuntu18.04 输入如下命令安装mosh sudo apt-get update sudo apt-get install mosh Mosh使用UDP协议连接，端口从60000到61000，网上有教程使用ufw开启端口，但是经过测试是无效的，有一个比较方便的方法时直接在云服务器管理控制台的安全组中添加。 3. 客户端配置本地机器是Mac，输入命令安装mosh，注意客户端和服务端都需要安装mosh brew install mosh 安装完成后需要进入本地shell脚本文件中 如果安装了zsh，就使用命令vi ~/.zshrc 如果是bash，就使用命令vi ~/.bash_profile 添加如下两行 export LC_CTYPE=en_US.UTF-8 export LC_ALL=en_US.UTF-8 保存退出后，使用source ~/.zshrc或者source ~/.bash_profile使得更改生效。 使用如下命令连接 mosh root@IP -p 60001 输入瞬间变得丝滑起来。","categories":[{"name":"折腾","slug":"折腾","permalink":"https://zhouzhuyan.com/categories/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"mosh","slug":"mosh","permalink":"https://zhouzhuyan.com/tags/mosh/"}]},{"title":"Java 线程（一）","slug":"Java/Java-并发","date":"2020-09-24T08:47:31.000Z","updated":"2020-09-24T08:47:31.000Z","comments":true,"path":"posts/909f13b2.html","link":"","permalink":"https://zhouzhuyan.com/posts/909f13b2.html","excerpt":"本文介绍了线程的基本概念，线程的状态，两种创建线程的方法，线程的属性，线程的休眠以及线程内部的数据共享。","text":"线程（一）1. 线程的基本概念一个线程是程序内部的顺序控制流 1.1 线程与进程：每个进程都有独立的代码和数据空间，进程切换的开销大 线程是轻量的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器，线程切换的开销小 多进程：在操作系统中，能同时运行多个任务（程序） 多线程：在同一个应用程序中，有多个顺序流同时执行（有多个代码段同时在运行） 关于线程与进程的辨析可以看这一篇文章进程与线程的一个简单解释 1.2 线程的概念模型：虚拟的CPU，封装在java.lang.Thread类中 CPU所执行的代码和所处理的数据，传递给Thread类 线程体 Java的线程是通过java.lang.Thread类来实现的 每个线程都是通过某个特定的Thread对象的方法run()来完成其操作的，方法run()称为线程体 2. 线程状态线程可以有如下6种状态： New（新建） Runnable（可运行） Blocked （阻塞） Waiting （等待） Timed waiting（计时等待） Terminated （终止） 2.1 新建线程new Thread(t); 当使用new新建一个线程时，这个线程还没有开始运行，状态是新建 2.2 可运行线程new Thread(t).start(); 调用start方法，线程就处于可运行状态。它可能正在运行也可能没有运行，由操作系统决定它具体的运行时间。所以这个状态被称为可运行，而不是运行。 2.3 阻塞和等待线程当线程处于阻塞或等待状态时，它暂时是不活动的。 要由线程调度器重新激活这个线程，具体细节取决于它是怎样到达非活动状态的。 2.4 终止线程线程终止的原因有2个： run方法正常退出，线程自然终止 因为一个没有捕获的异常终止了run方法，使线程意外终止 3. 如何创建线程构造线程的两种方法 定义一个线程类，它继承类Thread并重写其中的方法run() 提供一个实现接口Runnable的类作为线程的目标对象，在初始化一个Thread类或者Thread子类的线程对象时，把目标对象传递给这个线程实例，由该目标对象提供线程体run() 3.1 通过Thread类创建线程通过Thread类来创建线程 继承Thread类，创建多线程的方法之一 从Thread类派生一个子类，并创建子类的对象 子类应该重写Thread类的run方法，写入需要在新线程中执行的语句段 调用start方法来启动新线程，自动进入run方法（不是直接调用run方法） 我们来看下面这个计算阶乘的程序 public class FactorialThreadTester &#123; public static void main(String[] args) &#123; System.out.println(&quot;main thread starts&quot;); FactorialThread myThread = new FactorialThread(10); myThread.start(); System.out.println(&quot;main thread ends&quot;); &#125; &#125; 我们自定义了FactorialThread类继承Thread类，重写了run方法 public class FactorialThread extends Thread &#123; private int num; public FactorialThread(int num) &#123; this.num = num; &#125; @Override public void run() &#123; int i = num; int result = 1; System.out.println(&quot;new thread starts&quot;); while (i &gt; 0) &#123; result *= i; i--; &#125; System.out.println(&quot;Result: &quot; + result); System.out.println(&quot;new thread ends&quot;); &#125; &#125; 结果： main thread starts main thread ends new thread starts Result: 3628800 new thread ends 主线程的任务就是创新新线程，创建完成后主线程就结束了 结果说明： main线程已经执行完后，新线程才执行完 main方法调用thread.start()方法启动新线程后并不等待run方法返回就继续运行，线程的run方法在一边独自运行，不影响原来的main方法的运行，也就是说新建的线程调用start()方法后不一定立即进入运行状态 3.2 通过Runnable接口构造线程 只有一个run()方法 Thread类实现了Runnable接口 便于多个线程共享资源 Java不支持多继承，如果定义的类已经继承了某个基类，便需要实现Runnable接口来实现多线程 以实现Runnable的对象为参数建立新的线程 我们定义一个ThreadSleep类实现Runnable接口 public class ThreadSleep implements Runnable &#123; private int sleepTime; public ThreadSleep() &#123; this.sleepTime = (int) (Math.random() * 6000); &#125; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; is going to sleep for &quot; + sleepTime); Thread.sleep(sleepTime); &#125; catch (Exception e) &#123; &#125; System.out.println(Thread.currentThread().getName() + &quot; ends&quot;); &#125; &#125; public class ThreadTest &#123; public static void main(String[] args) &#123; ThreadSleep t = new ThreadSleep(); new Thread(t, &quot;task1&quot;).start(); &#125; &#125; 或者也可以使用lambda表达式来创建实例 public class ThreadTest &#123; public static void main(String[] args) &#123; Runnable task1 = () -&gt; &#123; try &#123; int sleepTime = (int) (Math.random() * 6000); System.out.println(Thread.currentThread().getName() + &quot; is going to sleep for &quot; + sleepTime); Thread.sleep(sleepTime); &#125; catch (Exception e) &#123;&#125; System.out.println(Thread.currentThread().getName() + &quot; ends&quot;); &#125;; new Thread(task1, &quot;task1&quot;).start(); &#125; &#125; 使用Runnable接口实现线程可以将CPU，代码和数据分开，形成清晰的模型，还可以从其他类继承 直接继承Thread类实现线程，编写简单，直接继承，重写run方法，但是不能再从其他类继承 3. 线程属性3.1 中断线程除了已经废弃的stop方法，没有方法可以强制线程终止。不过，interrupt方法可以用来请求终止一个线程 当对一个线程调用interrupt方法时，就会设置线程的中断状态为true，如果当前线程被一个sleep调用阻塞，则抛出一个InterruptedException异常。 while (!Thread.currentThread().isInterrupted()) &#123; //blablabla &#125; static Thread currentThread()返回表示当前正在执行的线程的Thread对象 boolean isInterrupted()测试线程是否被中断 3.2 守护线程void setDaemon(boolean isDaemon) 调用t.setDaemon(true)将一个线程转换为守护线程，必须在线程启动之前调用，作用是为其它线程提供服务。比如计时器定时发送信号给其它线程，如果只剩下守护线程，虚拟机就会退出。 4. 线程的休眠public class FactorialThreadTester &#123; public static void main(String[] args) &#123; System.out.println(&quot;main thread starts&quot;); FactorialThread myThread = new FactorialThread(10); myThread.start(); try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; &#125; System.out.println(&quot;main thread ends&quot;); &#125; &#125; 结果 main thread starts new thread starts Result: 3628800 new thread ends main thread ends 运行结果说明，新线程结束后main线程才结束。 线程休眠就是为了让其他线程得到执行的机会 5. 线程内部的数据共享public class ThreadTest &#123; public static void main(String[] args) &#123; ThreadSleep t = new ThreadSleep(); System.out.println(&quot;Starting threads&quot;); new Thread(t, &quot;task1&quot;).start(); new Thread(t, &quot;task2&quot;).start(); new Thread(t, &quot;task3&quot;).start(); System.out.println(&quot;Thread started, main ends&quot;); &#125; &#125; 结果 Starting threads Thread started, main ends task1 is going to sleep for 5235 task3 is going to sleep for 5235 task2 is going to sleep for 5235 task2 ends task1 ends task3 ends 3个线程的休眠时间是一样的，因为是用一个Runnable类型的对象创建的3个新线程，这3个线程就共享了这个对象的私有成员sleepTime。 在现实生活中，如果我们需要多个售票窗口同时销售200张票，就可以使用上述的方法。 参考： 《Java核心技术 卷I》 学堂在线-Java程序设计进阶","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"},{"name":"线程","slug":"线程","permalink":"https://zhouzhuyan.com/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"泛型程序设计","slug":"Java/泛型程序设计","date":"2020-09-18T10:25:08.000Z","updated":"2020-09-18T10:25:08.000Z","comments":true,"path":"posts/98735cb0.html","link":"","permalink":"https://zhouzhuyan.com/posts/98735cb0.html","excerpt":"本文介绍了Java泛型程序设计，包括使用泛型程序设计的目的，如何自己设计泛型类和泛型方法，类型擦除，泛型设计的限制与局限性，泛型设计的继承规则和通配符规则。","text":"泛型程序设计1. 为什么要使用泛型程序设计？泛型程序设计(generic programming)意味着编写的代码可以对多种不同类型的对象重用。能够提高代码的复用性，比如ArrayList就可以收集任何类的对象，比如String，Integer等，而不用为这些对象去编写不同的类。 1.1 类型参数泛型允许在定义类和接口的时候使用类型参数(type parameter)，声明的类型参数在使用时使用具体的类来替换，比如下面这个例子 List&lt;String&gt; files = new ArrayList&lt;&gt;(); 可以很明显的看出数组中包含的是String对象，类型参数使得程序更易读，也更安全。 2. 定义简单泛型类泛型类(generic class)就是有一个或多个类型变量的类。下面定义了一个简单的泛型类Pair Pair类引入了一个类型变量T，用于指定方法的返回类型，字段和局部变量的类型 public class Pair&lt;T&gt; &#123; private T first; private T second; public Pair() &#123; first = null; second = null; &#125; public Pair(T first, T second) &#123; this.first = first; this.second = second; &#125; public T getFirst() &#123; return first; &#125; public T getSecond() &#123; return second; &#125; public void setFirst(T newValue) &#123; first = newValue; &#125; public void setSecond(T newValue) &#123; second = newValue; &#125; &#125; 3. 泛型方法与类型变量的限定我们再定义了泛型类之后，就可以设计带有类型参数的方法，比如我们想要寻找数组中元素的最大最小值，就可以这样定义 public static &lt;T&gt; T min(T[] a) &#123; // blablabla &#125; 但是这样的设计有一个问题，在方法内部对元素进行比较时，需要使用compareTo方法，这就要求类型T实现Comparable接口，所以需要对其进行限定(bound) public static &lt;T extends Comparable&gt; T min(T[] a) &#123; // blablabla &#125; 之所以使用extends而不是使用implements是因为T是限定类型的子类型，而继承关系更接近于这种概念，一个类型变量也可以有多个限定 T extends Comparable &amp; Serializable 下面使用我们定义的泛型类实现了一个寻找数组元素最大和最小值的方法。 import java.time.*; public class PairTest2 &#123; public static void main(String[] args) &#123; LocalDate[] birthdays = &#123; LocalDate.of(1906, 12, 9), // G. Hopper LocalDate.of(1815, 12, 10), // A. Lovelace LocalDate.of(1903, 12, 3), // J. von Neumann LocalDate.of(1910, 6, 22), // K. Zuse &#125;; Pair&lt;LocalDate&gt; mm = ArrayAlg.minmax(birthdays); System.out.println(&quot;min = &quot; + mm.getFirst()); System.out.println(&quot;max = &quot; + mm.getSecond()); &#125; &#125; class ArrayAlg &#123; /** Gets the minimum and maximum of an array of objects of type T. @param a an array of objects of type T @return a pair with the min and max values, or null if a is null or empty */ public static &lt;T extends Comparable&gt; Pair&lt;T&gt; minmax(T[] a) &#123; if (a == null || a.length == 0) return null; T min = a[0]; T max = a[0]; for (int i = 1; i &lt; a.length; i++) &#123; if (min.compareTo(a[i]) &gt; 0) min = a[i]; if (max.compareTo(a[i]) &lt; 0) max = a[i]; &#125; return new Pair&lt;&gt;(min, max); &#125; &#125; 4. 泛型代码和虚拟机虚拟机没有泛型类型对象，所有对象都属于普通类。 4.1 类型擦除无论何时定义一个泛型类型，都会自动提供一个相应的原始类型(raw type)，这个原始类型的名字就是去掉类型参数后的泛型类型名。同时，类型变量会被擦除(erased)，并替换为其限定类型。 类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。 类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换 2.移除所有的类型参数。 比如3中的例子，原始类型就会变成下面的样子 public class Pair &#123; private Object first; private Object second; &#125; 由于T是一个无限定的变量，所以直接用Object替换。 4.2 转换泛型表达式调用一个泛型方法时，如果擦除了返回类型，编译器会插入强制类型转换 Pair&lt;Employee&gt; buddies = ...; Employee buddy = buddies.getFirst(); getFirst方法擦除类型后的返回类型是Object，编译器自动插入转换到Employee的强制类型转换。 4.3 转换泛型方法类型擦除还会出现在泛型方法中，比如 public static &lt;T extends Comparable&gt; T min(T[] a) 在擦除类型之后，就会变成 public static Comparable min(T[] a) 5. 限制与局限性5.1 泛型遇到重载public class A &#123; public static void method(List&lt;Integer&gt; list) &#123; &#125; public static void method(List&lt;String&gt; list) &#125; 上述代码编译器会报错，提示两个方法冲突，因为它们被擦除之后都变为List 5.2 泛型类中静态变量无效public class Singleton&lt;T&gt; &#123; private static T singleInstance; public static &#125; 静态变量被泛型类的所有实例对象所共享。 5.3 不能抛出或捕获泛型类的实例既不能抛出也不能捕获泛型类的对象，泛型类扩展Throwable不合法。 6. 泛型类的继承规则考虑一个父类和子类，比如Employee和Manager，需要注意的是，Pair&lt;Manager&gt;不是Pair&lt;Employee&gt;的子类。 也就是说，无论S和T又怎样的关系，Pair&lt;T&gt;和Pair&lt;S&gt;没有任何关系，这对于类型安全非常重要。 参考： 《Java核心技术 卷I》 Java成神之路","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"商业模式画布","slug":"需求与商业模式分析/商业模式画布","date":"2020-09-17T13:23:31.000Z","updated":"2020-09-17T13:23:31.000Z","comments":true,"path":"posts/184fbc6f.html","link":"","permalink":"https://zhouzhuyan.com/posts/184fbc6f.html","excerpt":"在软院一门课学习商业模式就像在说30天精通C++一样。。。","text":"商业模式画布一种用来描述商业模式，可视化商业模式，评估商业模式以及改变商业模式的通用语言。 商业模式 描述了企业如何创造价值，传递价值和获取价值的基本原理 使用9个基本构造块描述并定义商业模式 1. 客户细分 （Customer Segments）客户细分构造块用来描述一个企业想要接触和服务的不同人群或组织 细分的条件： 需求催生新供给 （4G网络使得人们分享生活的方式从图片到视频，抖音快手的出现） 需要新分销渠道和客户关系类型（新零售） 产生的利润率不同 （薄利多销还是三年不开张，开张吃三年） 愿意为某方面的特殊需求买单 客户构成了任何商业模式的核心。没有（可获益的）客户，任何企业都无法长久存活。 需要谨慎的处理客户的细分与取舍，比如王者荣耀与Dota2，Dota2从魔兽，Dota而来，非常硬核，有一批持续的老玩家，但是王者荣耀的操作十分简单，能够吸引新人进入。明确服务于哪部分客户 企业把客户分成不同的细分段，每个段中的客户拥有共同的需求。 商业模式可以定义客户细分群体。这里给出几个客户细分群体的例子： 大众市场(Mass Market) 聚焦大范围客户群体，常见于消费电子行业（找人群共性） 小众市场(Niche Market) 常见与供应商-采购商的关系（强业务特征） 区隔化市场(Segmented) 在略有不同的客户需求和困扰的市场细分群体间有所区别。比如瑞士精密微型系统公司，提供的微型机械设计和生产解决方案服务与3个不同的客户细分群体——钟表，医疗，工业自动化行业。（某业务下基于客户共性的细分） 多元化市场(Diversified) 服务两个具有不同需求和困扰的客户细分群体。比如亚马逊的云计算服务，阿里，华为等（垄断地位、技术领先与外拓、团队能力与开拓意识强） 多边平台或多边市场(Multi-sided platforms/Multi-sided markets) 大型互联网平台 例如b站（大流量，上升为生活方式的使用习惯，多种收益流的平衡与补贴） 2. 价值主张 (Value Propositions)价值主张构造块用来描绘为特定客户细分创造价值的产品和服务 它解决了客户困扰或满足了客户需求。使得客户能够有偏爱从而选择一家而放弃一家（但是在现实中往往会有两个共存的情况，比如美团和饿了么） 可以思考如下一些问题的答案： 我们该向客户传递一种什么样的价值？ 我们能帮助客户解决一个什么样的难题？ 我们正在满足客户的那些需求？ 我们正在提供给客户群体哪些系列的产品和服务？ 价值主张通过迎合细分群体的独特需求来创造价值，价值是可以定量（如价格，服务速度）或定性的（如设计，客户体验）。下面有一些例子： 新颖(Newness) 满足客户未曾察觉的全新需求 性能(Performance) PC与显卡 定制化(Customization) 大规模定制（联名款）客户参与创造（MIUI，UGC） 一站式服务(Getting the job done) 咨询公司 设计(Design) 时尚，消费电子产品 品牌/身份地位(Brand/Status) 奢侈品 价格(Price) 廉价航空 缩减成本(cost reduction) 服务外包 风险控制(risk reduction) 保险 可获得性(accessibility) 共享经济 便利性/实用性(convinence/usability) 云计算 总的来说，可以分为3个部分： 让事情更简单（解决痛点）价格，缩减成本，便利性，实用性 让事情更复杂（获取收益）定制，设计，品牌地位，可获得性 让事情更透明（解决痛点）风险控制，一站式服务 3. 渠道通路 (Channels)描绘公司是如何与客户细分接触，沟通来描述其价值主张 企业与客户交互体系：交流、分销、销售渠道、售后，是用户的交互触电 作用：了解产品与服务、评估价值主张；购买产品与服务、传递价值主张；提供售后支持 商业真正的秘密，与产品设计的关系微妙（实现层面重合度小，却又容易受到产品口碑风险的冲击，需要做到真正的匹配），容易积累收益但是波动性大、风险高 通过哪些渠道可以接触客户细分群体？如何接触？ 哪些渠道有效？成本效益最好？ 渠道如何整合？渠道与客户的例行程序如何整合？ 把价值主张推向市场期间，发现如何接触客户的正确渠道组合是至关重要的。 如下是渠道五个阶段的示意图。 合作伙伴渠道利润低，但是可以通过其扩展企业接触客户的范围和收益。自有渠道利润高，但其建立和运营成本都很高。需要在不同的渠道之间建立平衡，令客户满意的同时使得收益最大化。 一个渠道可以包含上图的一个或五个阶段：知名度-评价-购买-传递-售后。 渠道的运营方式： 一个组织可选用自有渠道、合作方渠道、或混用，以追求获益与成本的平衡以及最佳的客户体验。 自身强渠道：比如蓝绿大厂，也就是oppo和vivo，在哪里都可以看到它们的身影，还有品牌贴牌（南极人）与授权认证，能主动引发流量的互联网平台（淘宝） 合作方渠道：各大电商平台，贝业新兄弟（与宜家合作提供家具配送与安装服务），小红书（种草拔草社区） 混用：天猫上的苏宁易购官方店（阿里与苏宁在仓储、物流、售后上的合作），网易严选 （低价）团购与尾货清理：拼多多，唯品会，在线带货 一定要重视渠道-设计运维一体化，最容易产生新闻的地方，要能够从渠道构建与运维看出隐含的价值主张与客户关系 4. 客户关系（Customer Relationship）一家企业针对某一个客户群体所建立的客户关系的类型 靠人员维护（“专属一对一财富管家”） VS 自动化设备（“24小时自助”） 动机： 开发新客户（客户获取） 留住原客户（客户维系）提高使用频率 增加销售量或客单价（当习惯使用一款产品后，价格变高，比如携程杀熟，天猫的88VIP事件） 免费推广-提升忠诚度（全家桶、归属感、情怀）-提高客单价 新手礼包/老用户激活礼包-品牌宣传与建设/用户等级-老客户专属套餐 我们每个客户细分群体希望我们与之建立和保持何种关系？ 客户关系类型 私人服务(personal assistance)：基于人与人之间的互动（商场导购、柜台服务与电渠、销售员） 专属私人服务(dedicated personal assistance)：为单一客户安排的专门的客户代表，是层次最深，最亲密的关系类型，需要较长的时间建立（私人银行服务、华为电信设备、健身/培训“私教”） 自助服务(self-service)：一家公司与客户不存在直接的关系，而是为客户提供自助服务所需要的条件(话费流量充值、银行普通业务（ATM与大厅内自助服务）) 自动化服务(automated services)：更加精细的自动化过程实现自助服务 （各类平台推荐系统、网站导航设计（活动、凑单、无货推荐、红色与橙色的加入购物车、立即购买）） 社区(communities)：与客户建立更深入的联系，促进社区成员的互动，帮助公司更好的理解客户需求（花粉俱乐部、小米之家、小红书、各类网游社区） 客户共同创造(co-creation)：和客户共同创造价值 MIUI，UGC（土豆、B站、抖音），各种评论（电影书籍-豆瓣、旅游住宿-Airbnb、普通商品-“自发安利”与评论区），采纳用户反馈的社区（产品调查问卷、游戏平衡运维），小红书 正面的例子是B站，设立了风纪委员，小黑屋等机制，维护了一个相对较好的社区环境，反面例子懂得都懂~ 客户关系类型可以分为以下3类 成本导向：自助服务、自动化服务 价值导向：私人服务、专属私人服务、客户共同创造（差异化的服务 比如VIP） 兼顾：社区 5. 收入来源（Revenue Streams）企业从每一个客户群体获得的现金收益（扣除成本的利润） 探索用户真正愿意付费的点！ 两类收益来源： 一次性交易收入 持续收入（进一步提供产品服务或售后支持）比如现在各种VIP的自动续费 定价机制 固定（基于静态变量）：目录价、基于产品特性（“青春版”、“畅享版”）、基于客户群（教育版）、基于数量 浮动（基于动态变量）：谈判/议价、收益管理（库存与发生购买的时间，如酒店、航班等）、实时市场价格、拍卖 三级价格歧视（差异定价）：按人（杀价、拍卖、杀熟）、按量（批发、团购、套餐、优惠券、峰谷阶梯定价）、按类（可选择的差异化服务：氪金、VIP、加急、视频会员、精装与典藏、机票折扣、社交裂变） 收入来源的方式 资产销售（asset sale）：实物产品所有权转让，消费者拥有处置的全部权利 使用费（usage fee）：特定的服务收费，客户使用服务越多，付费越多（电信、宾馆、快递、付费网游点卡、公共交通车票） 会员费（subscription fee）：销售重复使用的服务（健身卡、付费网游月卡、公共交通月票、音乐会员） 租赁（lending/renting/leasing）：特定资产在特定时间的使用权转移并获益（充电宝） 许可使用费（licensing）：专利授权、版权（图片、音乐、字体）、加盟或特许经营 经纪人佣金（brokerage fees）：信用卡（交易手续费）、支付平台（交易与提现手续费）、中介 广告费（advertising）：传媒、品牌策划、软件业与服务业；广告费增长乏力，分蛋糕的太多 6. 核心资源（Key Resources）保证一个商业模式顺利运行所需的最重要的资产 每个商业模式都需要核心资源，这些资源使得企业组织能够创造和提供价值主张，接触市场，与客户细分群体建立关系并获取收入。 用于：价值主张的创造与提供、开拓市场、维护客户关系并获益 可以“拥有”或者“租赁” “拥有”意味着额外的管理、折旧和风险，“租赁”意味着让出的利润空间 类型 实物资源（physical）：生产设备、房屋、车辆、机器、系统、销售点管理系统、分销渠道 知识性资源（intellectual）：品牌（可口可乐）、专利（高通与华为）、知识产权与体系（微软、SAP） 人力资源（human）：普遍存在，对于创新性和知识密集产业最重要（如IT业），出色的营销团队 金融资源（financial）：车贷、电子设备免息分期、GE的膨胀与衰落 7. 关键业务（Key Activities）保障其商业模式正常运行所需做的最重要的事情 价值主张、获得市场、客户关系与收益 与价值主张强相关，价值主张的具象化 构建护城河：商业模式创新-&gt;构建不可替代的关键业务-&gt;支撑服务升级-&gt;基础设施投资-&gt;底层技术突破 09年开始建立阿里云，因为阿里巴巴意识到如果不建立自己的云服务平台，它在淘宝的利润将因为不断扩大的云服务需求被Amazon吞噬 类型 生产(production)：包含分销（企业商业模式的核心） 解决方案(problem solving)：知识管理与持续的培训（咨询公司，医院） 平台/网络(platform/network)：以平台为核心资源的商业模式，其关键业务与平台管理，服务提供和平台推广相关（XX网、Visa卡、操作系统、应用商店、游戏平台） 8. 重要合作（Key Partnership）保证一个商业模式顺利运行所需的供应商和合作伙伴网络 非竞争者之间的战略联盟 3q大战之后的腾讯联盟（与阿里直营思路显著不同） 竞争者之间的战略合作 红蓝快乐水、微信支付与支付宝、米国两党制 新业务的合资公司托拉斯 大厂“生态” 、微信v.s. 苹果、Fortnite v.s. App Store + Google Play（fortnite试图使得不同系统上的账户可以互通） 稳定供应关系的供应商和采购商 产业园、苹果认证供应商、闭环的互联网影视平台（传统影视产业：制作、发行、院线） 合作动机 优化与规模效应：降低成本，外包或共享基础设施 特殊资源及活动的获得：高技术产品、销售团队、特许商品 降低风险和不确定性：某领域内的战略联盟（蓝光、5g） 9. 成本结构（Cost Structure）运营一个商业模式所发生的全部成本 确定核心资源、关键业务和重要合作之后，成本核算将相对容易 也有以低成本结构为核心的商业模式（廉航、红米、Zara） 什么是我们我们商业模式中最重要的固有成本？ 哪些核心资源、关键业务花费最多 导向 成本导向 cost-driven：成本最小化，创造并维持极尽精简的成本结构 比如廉价航空公司 价值导向 value-driven：高端的价值主张与高度的个性化服务 比如豪华酒店 特点 固定成本：管理员工工资，租金，生产设备 可变成本：加工工人工资，加（bai）班（ri）费（meng），广告推广费，水电，原材料消耗 规模经济：大宗采购，大规模生产摊薄的固定成本 范围经济：渠道的复用 小米台灯为什么那么便宜？ 参考： 《商业模式新生代》","categories":[{"name":"需求与商业模式分析","slug":"需求与商业模式分析","permalink":"https://zhouzhuyan.com/categories/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"商业模式","slug":"商业模式","permalink":"https://zhouzhuyan.com/tags/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/"}]},{"title":"云计算概述","slug":"云计算/云计算概述","date":"2020-09-16T12:00:44.000Z","updated":"2020-09-16T12:00:44.000Z","comments":true,"path":"posts/756f403a.html","link":"","permalink":"https://zhouzhuyan.com/posts/756f403a.html","excerpt":"本文对云计算进行了简单的介绍，包括云计算的起源，云计算产生的时代背景，云计算的定义，服务模型和实现机制，云计算的优势以及当前云计算的面对的风险与挑战。","text":"云计算概述1. 起源自计算机诞生之日起，人类就从未停止对更高计算性能的追求。 那么如何提高计算性能呢？ 思路1 把一台计算机做的足够强大 计算范式：集中式计算 将所有计算资源集中在一个物理系统之内，所有资源（处理器，内存，存储器）是共享的，并且紧耦合在一个集成式操作系统中。 计算范式：并行计算 提高效率，同一时间执行多个计算 所有处理器紧耦合于中心共享内存或松耦合于分布式内存，处理器通信通过共享内存或通过消息传递完成。 问题：单台计算机价格高昂，并行计算有瓶颈 思路2 人多力量大，机多计算强 由众多自治计算机组成，各自拥有私有内存，通过计算机网络通信，信息交换通过信息传递完成。 多个物理系统：分布式系统，分布式程序，分布式编程 1.1 传统分布式计算系统 1.1.1 计算集群实现计算抽象 特点 基本组件为计算节点、通信软件、网络接口卡以单独身份接入互联网 1.1.2 P2P系统实现了存储抽象 特点 节点是简单接入互联网的客户机，自治，自由加入和退出问题 无中心协作或中心数据库，有专用的物理互联网络，不稳定，不可靠，不安全 1.1.3 计算网络接近”云“ 特点 计算资源整合，一个集成的资源池，提供基础设施 节点包括：工作站，服务器，集群，超级计算机问题： 异构、用户管理、耗资源的协议、安全性、应用受限 1.2 云计算1.2.1 定义云计算是相对与1.1中的3个系统更好的解决方案，它对网格进行优化，可以完美解决分布式计算。 大量计算节点，同构可控 专用内部网络 通过互联网对外服务（公有云） 全面虚拟化（计算、存储、网络、桌面） 集中管理 安全高效 云计算的定义基本可以总结为： 云计算是一种商业计算模型，通过网络按需提供可以动态伸缩的廉价计算服务。 云是一些可以自我维护和管理的虚拟计算资源，通常是一些大型服务器集群，包括计算服务器，存储服务器和宽带资源等。 之所以称为云，是因为其具有现实中云的特征——云一般都较大，云的规模可以动态伸缩，它的边界是模糊的，位置是不确定的， 1.2.2 概念模型PPT p11 1.2.3 云计算 vs 网格计算 网格计算 云计算 共同： 提升计算能力，完成数据处理 构建虚拟资源池且动态可伸缩 支持多承租任务 聚合分布的资源，恰好有 使用专有的资源，专门做 强调虚拟组织，立足特定任务 不强调虚拟组织，重视通用性 利用中间件来屏蔽异构系统 不强调异构性 面向科研，商业模式不清晰 针对企业应用，商业模式清晰 2. 初探2.1 时代背景 今天是大数据的时代，一切皆为大数据，一切皆为大数据。我们先来简单的介绍一下大数据。 什么是大数据？ 海量数据或巨量数据，其规模巨大到无法通过目前主流的计算机系统在合理时间内获取、存储、管理、处理并提炼以帮助使用者决策。 （刘鹏，《云计算》第三版） 为什么会产生大数据？ 数据产生方式的改变，越来越自动化 人类活动越来越依赖数据 互联网+物联网大数据有怎样的特征？ 3V: Volume(量大), Variety(多样), Velocity(快速) 4V+1C: Value(低价值密度), Complexity(复杂:处理和分析难度大) 5V: Volume, Variety, Velocity, Value, Veracity(真实) 云计算是处理大数据的手段。大数据促进了云计算的产生，激发了云计算的潜力。云计算为大数据的收集，存储，加工和应用提供了更好的支持。 2.2 云的服务模型 2.2.1 IaaS将硬件设备等基础资源封装成服务服务提供给用户。用户相当于在使用裸机和磁盘，比如亚马逊云计算AWS的弹性计算云EC2 通过虚拟机的方式对外提供计算和存储能力 机器享有公网IP，多个虚拟机之间通过网络进行通信 类似租用独立的计算机 用户自行解决多台机器之间的协同问题 优势 允许用户动态申请和释放资源 按使用量计费 由公众共享，具有更高的资源使用效率（节能环保） 2.2.2 PaaS抽象层次更进一步，提供用户应用程序的运行环境 自身负责资源的动态扩展和容错管理 优势 用户无需考虑节点间的配合问题 缺陷 用户自主权降低，需按照给定的编程环境和编程模型构建应用 2.2.3 SaaS针对性更强，将某些特定应用软件功能封装成服务。只提供某些专门用途的服务供应用调用 2.2.4 实现机制不同的供应商提供了不同的解决方案，没有同意的技术体系结构。下图是云计算体系结构参考模型 SOA构建层 封装云计算能力成标准的Web Service服务，并纳入SOA体系 其中，SOA是面向服务的体系结构(Service-oriented Architecture) 管理中间件层 云计算的资源管理，并对众多应用任务进行调度，使资源能够高效、安全的为应用提供服务 资源池层 将大量相同类型的资源构成同构或接近同构的资源池 物理资源层 计算机、存储器、网路设施、数据库和软件等 Tip 管理中间件层和资源池层是云计算技术最关键的部分，SOA构建层的功能更多依靠外部设施提供。 下面以IaaS为例，简述云计算的实现机制。 用户交互接口向应用以Web Services方式提供访问接口，获取用户需求。 服务目录是用户可以访问的服务清单。 系统管理模块负责管理和分配所有可用的资源，其核心是负载均衡。 配置工具负责在分配的节点上准备任务运行环境。 监视统计模块负责监视节点的运行状 态，并完成用户使用节点情况的统计 2.3 风险和挑战2.3.1 云计算压倒性的成本优势云计算之所以拥有划时代的优势，就是因为它的技术特征和规模效应所带来的的压倒性的性能价格比优势。 全球企业的IT开销分为三部分：硬件开销、能耗和管理成本。调查显示，在硬件开销持平的同时，能耗和管理成本上升非常迅速。而云计算的经济性主要体现在以下两个方面： 一方面，如果使用云计算，可以获得更低的硬件和网络成本，更低管理成本和电力成本。比如Google的数据中心就建立在人烟稀少，气候寒冷，水电资源丰富的地区，这样使得电价、场地、人力都远远比在城市建立要低，今天的中小企业直接租用相关的云服务也比自己去租用场地，搭建服务器要便宜的多。 另一方面，云计算与传统的互联网数据中心(IDC)的资源利用率有很大不同。在以前，每个租用IDC的网站所获得的带宽，处理能力和存储空间都是固定的，但是网站的访问量并不均衡，比如有的网站白天没啥人看，晚上流量很多。为了应对这些情况，网站拥有者需要按照峰值要求来配置服务器和网络资源，这就造成了资源的浪费。而云计算平台提供弹性服务，动态分配和释放资源，大大提高了资源的利用效率。 2.3.2 其它优势 可扩展性和可伸缩性 虚拟化 模拟符合用户需求的任何计算环境 高可靠 多副本容错 计算节点同构可互换等保障措施 管理简单 安全 2.3.3 云计算技术难点 2.3.4 风险与挑战增加了安全漏洞 运程使用IT资源需要云用户将信任边界扩展到外部的云，建立这样的安全架构同时又不引入安全漏洞是非常困难的 重叠的信任边界和不断增加的数据曝光为恶意的云用户提供了更多的攻击IT资源、窃 取或破坏企业数据的机会 降低了运营管理控制 云用户对云资源的管理控制低于对企业内部IT资源的管理控制 云提供者可能不遵守它发布的云服务保证 云用户和云提供者之间较长的地理距离可能需要更多的网络跳数，会带来延迟波 动和带宽受限 云提供者之间有限的可移植性 由于缺乏行业标准，不同的云提供者提供的服务存在较大差异 出于商业原因，云平台也不希望用户更换平台 多地区法规和法律问题 第三方云提供者通常选择造价较低、方便的地理位置建立数据中心，而云用户通常不会意识到所使用IT资源和自身数据所存放的位置 潜在的数据获得和公开，比如某些国家的法律规定，某些类型的数据必须向某些政府机构或数据主体公开 参考： 《云计算 （第三版）》 刘鹏","categories":[{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"异常与断言","slug":"Java/异常与断言","date":"2020-09-12T13:26:04.000Z","updated":"2020-09-12T13:26:04.000Z","comments":true,"path":"posts/35f9d194.html","link":"","permalink":"https://zhouzhuyan.com/posts/35f9d194.html","excerpt":"在理想世界里，用户输入数据的格式永远都是正确的，代码永远不会出现bug，然而，在现实世界的开发过程中，总会遇到各种各样的问题，这时候就需要我们使用异常和断言来调试我们的程序，解决问题。","text":"异常与断言在理想世界里，用户输入数据的格式永远都是正确的，代码永远不会出现bug，然而，在现实世界的开发过程中，总会遇到各种各样的问题，当然，我也可以说，这不是bug，而是特性~~~言归正传，如果由于程序的错误导致用户所做的工作统统丢失，那用户可能就再也不会用它了。为了避免这样的情况，至少应该做到以下几点 向用户通知错误 保存所有的工作 允许用户妥善地退出程序 1. 处理错误为了能够处理程序中的异常情况，必须考虑到程序中可能会出现的错误和问题。比如： 用户输入错误 设备错误 物理限制 代码错误 1.1 异常分类在Java中，异常对象都是派生于Throwable类的一个实例。在下一层分解为两个分支，Error和Exception。Error描述了Java运行时系统的内部错误和资源耗尽错误Exception又分解为两个分支由编程错误导致的RuntimeException，比如错误的强制类型转换，数组访问越界等由I/O错误导致的其他异常IOException，比如试图打开一个不存在的文件等如下图所示是异常层次结构的一个示意图 Tip 如果出现RuntimeException，那么一定是你的问题 Java将派生于Error类或RuntimeException类的所有异常称为非检查型(unchecked)，所有其他异常称为检查型(checked) 1.2 如何抛出异常假设我们正在读取一个文件，预期读取1024个字符，但是在读到500个字符的时候文件就结束了，出现了问题，我们希望抛出一个EOFException，即输入过程中意外遇到了EOF。 String readData(Scanner in) throws EOFException &#123; // blablabla if (!in.hasNext()) &#123; if (n &lt; len) &#123; throw new EOFException(); &#125; &#125; &#125; 1.3 创建异常类如果我们遇到了标准异常类无法描述清楚的问题，可以自己创建异常类。我们可以定义一个派生于Exception的类，或者某个Exception的子类，比如IOException。 class FileFormatException extends IOException &#123; public FileFormatException() &#123;&#125; public FileFormatException(String gripe) &#123; super(gripe); &#125; &#125; 2. 捕获异常要想捕获一个异常，需要设置try/catch块。 try &#123; // blablabla &#125; catch (Exception e) &#123; // blablabla &#125; 如果try语句块中的代码抛出了catch子句中指定的一个类，那么程序将跳过try语句块中的其余代码，并执行catch语句块中的代码。如果try中的代码没有异常，那么程序就会跳过catch语句。 2.1 finally子句代码抛出一个异常时，就会停止处理这个方法中的剩余代码，但是如果这个方法中存在一些资源需要被清理，就会产生问题。finally子句不管异常有没有被捕获，都会执行。比如下面的例子，所有情况下都会程序都会关闭输入流。 FileInputStream in = new FileInputStream(); try &#123; // blablabla &#125; catch (IOException e) &#123; // blablabla &#125; finally &#123; in.close(); &#125; 2.2 try-with-resources语句对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。关闭资源的常用方式就是在finally块里是释放，即调用close方法。就像我们在2.1节中的例子一样，但是从java7开始，我们可以使用一种更好的方法try-with-resources语句来实现。它的形式如下 try (Resources res = ...) &#123; // blablabla &#125; 我们来看一个具体的例子，读取一个文件中的所有单词。 try (Scanner in = new Scanner( new FileInputStream(&quot;/usr/share/dict/words&quot;), StandardCharsets.UTF_8)) &#123; while (in.hasNext()) &#123; System.out.println(in.next()); &#125; &#125; 3. 使用断言断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查。断言的关键字是assert。有以下两种形式 assert condition; assert condition : expression; 这两种形式都会计算条件，如果结果为false，抛出AssertionError异常。在第二个语句中，表达式将传入AssertionError对象的构造器，并转换成一个消息字符串。 默认情况下，断言是禁用的，需要在运行程序时用-ea启用断言。 参考： 《Java核心技术 卷I》 Java工程师成神之路","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"概述与递归简论","slug":"数据结构与算法/数据结构与算法概述","date":"2020-09-10T12:23:52.000Z","updated":"2020-09-10T12:23:52.000Z","comments":true,"path":"posts/ddb07891.html","link":"","permalink":"https://zhouzhuyan.com/posts/ddb07891.html","excerpt":"本文对数据结构进行了介绍，讲述了什么是数据结构以及数据结构涉及到的3个层面。同时介绍了递归的思想和设计，并讲解了斐波那契数列，排列，汉诺塔问题的递归解决方式。","text":"概述1. 什么是数据结构？我们把这个词分解开来，首先回答什么是数据。数据是信息的载体，是数字，字符或其它符号的集合。数据结构是数据对象和组成对象的数据成员之间的关系。 Data_Structure = &#123;D, R&#125;D是数据对象R是D中所有数据成员的关系 数据结构涉及3个方面：逻辑结构：从用户视图看，是面向问题的物理结构：从具体实现视图看，是面向计算机的操作及其实现我们以一个学生表为例，它的逻辑结构式线性表，物理结构是数组，而操作是增删改查 2. 递归简论2.1 如何设计递归我们通过递归来引入数据结构与算法的学习。当一个函数用它自己来定义时，我们就称它是递归(recursive)的。我们可以看下面这个简单的例子 f(x) = \\begin{cases} 0, & x=0 \\\\\\\\ 2f(x-1)+x^2, & x > 0\\end{cases}我们用代码来实现它 public static int f(int x) &#123; if (x == 0) &#123; return 0; &#125; return 2 * f(x - 1) + x * x; &#125; 观察这段代码，函数体内首先有一个if结构，这是递归的基准情况(base case)，即此时函数的值可以直接算出而不用进行递归。再往下的return语句则进入了递归，要注意的是，递归调用将反复进行直到出现基准情况为止。比如我们计算f(3)，那么会调用f(2), f(1)直到出现基准情况f(0)，它的计算实际上是这样的 (2\\times(2\\times(2\\times f(0)+1\\times1) + 2\\times2)+3\\times3)下面我们再来看一种糟糕的递归设计 public static int bad(int n) &#123; if (n == 0) &#123; return 0; &#125; return bad(n / 3 + 1) + n - 1; &#125; 我们会发现，在上述的代码中，bad(1)被定义为bad(1)，而不知道具体是多少，计算机会反复调用它，程序无法停止，也求不出解。 通过上面的两个例子，可以得出递归的设计准则 基准情形(base case)。必须有某些基准的情形，不用递归就能够求解。 不断推进(make progress) 递归调用必须能够朝着一个基准情形推进。 2.2 递归实践我们通过几个经典的例子来加深对递归的理解。 2.2.1 菲波那切数列我们知道它的函数是$fib(0)=0,\\ fib(1)=1,\\ fib(n)=fib(n-1)+fib(n-2); n&gt;=2$可以很容易地将其用代码表示 public static long fib(long n) &#123; if (n == 0 || n == 1) &#123; // base case return n; &#125; return fib(n - 1) + fib(n - 2); &#125; 2.2.2 排列现在有一个数组&#123;a, b, c&#125;，要求对它进行全排列，即排列结果是abc,acb,bac,bca,cab,cba public class Permutation &#123; public static void permutation(char[] list, int k, int m) &#123; int i; if (k == m) &#123; for (i = 0; i &lt;= m; i++) &#123; System.out.print(list[i]); &#125; System.out.println(); &#125; else &#123; for (i = k; i &lt;= m; i++) &#123; char temp = list[k]; list[k] = list[i]; list[i] = temp; permutation(list, k + 1, m); temp = list[k]; list[k] = list[i]; list[i] = temp; &#125; &#125; &#125; public static void main(String[] args) &#123; char[] list = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; permutation(list, 0, 2); &#125; &#125; 2.2.3 汉诺塔问题汉诺塔问题是一个经典的问题。汉诺塔(Hanoi Tower)，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？64个圆盘对于当前的计算机，可能需要几百上千年才能算出，但是我们可以简化这个问题，使用3个圆盘来看一下如何用递归来实现。 根据我们的递归设计准则，首先要明确基准条件，也就是只有一个圆盘，那很简单，就是把它从第一根柱子移动到第三根柱子，然后设计不断推进的过程，有3根柱子，起点(fromTower)，终点(toTower)，中转(auxTower)。有一个非常易于理解的方式，我们首先将盘从起点移到中转点，这个时候的中转点实际上是终点，再从中转点移到终点，这个时候的中转点实际上是起点，所以设计的两个递归是这样的。 moveDisks(n - 1, fromTower, auxTower, toTower); moveDisks(n - 1, auxTower, toTower, fromTower); 下面是完整的代码实现。 public class HanoiTower &#123; public static void moveDisks(int n, char fromTower, char toTower, char auxTower) &#123; if (n == 1) &#123; System.out.println(&quot;move disk &quot; + n + &quot; from &quot; + fromTower + &quot; to &quot; + toTower); &#125; else &#123; moveDisks(n - 1, fromTower, auxTower, toTower); System.out.println(&quot;move disk &quot; + n + &quot; from &quot; + fromTower + &quot; to &quot; + toTower); moveDisks(n - 1, auxTower, toTower, fromTower); &#125; &#125; public static void main(String[] args) &#123; moveDisks(3, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;); &#125; &#125; 打印结果 move disk 1 from A to C move disk 2 from A to B move disk 1 from C to B move disk 3 from A to C move disk 1 from B to A move disk 2 from B to C move disk 1 from A to C 参考： 《数据结构与算法 Java语言描述》","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://zhouzhuyan.com/tags/%E9%80%92%E5%BD%92/"}]},{"title":"Java 接口","slug":"Java/Java-接口","date":"2020-09-09T01:06:16.000Z","updated":"2020-09-09T01:06:16.000Z","comments":true,"path":"posts/d993c7e9.html","link":"","permalink":"https://zhouzhuyan.com/posts/d993c7e9.html","excerpt":"本文介绍了Java面向对象编程中的另外一个重要概念——接口，介绍了接口的基本含义，属性，接口的回调，以Comparator接口为例展示了如何自定义和使用接口。","text":"接口接口(interface)用来描述类应该做什么，而不指定它们具体该如何做。一个类可以实现(implement)一个或多个接口。 1. 接口的概念接口不是类，而是对希望符合这个接口的类的一组需求 Tip 接口中的所有方法都自动是public，因此在接口中声明方法时，不必提供关键字public 接口绝不会有实例字段 public class Employee implement Comparable&lt;Employee&gt; &#123; // blablabla @Override public int compareTo(Employee other) &#123; return Integer.compare(salary, other.salary); &#125; &#125; 2. 接口的属性接口不是类，不能够使用new实例化一个接口，但是可以声明接口的变量，接口变量必须引用实现这个接口的类对象 Comparable x = new Employee(. . .); Tip为什么需要接口，而不是直接使用抽象类？因为Java不支持多继承，所以每个类只能扩展一个类。而接口提供了多继承的好处，而避免了多重继承的复杂性和低效性。 3. 接口与回调回调(callback)是一种常见的程序设计模式。在这种模式中，可以指定某个特定事件发生时应该采取的动作。比如我们设计了一个时钟，可以请求每秒更新一次，以便更新时钟的表盘。 下面是一个定时器和动作监听的具体使用的例子，定时器启动之后，程序将弹出一个消息对话框，并等待用户点击OK来终止程序的运行，在程序等待用户操作的同时，每隔1秒显示一次当前时间 import java.awt.*; import java.awt.event.*; import java.time.*; import javax.swing.*; public class TimerTest &#123; public static void main(String[] args) &#123; TimePrinter listener = new TimePrinter(); // construct a timer that calls the listener // once every second Timer timer = new Timer(1000, listener); timer.start(); // keep program running until the user selects &quot;OK&quot; JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;); System.exit(0); &#125; &#125; class TimePrinter implements ActionListener &#123; @Override public void actionPerformed(ActionEvent event) &#123; System.out.println(&quot;At the tone, the time is &quot; + Instant.ofEpochMilli(event.getWhen())); Toolkit.getDefaultToolkit().beep(); &#125; &#125; 4. Comparator接口如果我们想要对字符串数组进行排序，可以直接使用String.compareTo方法按字典顺序比较字符串。如果我们希望按照字符串长度来进行比较，可以自己实现一个比较器(comparator)，如下面的例子中，将比较器作为参数传入Arrays.sort方法中。 import java.util.Arrays; import java.util.Comparator; public class LengthCompare &#123; public static void main(String[] args) &#123; String[] friends = &#123;&quot;Adam&quot;, &quot;Ben&quot;, &quot;Peter&quot;, &quot;Noah&quot;&#125;; Arrays.sort(friends, new LengthComparator()); System.out.println(Arrays.toString(friends)); &#125; &#125; class LengthComparator implements Comparator&lt;String&gt; &#123; @Override public int compare(String o1, String o2) &#123; return o1.length() - o2.length(); &#125; &#125; 参考： 《Java核心技术 卷I》","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"Java 继承","slug":"Java/Java-继承","date":"2020-09-08T08:09:47.000Z","updated":"2020-09-08T08:09:47.000Z","comments":true,"path":"posts/8b3a0e63.html","link":"","permalink":"https://zhouzhuyan.com/posts/8b3a0e63.html","excerpt":"本位介绍了Java面向对象编程中的重要思想——继承，包括对超类和子类，对象包装器和继承的设计技巧的介绍。","text":"继承继承(inheritance)的基本思想是基于已经有的类创建新的类，复用这些类的方法。 一、类，超类和子类在前面的文章中我们实现了一个Employee类，假设你在某个公司工作，这个公司的经理和员工的待遇不一样，普通员工在完成任务后仅领取薪水，而经理还拥有奖金。这个时候，我们可以定义一个新类Manager，使用继承重用Employee中的代码，同时定义新的方法来增加奖金这一功能。 TipManager is-a Employeeis-a关系是继承的一个明显特征 1. 定义子类使用extends关键字来表示继承 public class Manager extends Employee &#123; // blablabla &#125; 关键字extends表明正在构造的新类派生于一个已经存在的类。这个类被称为超类(superclass) 或父类(parent class)，新类称为子类(subclass)在设计类时，应该将一般方法放在超类中，将更特殊的方法放在子类中比如我们在Manager类中应该实现一个设置奖金金额的方法。 public class Manager extends Employee &#123; private int bonus; public void setBonus(double bonus) &#123; this.bonus = bonus; &#125; &#125; 2. 覆盖方法超类中的某些方法对子类不一定适用，比如Manager类中的getSalary方法应该返回薪水和奖金的总和，所以要提供一个新的方法来覆盖(override)超类中的某个方法。要注意的是，Manager类的getSalary方法不能够直接访问salary字段，因为其实Employee类的私有字段，所以需要使用super关键字 public int getSalary() &#123; int baseSalary = super.getSalary(); return baseSalary + bonus; &#125; 3. 子类构造器public Manager(int id, String name, int salary) &#123; super(id, name, salary); bonus = 0; &#125; 语句super(id, name, salary);实现了对Employee中私有字段的调用 4. 多态我们可以通过is-a来判断是否将数据设计为继承关系，它的另外一种表述是替换原则，即程序中出现超类对象的任何地方都可以使用子类对象替换。 在Java中，对象变量时多态(polymophic)的。一个Employee类型的变量既可以引用一个Employee类型的对象,也可以引用Employee类的任何一个子类的对象(比如Manager) Employee e; e = new Employee(1, &quot;A&quot;, 10000); e = new Manager(2, &quot;B&quot;, 20000); 虽然这里的e引用了Manager类型的对象，但是编译器只将e看成是一个Employee对象，所以如下的调用是错误的。 e.setBonus(10000); // ERROR 5. 阻止继承: final类和方法如果我们需要阻止某个类被继承，可以使用final关键字 public final class Child extends Father &#123; // blablabla &#125; 类中的某个特定的方法也可以声明为final，这样子类就不能够覆盖这个方法。 Tip为什么要将类或方法声明为final？确保它们不会在子类中改变语义。比如String类是final类，所以一个String引用引用的一定是String对象，而不是其它。 6. 抽象类在继承层次结构中，位于上层的类更具有一般性比如我们加入Person类和Student类，下图是这三个类之间的继承关系 每个人都有一些属性，比如姓名，年龄，引入一个公共的超类，就可以把getName方法放在继承层次结构中的更高一层，使用abstract关键字来定义抽象类 public abstract class Person &#123; private String name; public Person (String name) &#123; this.name = name; &#125; public abstract String getDescription(); public String getName() &#123; return name; &#125; &#125; 抽象类不能够实例化，如下的表达式是错误的 new Person(); // ERROR 二、对象包装器与自动装箱所有的基本类型都有一个与之对应的类，这些类被称为包装器(wrapper)，分别是Integer, Long, Float, Double, Short, Byte, Character, Boolean。包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值，同时，包装器还是final，不能够派生它们的子类。 Tip为什么需要包装类？因为Java是一种面向对象程序设计语言，很多地方需要使用对象而不是基本类型。比如在ArrayList中，我们不能够写成ArrayList&lt;int&gt;，而要写成ArrayList&lt;Integer&gt;。 2. 自动拆箱与装箱自动装箱: 就是将基本数据类型自动转换成对应的包装类。自动拆箱：就是将包装类自动转换成对应的基本数据类型。 Integer n = 3; // 自动装箱 int m = n; // 自动拆箱 三、继承的设计技巧 将公共操作和字段放在超类中 使用继承实现is-a关系 除非所有继承的方法都有意义，否则不要使用继承 在覆盖方法时，不要改变预期的行为 使用多态，而不要使用类型信息 参考： Java工程师成神之路 《Java核心技术 卷I》","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"Java 面向对象概述","slug":"Java/Java面向对象概述","date":"2020-09-04T08:08:48.000Z","updated":"2020-09-04T08:08:48.000Z","comments":true,"path":"posts/e27767b2.html","link":"","permalink":"https://zhouzhuyan.com/posts/e27767b2.html","excerpt":"本文介绍了Java面向对象的相关内容，包括面向对象的思想和特点，类的使用以及静态变量和方法。","text":"对象与类概述一、面向对象程序设计概述结构化程序：算法+数据结构 = 程序 （即确定如何操作数据，再决定如何组织数据的结构） 面向对象程序设计(OOP)：将数据放在第一位，再考虑操作数据的算法 1. 类 类(class)是构造对象的模板或蓝图，就好像一个制作某件工艺品的模具，对象就是工艺品 由类构造(construct)对象的过程称为创建类的实例(instance) 封装(encapsulation)将数据和行为组合在一个包中，对对象的使用者隐藏具体的实现方式，也称为数据隐藏 对象中的数据称为实例字段(instance field)，操作数据的过程称为方法(method) 对象拥有的实例字段值的集合就是这个对象的当前状态(state) 程序只能通过对象的方法和对象数据进行交互，对象被赋予了“黑盒”的特征，提高了重用性和可靠性 可以通过扩展一个类来构建新的类，这使得用户自定义类更加容易。在Java中，所有类都来自于一个超类，即Object。 通过扩展一个类来建立一个新的类的过程就是继承(inheritance)，新类具有被扩展的类的全部属性和方法，可以自定义新的属性和方法。 2. 对象对象的3个特性： 行为(behavior)——可以对对象完成的操作（应用的方法） 状态(state)——描述当前状况的信息，状态的改变必须通过调用方法实现 标识(identity)——每个对象有唯一的标识来区分（如两个订单的编号肯定不相同） 3. 识别类编写程序从识别类开始，然后为各个类添加方法。 一个简单的方法是在分析问题的过程中寻找名词——类，寻找动词——方法 例如我们有商品，订单，账户这样的名词作为类，即Item，Order，Account 那么在账户这个类中，就可以有增加账户，修改账户等方法。 4. 类之间的关系类之间最常见的关系有： 依赖（”uses-a“） 聚合 （”has-a“） 继承（“is-a”) 4.1 依赖（dependence）如果一个类的方法使用或操纵另一个类的对象，我们就可以说一个类依赖于另一个类 比如Order对象访问Account对象查看信用状态，这就是一个使用(“uses-a”)的关系。 （尽可能减少相互依赖的类，做到低耦合） 4.2 聚合（aggregation）类A的对象包含（”has-a”）类B的对象 如一个Order对象就包含了一些Item对象 4.3 继承（inheritance）一个更特殊的类与一个更一般的类之间的关系 也就是前面提到的扩展，比如现在我们定义一个加急订单RushOrder类，那么它是一个（”is-a”)Order类 也就是有Order类继承而来。 下图展示了上述的三种关系。 二、使用预定义类我们通过可以Java中的预定于类来了解如何构造对象，以及如何使用类的方法。如下的例子： import java.util.Date; public class DateTest &#123; public static void main(String[] args) &#123; Date birthday = new Date(); System.out.println(birthday.toString()); &#125; &#125; 在Java中，要使用构造器(constructor)来构造新的实例，比如上面的代码中new Date()就构造了一个新的对象，这个对象被初始化为当前的日期和时间。 Tip需要注意的是，单独的定义Date birthday中的birthday并不是对象，对它进行操作编译器会报错。一定要初始化变量birthday。对象变量本身并不包含一个对象，而是引用一个对象，new操作符的返回值也是一个引用。 三、自定义类1. 对象与对象变量要想使用对象，就需要先构造对象，并指定其初始状态。在Java中，使用构造器（构造函数）来构造。 比如某公司有一个职员管理系统，其中有一个关于职员信息的类Employee 那么我们可以通过下面这个表达式构造一个新对象 Employee employee = new Employee(1, &quot;Allen&quot;, 10000); 其中employee是一个对象变量，我们用new Employee(int id, String name, int salary)构造了一个新对象，初始化该对象变量，要注意的是对象变量并没有包含一个对象，而是引用一个对象。 在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。 public class Employee &#123; private int id; private String name; private int salary; public Employee(int id, String name, int salary) &#123; this.id = id; this.name = name; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public int getSalary() &#123; return salary; &#125; public static void main(String[] args) &#123; Employee[] staff = new Employee[3]; staff[0] = new Employee(1, &quot;Allen&quot;, 10000); staff[1] = new Employee(2, &quot;Ben&quot;, 12000); staff[2] = new Employee(3, &quot;David&quot;, 15000); for (Employee e : staff) &#123; System.out.println(&quot;id=&quot; + e.getId() + &quot;,name=&quot; + e.getName() + &quot;,salary=&quot; + e.getSalary()); &#125; &#125; &#125; /** Output: id=1,name=Allen,salary=10000 id=2,name=Ben,salary=12000 id=3,name=David,salary=15000 */ 2. 构造函数构造函数，与类同名，将实例初始化为指定的初始状态 public Employee(int id, String name, int salary) &#123; this.id = id; this.name = name; this.salary = salary; &#125; Tip 构造函数根据参数的不同可以有多个， 构造函数没有返回值。 4. 封装的优点如下是一个访问器方法，又称为字段访问器 public int getId() &#123; return id; &#125; Tip为什么不直接将这些变量设为public公共访问呢？因为这样的话这些变量就可以轻易的被外界修改，受到破坏比如这里的职员id应该是只读的，不能够设置为public被外界随意更改。 4. final定义为final的实例字段必须在构造对象时初始化，否则编辑器会报错，顾名思义，final表示最终的，在初始化之后不能够再修改这个值。 private final String name = &quot;John&quot;; Tipfinal修饰符对于基本类型和不可变类，如String类适用，但是对于可变的类，如StringBuilder就会出现问题，因为它仅仅保证了引用不会指向另外一个对象，但是这个对象是可以更改的。 四、静态字段和静态方法1. 静态字段回到我们之前的Employee类中，如果我们需要一个变量来记录公司有多少雇员，就可以使用static修饰符，定义一个静态变量 private static int count; 静态变量是属于类的变量，而不属于单个对象，对于Employee类的所有实例，共享一个count。而对非静态的变量，每个对象都有一个自己的副本 2. 静态常量Math类中定义了一个静态常量PI public class Math &#123; public static final double PI = 3.1415926535897932846; &#125; 我们可以通过Math.PI来直接访问它，如果没有static，那么就需要创建Math类的对象来访问它，效率比较低。 3. 静态方法如果我们想要知道公司的雇员人数，就可以使用静态方法 public static int getCount() &#123; // 返回静态变量 return count; &#125; 使用静态方法的两种情况： 方法不需要访问对象状态 方法只需要访问类的静态字段（比如上面的例子）","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"Hexo部署到云服务器","slug":"Hexo/Hexo部署到云服务器","date":"2020-09-03T14:57:59.000Z","updated":"2020-09-03T14:57:59.000Z","comments":true,"path":"posts/e80e623c.html","link":"","permalink":"https://zhouzhuyan.com/posts/e80e623c.html","excerpt":"","text":"0. 准备工作博客的搭建和域名的绑定可以参考我以前的博客。使用Github pages + Hexo搭建个人博客Hexo个人博客绑定域名 由于博客是基于Github pages搭建的，所以在国内的访问速度比较慢，可以部署到云服务器上加快访问的速度，我使用的是腾讯云学生机。注意在国内使用云服务器部署网站需要对网站进行备案，详细步骤可以参考腾讯的官方文档。在备案完成后，就可以进行网站的部署了。 1. 配置gitTip我的服务器型号是CentOS 7.5 1.1 安装gityum install -y git 看到complete字样说明安装完成了，可以通过如下命令验证 git --version 出现版本则说明安装成功。 1.2 创建git账户adduser git passwd git 注意一定要有第二步passwd git，这是给git账户设置密码，否则账户不会使用。 1.3 设置免密登录git使用su命令切换至git用户，并进入用户git的根目录 su git cd 创建~/.ssh文件夹和~/.ssh/authorized_keys文件 mkdir ~/.ssh touch ~/.ssh/authorized_keys 将本地的id_rsa.pub文件中的公匙复制到authorized_keys文件中，在mac中，该文件的地址是/Users/你的用户名/.ssh/id_rsa.pub，可以在终端中使用如下命令打开.ssh文件夹，然后使用vs code打开该文件 open /Users/galahad/.ssh 复制其中的内容，然后打开authorized_keys文件 vi ~/.ssh/authorized_keys 按i进入插入模式，复制内容按esc键进入命令模式，输入:wq保存并退出最后对文件赋予对应的权限 chmod 600 /home/git/.ssh/authorized_keys chmod 700 /home/git/.ssh 这样就可以使得本地终端可以免密登录git用户，可以在本地终端使用ssh远程连接测试 ssh git@你的IP 如果仍需输入密码，那说明配置有问题，可以重新按照1.3的步骤再配置一遍，当然，1.3的部分不是必须的，这只是为了在本地提交文件到服务器的时候不用输入密码，省点儿力气。 1.4 配置git仓库在git用户的根目录下创建hexo存储的目录 mkdir -p projects/blog 再创建一个git仓库，并初始化一个仓库 mkdir repos cd repos git init --bare blog.git 之后，在blog.git文件夹下会产生一个hooks文件夹，在其中创建一个文件post-receive，在其中配置一个钩子 cd blog.git/hooks vi post-receive 将如下内容复制到其中 #!/bin/sh git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f 保存退出之后，赋予文件可执行权限 chmod +x post-receive 然后输入exit回到root用户下，输入如下命令 chown -R git:git /home/git/repos/blog.git 配置完仓库后，可以在本地使用git clone命令测试是否能够成功克隆仓库 git clone git@server_ip:/home/git/repos/blog.git 2 配置Nginx2.1 安装Nginxyum install -y nginx 启动nginx nginx 2.2 配置文件先暂停服务 nginx -s stop 进入nginx目录，编辑配置文件 cd /etc/nginx vi nginx.conf 注意要修改两个地方，一个是将user nginx改为user root第二个就是在server的位置，添加root解析路径/home/git/projects/blog/，如果你已经有了域名，那么在server_name后面添加上你的域名。其它保持不变。 server &#123; listen 80 default_server; listen [::]:80 default_server; server_name zhouzhuyan.com www.zhouzhuyan.com; root /home/git/projects/blog/; index index.html index.htm; &#125; 保存退出重新启动nginx systemctl restart nginx 2.3 检查检查nginx状态 systemctl status nginx 如果看到绿色的active就表示配置成功了。我在这里遇到了一个问题，它的状态显示红色的failed,，错误是98: Address already in use，80端口已经被占用，这个时候可以用如下命令检查一下是谁占用了80端口 netstat -ntpl 如果就是nginx的话，应该是由于之前的配置文件中，listen 80 default_server;监听ipv4的80端口，而listen [::]:80 default_server;监听的是ipv6的80端口，于是就重复占用了。可以在配置文件中这样更改 listen [::]:80 ipv6only=on default_server; 然后重启nginx应该就可以了。 3. Hexo本地配置hexo的站点配置文件_config.yml deploy: type: git repo: git@你的IP:/home/git/repos/blog.git branch: master 然后进行部署 hexo clean hexo g -d 4. 启用https由于nginx默认使用的是http，所以在网站访问的时候，会显示不安全，可以通过配置来开启https 4.1 申请SSL证书阿里云和腾讯云都提供免费的SSL证书下载，因为我的域名是在腾讯云云购买的，所以我就从腾讯云上下载了SSL证书 4.2 传输文件到服务器从腾讯云上下载证书到本地，会得到一个自己域名命名的文件夹，里面有Apache，Nginx，Tomcat，IIS的证书，由于我们使用的是nginx服务，所以只需要Nginx文件夹内的xxx.crt和xxx.key两个文件。在服务端创建文件夹存储证书 mkdir /home/git/SSL 我们可以使用scp命令将本地的文件传输到服务器 scp -r xxx/Nginx git@你的IP /home/git/SSL 4.3 配置nginx然后再次编辑nginx.conf文件，这里可以参考官方文档Nginx 服务器证书安装，文档写的很清晰，按照其中的步骤配置一下就可以完成了。之后我们就可以通过https访问网页，在网址旁边会出现一把锁。 参考：[1]HJX.将Hexo部署到阿里云轻量级服务器(保姆级教程)[EB/OL].https://hjxlog.com/posts/20191130a1.html,2019-11-30.[2]Dreamy.TZK.将Hexo部署到云服务器[EB/OL].https://cloud.tencent.com/developer/article/1632020,2020-05-25.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"策略模式","slug":"设计模式/策略模式","date":"2020-09-02T04:29:06.000Z","updated":"2020-09-02T04:29:06.000Z","comments":true,"path":"posts/72e3b671.html","link":"","permalink":"https://zhouzhuyan.com/posts/72e3b671.html","excerpt":"","text":"策略模式 问题：假设有一个模拟鸭子的游戏，游戏中拥有各种鸭子，我们设计了一个鸭子的超类，并且让各种鸭子，比如红头鸭，橡皮鸭等，继承它。现在，我们需要更新这个游戏，使得鸭子可以飞起来，该怎么做？ 使用继承？如果依然使用继承，在超类中添加一个fly()方法，会出现不适合该行为的子类也具有该行为的问题，比如橡皮鸭就不会飞，但继承的做法使得它也可以飞起来。 如果选择覆盖fly()方法，那么在后续的更新中，我们需要不断地检查可能需要覆盖的fly()方法。所以使用继承来提供行为，会造成代码在多个子类最终重复，复用性差，难以知道鸭子的全部行为，运行时的行为不容易改变等问题。 使用接口？如果抽象出一个Flyable接口，只有会飞的鸭子才实现这个接口呢？设想一下，如果我们有上百种会飞的鸭子，那么就会造成大量的代码重复，每个子类中都要实现一次fly()方法，而且代码无法复用，如果我们需要修改这个方法，想象一下，这简直就是一场灾难。 策略模式实现软件开发过程中总是伴随着变更。设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码放在一起。也就是说我们把会变化的部分取出并封装起来，以便以后的改动和扩充。 分离变化与不变的部分在鸭子类中，我们可以发现fly()和quack()两个方法经常需要修改，那么我们就可以建立两组远离Duck类的类，一个与fly相关，一个与quack相关，每一组类实现各自的动作，比如让一个类实现“呱呱叫”，一个类实现“吱吱叫”，还有一个类实现“安静” 设计行为设计原则 针对接口编程，而不是针对实现编程用接口代表每个行为，鸭子类不会实现Flying的接口，而是制造一组专门的类来实现FlyBahavior public interface FlyBehavior &#123; public void fly(); &#125; 实现行为现在有一个FlyBehavior接口，还有对应的类，负责实现具体的行为。 public class FlyWithWings implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(&quot;I&#x27;m flying.&quot;); &#125; &#125; public class FlyNoWay implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(&quot;I can&#x27;t fly&quot;); &#125; &#125; 整合行为鸭子将飞行的动作委托给别人处理，而不是在鸭子类内部定义飞行方法。在鸭子类中加入实例变量flyBahavior，声明为接口类型。 public abstract class Duck &#123; FlyBehavior flyBehavior; public abstract void display(); public void performFly() &#123; flyBehavior.fly(); &#125; &#125; 每个鸭子对象都会动态的设置这些变量以在运行时引用正确的类型。 public class MallardDuck extends Duck &#123; public MallardDuck() &#123; flyBehavior = new FlyWithWings(); // 使用FlyWithWings作为FlyBehavior类型 &#125; @Override public void display() &#123; System.out.println(&quot;I&#x27;m a real Mallard duck.&quot;); &#125; &#125; 测试 public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck mallard = new MallardDuck(); mallard.performFly(); &#125; &#125; // Output: I&#x27;m flying. 动态设定行为如果想要在运行时改变鸭子的行为，只需要调用鸭子的setter方法就可以了。我们在鸭子类中增加设定方法 public void setFlyBehavior(FlyBehavior fb) &#123; flyBehavior = fb; &#125; 创造一个新的类模型鸭 public class ModelDuck extends Duck &#123; public ModelDuck() &#123; flyBehavior = new FlyNoWay(); &#125; @Override public void display() &#123; System.out.println(&quot;I&#x27;m a model duck.&quot;); &#125; &#125; 建立一个新的FlyBehavior类型 public class FlyRocketPowered implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(&quot;I&#x27;m flying with a rocket.&quot;); &#125; &#125; 测试调用setter方法，改变了模型鸭的飞行行为 public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck model = new ModelDuck(); model.performFly();; model.setFlyBehavior(new FlyRocketPowered()); model.performFly(); &#125; &#125; /* Output: I can&#x27;t fly; I&#x27;m flying with a rocket. */ 每一个鸭子都有一个(HAS-A)FlyBahavior，将飞行委托给它处理。设计原则 多用组合，少用继承使用组合建立系统具有很大的弹性，可以将算法族封装成类，还可以在运行时动态地改变行为。 策略模式小结意图定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。使得算法可以独立于它的客户变化。 适用 许多相关的类仅仅只是行为有差别，比如鸭子类中的飞行 需要使用一个算法的不同变体 算法使用客户不应该知道的数据 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现（switch或if） 结构与参与者 Strategy (策略)定义所有支持的算法的公共接口，Context使用这个接口来调用ConcreteStrategy定义的算法，比如FlyBehavior就是一个策略ConcreteStrategy(具体策略)以Strategy接口实现某具体的算法，比如FlyWithWings,FlyNoWay等Context (上下文) 用一个ConcreteStrategy对象来配置 维护一个对Strategy对象的引用 可定义一个接口让Strategy来访问它的数据比如Duck类 效果优点 相关算法系列 Strategy类层次为Context定义了一系列可供复用的算法或行为 替代继承的方法 使用继承可以直接生成一个Context的子类，给它不同的行为，但这样会使得Context难以理解，维护和扩展，不能动态改变算法。而将算法封装在独立的Strategy类中使得我们可以独立于Context改变它，易于理解，修改和扩展。 消除可一些条件语句 含有许多条件语句的代码通常需要使用策略模式 实现的选择 策略模式可以提供相同行为的不同实现供客户选择 缺点 客户必须了解不同的策略 需要向客户暴露具体问题，所以只有当不同行为的变体与客户有关时，才使用策略模式 Strategy和Context之间的通信开销 增加了对象的数目","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhouzhuyan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"策略模式","slug":"策略模式","permalink":"https://zhouzhuyan.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"概率论的基本概念","slug":"数据科学/概率论的基本概念","date":"2020-04-09T15:23:48.000Z","updated":"2020-04-09T15:23:48.000Z","comments":true,"path":"posts/36736857.html","link":"","permalink":"https://zhouzhuyan.com/posts/36736857.html","excerpt":"本文介绍了概率论的基本概念，包括概率的定义，概率的计算，同时还有随机测试的简单介绍。 重点 概率的定义 条件概率 乘法公式 全概率公式 贝叶斯公式","text":"本文介绍了概率论的基本概念，包括概率的定义，概率的计算，同时还有随机测试的简单介绍。 重点 概率的定义 条件概率 乘法公式 全概率公式 贝叶斯公式 一、概率的定义当我们还不能用数学符号描述一件事情，那么说明我们还没有想清楚这件事。 所以，我们需要建立元素到数据的映射 1. 基本概念1.1 随机实验 可以在相同的条件下重复进行 每次实验结果不止一个，并且事先明确实验的所有可能结果 进行一次实验前不能够确定那一个结果会出现 例：抛一枚硬币，观察正面H与反面T出现的情况 1.2 样本空间随机试验$E$的所有可能结果组成的集合称为$E$的样本空间，记为$\\Omega$ 样本空间中的每个元素，即$E$的每个结果，称为样本点，记为$e$ 1.3 随机事件样本空间$\\Omega$的任意子集$A$称为随机事件 观察到样本点$e$，若$e\\in A$，则称这一事件发生。 基本事件：由一个样本点组成的单点集 复合事件：由两个或两个以上样本点组成的集合 必然事件：全集$\\Omega$ 不可能事件：空集$\\emptyset$ 2. 事件的集合运算 包含：$A\\subset B$，事件B包含事件A，则事件A发生必然导致事件B发生 相等：$A=B$，即$A\\subset B$且$B\\subset A$ 和：$A\\bigcup B$，即A和B至少有一个发生 差：$A-B$，即事件A发生且事件B不发生 积：$A\\bigcup B$，记作$AB$，即事件A和事件B都发生 互不相容：$AB = \\emptyset$，即A和B不能同时发生 互逆：$A\\bigcup B=\\Omega$ 且$AB = \\emptyset$，A和B互逆，通常B记为$\\overline{A}$ 2.1 复杂事件的集合运算 A发生而B和C都不发生：$A\\overline{B} \\overline{C}=A-B-C=A-(B\\bigcup C)$ A与B都发生而C不发生：$AB\\overline{C}=AB-C=AB-ABC$ 三个事件都发生：$ABC$ 三个事件恰好有一个发生：$A\\overline{B}\\overline{C}+\\overline{A}B\\overline{C}+\\overline{A}\\overline{B}C$ 三个事件至少发生一个：$A\\bigcup B\\bigcup C$ 2.2 常用定律 交换律 结合律 分配率：$A\\, \\bigcup \\,(B\\bigcap C)=(A\\bigcup B)\\bigcap (A\\bigcup C)$ $A\\, \\bigcap \\,(B\\bigcup C)=(A\\bigcap B)\\,\\bigcup \\,(A\\bigcap C)$ 德摩根定律：$\\overline{A\\bigcup B}=\\overline{A}\\bigcap\\overline{B}$ $\\overline{A\\bigcap B}=\\overline{A}\\bigcup\\overline{B}$ 3. 频率描述了事件发生的频繁程度 定义 重复观察n次事件A发生的次数$n_A$称为A的频数 比值$\\frac{n_A}{n}$称为事件A发生的频率，并记为$f_n(A)$ 性质 $0\\,\\leq\\, f_n(A)\\, \\leq\\, 1$ $f_n(\\Omega)=1$ 若$A_1,\\cdots,A_k$两两互不相容，则 f_n(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=f_n(A_1)+\\cdots+f_n(A_k) 收敛性 当n足够大，$f_n(A)$收敛于某个常数，这个常数就是概率（证明见后续） 我们应该都听说过德摩根抛硬币的故事，对一个事件进行大量的实验可以得到频率，但是我们不可能对所有事件都做类似的事情，所以就有了概率 4. 概率表征事件发生的可能性大小 定义 $\\Omega$为样本空间，对于每一事件A赋予一实数$P(A)$，若P(A)满足下列条件则被称为概率： 非负性：$0\\leq P(A)\\leq 1$ 规范性：$P(\\Omega)=1$ 可列可加性：$A_1,\\cdots,A_n$互不相容，则$P(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=P(A_1)+\\cdots+P(A_k)$ 性质 $P(\\emptyset)=0$ $P(\\overline{A})=1-P(A)$ 若$A\\subset B$，则有$P(A)\\leq P(B),\\quad P(B-A)=P(B)-P(A)$ 对于任意两个事件A和B，$P(A\\bigcup B)=P(A)+P(B)-P(A+B)$ 4.1 古典概型(等可能概型)定义 若$\\Omega$是**有限样本空间，其样本点为$e_1,\\cdots e_n$，在有限样本空间中引进概率。 1/n称为事件${e_i}$的概率，记为$P({e_i})$ P(\\{e_1\\})+\\cdots +P(\\{e_n\\})=P(\\Omega)=1从定义中不难发现古典概型的两个特点： 样本空间包含有限个元素 试验中每个基本事件发生的可能性相同 注：基本事件是两两不相容的 若事件A包含k个基本事件，则有 P(A)=\\sum_{i=1}^kP(\\{e_{i_k}\\})=\\frac{k}{n}4.2 几何概型数据从有限集合推广到无限集合 例：约会问题 两人约定7点到8点在某地会面，先到者等候另一人20分钟，过时就离去，试求这两人会面的概率。 解：以$x,y$分别表示两人到达的时刻，则会面的充要条件为$|x-y|\\leq20$，这就是一个几何概率的问题，可能的结果全体是边长60的正方形里面的点，结果为 P(A)=\\frac{60^2-40^2}{60^2}从上面的例子不难看出，样本空间从原来的有限的个数，变成了无限的点。 如果要在半径为1的圆内随机地取一条弦，问弦长超过$\\sqrt{3}$的概率是多少？ 3种思路有3种不同的答案 在数据映射中，我们需要遵循物理世界到数据集合的某种结构保持 二、概率的计算1. 条件概率事件A发生的条件下事件B发生的概率 1.1 定义设A，B是两事件，且$P(A)&gt;0$，称 P(B|A)=\\frac{P(AB)}{P(A)}为在事件A发生的条件下事件B发生的条件概率 条件概率符合概率定义中的3个条件 非负性 规范性 可列可加性：$B_1,\\cdots,B_n$两两互不相容 P(\\bigcup_{i=1}^\\infty B_i\\,\\mid\\,A)=\\sum_{i=1}^\\infty P(B_i\\mid A)同时也可以使用概率的性质 P(B_1\\bigcup B_2)=P(B_1\\mid A)+P(B_2\\mid A)-P(B_1B_2\\mid A)注意这里是对任意事件$B_1,B_2$，两者不一定互不相容，如果互不相容，那么$P(B_1B_2)=\\emptyset$，与可列可加性不矛盾。 1.2 乘法公式P(AB)=P(A)P(B|A)推广：一般地，我们有： P(A_1A_2\\cdots A_n)=P(A_1)P(A_2\\mid A_1)\\cdots P(A_n\\mid A_1A_2\\cdots A_{n-1})大多数应用中，我们会直接获取条件概率，通过它进行计算 1.3 完备事件组设$B_1,\\cdots,B_n$是样本空间$\\Omega$的一个事件组，若满足 $B_i\\bigcap B_j=\\emptyset$ ，对于任意$i\\neq j$ $\\bigcup_iB_i=\\Omega$ 则$B_1,\\cdots,B_n$称为一个完备事件组 1.4 全概率公式设$B_1,\\cdots,B_n$是样本空间$\\Omega$的一个完备事件组，且$P(B_i)&gt;0(i=1,2,\\cdots,n)$，则对于任一随机事件A，有 P(A)=\\sum_{i=1}^nP(B_i)P(A\\mid B_i)当$P(A)$不易求得时，利用此公式 1.5 贝叶斯公式设实验E的样本空间为$\\Omega$，$A$为$\\Omega$的事件，$B_1,\\cdots,B_n$为$S$的一个划分，且$P(A)&gt;0,P(B_i)&gt;0$，则 P(B_i\\mid A)=\\frac{P(A\\mid B_i)P(B_i)}{\\sum_{j=1}^nP(A\\mid B_j)P(B_j)},i=1,2,\\cdots,n如：设$A,B$为两事件，$P(B)&gt;0$，则 P(A\\mid B)=\\frac{P(B\\mid A)\\times P(A)}{P(B)}贝叶斯定理往往与全概率公式同时使用。全概率公式用于”由因求果“的问题，而贝叶斯定理用于”执果寻因“问题。 常用：令$n=2$，那么全概率公式和贝叶斯公式分别为： P(A)=P(A\\mid B)P(B)+P(A\\mid \\overline{B})P(\\overline{B})P(B\\mid A)=\\frac{P(AB)}{P(A)}=\\frac{P(A\\mid B)P(B)}{P(A\\mid B)P(B)+P(A\\mid \\overline{B})P(\\overline{B})}1.6 独立性定义：设$A,B$是两事件，如果满足等式 P(AB)=P(A)P(B)则称事件$A$和事件$B$相互独立 定理：设$A,B$是两事件，且$P(A)&gt;0$，若$A,B$相互独立，则$P(B\\mid A)=P(B)$，反之亦然 定理：若事件$A,B$相互独立，则下列各对事件也相互独立，$A\\&amp;\\overline{B},B\\&amp;\\overline{A},\\overline{A}\\&amp;\\overline{B}$ 定义：设$A,B,C$是三个事件，如果满足等式 P(AB)=P(A)P(B),\\\\ P(BC)=P(B)P(C)\\\\P(AC)=P(A)P(C)\\\\P(ABC)=P(A)P(B)P(C)则称事件$A,B,C$相互独立 三、随机测试示例实际应用中使用概率论 1. 随机测试初步假设有一个计算多项式乘法的程序。 程序可能采用左右两边的某一方式实现： (x+1)(x-2)(x+3)(x-4)(x+5)(x-6)=x^6-7x^3+25思考： 如何验证左右两边的多项式相等 假设有一个超大规模的多项式呢？ F(X)?\\equiv G(x)1.1 规范化两个多项式相等当且仅当他们的规范式中所有的对应系数相等， 那么把$F(x)$变换为规范式，有$O(d^2)$的复杂度 1.2 随机测试-初步设$F(X),G(x)$的最高阶为的$d$，随机算法首先是从${1,\\cdots,100d}$中均匀随机（等可能）地选择一个整数$r$，然后计算两个式子的值，进行判断。有$O(d)$的复杂度，大大提高了速度。 当然，这种算法可能会给出错误的答案。 $F(x)\\neq G(x), F(r)=G(r)$，算法检测结果错误 错误的概率是多少？可以接受吗？ 当$r$是方程$F(x)-G(x)=0$的根时，必然会出现错误结果。 $F(x)-G(x)$的次数不高于$d$，由代数的基本定理可知，$F(x)-G(x)=0$不可能多于$d$个根。 那么在${1,\\cdots,100d}$中，给出错误答案的概率不会高于$\\frac{1}{100}$ 2. 随机测试改进如何改进算法正确率？ 很容易想到两个方向，扩大检测范围，重复多次检测 2.1 扩大范围在更大的范围进行取值，比如在${1,\\cdots,1000d}$中进行检测，那么错误答案概率不会超过$\\frac{1}{1000}$ 2.2 重复检测重复多次进行随机检测 有放回抽样 $k$次有放回抽样错误率为 P(E_1\\,\\bigcap\\cdots\\bigcap\\,E_k)=\\prod_{i=1}^kP(E_i)\\leq(\\frac{1}{100})^k可以看到，错误率指数级降低 无放回抽样 总结： 无放回比有放回准确率高 有放回实现比无放回简单 当$d+1$次无放回抽样后，能够确保准确性，但是算法复杂度提升到$O(d^2)$ 四、总结1. 概率的定义$\\Omega$为样本空间，对于每一事件A赋予一实数$P(A)$，若P(A)满足下列条件则被称为概率： 非负性：$0\\leq P(A)\\leq 1$ 规范性：$P(\\Omega)=1$ 可列可加性：$A_1,\\cdots,A_n$互不相容，则$P(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=P(A_1)+\\cdots+P(A_k)$ 2. 条件概率P(B|A)=\\frac{P(AB)}{P(A)}3. 乘法公式P(A_1A_2\\cdots A_n)=P(A_1)P(A_2\\mid A_1)\\cdots P(A_n\\mid A_1A_2\\cdots A_{n-1})4. 全概率公式P(A)=P(A\\mid B_1)P(B_1)+\\cdots+P(A\\mid B_n)P(B_n)5. 贝叶斯公式P(A\\mid B)=\\frac{P(B\\mid A)P(A)}{P(B)}参考： 中国大学MOOC-南京大学-数据科学基础 《概率论与数理统计》浙江大学第四版","categories":[{"name":"数据科学","slug":"数据科学","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://zhouzhuyan.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"Hexo个人博客绑定域名和配置SSL证书","slug":"Hexo/Hexo个人博客绑定域名和配置SSL证书","date":"2020-04-09T13:29:25.000Z","updated":"2020-04-09T13:29:25.000Z","comments":true,"path":"posts/2cd2c226.html","link":"","permalink":"https://zhouzhuyan.com/posts/2cd2c226.html","excerpt":"Hexo 个人博客绑定域名和配置SSL证书在完成个人博客的搭建以后，我们可以通过一个https://xxx.github.io形式的链接在访问我们的个人博客网站，那么如果想拥有一个个性的域名，该如何操作呢？","text":"Hexo 个人博客绑定域名和配置SSL证书在完成个人博客的搭建以后，我们可以通过一个https://xxx.github.io形式的链接在访问我们的个人博客网站，那么如果想拥有一个个性的域名，该如何操作呢？ 一、 绑定域名1. 购买域名可以在阿里云或者腾讯云上购买，不同形式的有不同的价格，根据自己的情况购买即可。我在腾讯云上购买了我现在的域名zhouzhuyan.com 注意：如果不使用国内的服务器的话不用备案，只要完成实名认证就可以了。 现在实名认证，审核都很快，虽然说一个工作日审批，但是我的话几分钟成功了。在域名的状态显示正常以后，就可以使用了。 2. 域名解析这个时候，网站时访问不了的，因为还需要去解析你的域名，将你的域名指向你的个人网站。 到腾讯云控制台的域名管理界面，找到你的域名，点击解析，选择添加记录 主机记录 记录类型 线路类型 记录值 www CNAME 默认 你的Github项目仓库名 @ CNAME 默认 你的Github项目仓库名 两个主机记录是为了让你的网站在有www和没有的情况下都可以访问，仓库名可以在Github仓库的Settings里面找到。解析需要10分钟，耐心等待。 3. 在项目中更换到Github中找到自己的网站所在的仓库，进入Settings界面 在Custom domain里面填写自己的域名，选择save，这样就会出现上图的形式，显示Your site is published at https://你的域名，勾选Enforce HTTPS 4. 创建CNAME文件进入你的Hexo本地文件所在的根目录，找到\\source目录，在里面创建一个文件CNAME，注意它是没有类型的，不是.txt。 在里面加入你的域名，注意不要在前面加入https www这样的前缀，就是你的域名。 然后hexo d -g部署你的网站，等待一段时间后，就可以通过你的个性域名访问网站了。 二、 SSL安全证书注册好域名后，用google访问时，可能会出现您访问的不是安全链接的提示，或者能够正常访问，但是域名旁边显示的是一个感叹号，表示不安全，这是因为我们还没有申请安全证书，在申请了证书之后，域名旁边显示的就是一把锁，表示安全。 腾讯云和阿里云都提供免费的SSL证书下载，具体安装也有相关的文档，按照步骤操作就行。 腾讯云Nginx服务器证书安装 Mac下nginx的使用 在证书安装好了以后，可以看到域名解析里面多出了一条TXT类型的解析。 在Chrome浏览器中，打开网站后如果仍然显示不安全，即没有出现锁的图标，右击选择检查元素，进入开发者模式，看Security里面有什么问题。 踩坑：我发现我用阿里云图床的图片引用的是http头，把它改为https，锁就出现了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"C++字符串,向量和数组","slug":"C++/字符串-向量和数组","date":"2020-04-03T14:03:24.000Z","updated":"2020-04-03T14:03:24.000Z","comments":true,"path":"posts/869e4b19.html","link":"","permalink":"https://zhouzhuyan.com/posts/869e4b19.html","excerpt":"二、字符串，向量和数组作用域操作符:: 含义：编译器应从操作符左侧的作用域中寻找右边那个名字 比如std::cin是要使用命名空间std中的cin 这样做是为了避免某些名字被重复使用 使用using声明可以更加简便的使用命名空间中的成员。","text":"二、字符串，向量和数组作用域操作符:: 含义：编译器应从操作符左侧的作用域中寻找右边那个名字 比如std::cin是要使用命名空间std中的cin 这样做是为了避免某些名字被重复使用 使用using声明可以更加简便的使用命名空间中的成员。 1. String类型表示可变长的字符串 1.1 定义和初始化 使用需要头文件和命名空间 #include&lt;string&gt; using std::string; 初始化 string s1; // 空字符串 string s2 = s1; // s2是s1的副本 string s3 = &quot;abc&quot;; string s4(10, &#x27;c&#x27;); // 十个c 1.2 string对象上的操作 使用getline读取一整行 string line; getline(cin, line); 当读取到换行符时结束，并将读到的内容存入string中，但是不存换行符 empty和size操作 str.empty()根据字符串是否为空返回一个布尔值 str.size()返回字符串长度 使用visual studio编程的时候，碰到过一个warning，将无符号数赋值给了有符号数。 这是由于size函数的返回值类型引起的，它是一个string::size_type类型的值，是无符号类型的， 可以用auto来推断变量的值 auto len = str.size(); 比较，赋值，相加 string s1 = &quot;abc&quot;; string s2 = &quot;xcvd&quot;; // s1 &lt; s2 比较第一个不同的字符 string s3 = s1; // 赋值 string s4 = s1 + s2; // abcxcvd 处理string中的字符 #include&lt;cctype&gt; isalnum(c); isalpha(c); islower(c); isupper(c); ispunct(c); // 是标点符号为真 2. Vector类型可变长数组，类似于Java中的ArrayList 2.1 初始化vector&lt;T&gt; v; vector&lt;T&gt; v1 = &#123;a, b, c&#125;; // 注意是花括号 vector&lt;T&gt; v2&#123;a, b&#125;; // 花括号，两个元素 vector&lt;int&gt; v3(10, 1); // 圆括号 10个元素，每个初始化为1 2.2 操作vector&lt;int&gt; v; v.push_back(1); // 添加1 v.pop_back(); // 去掉最后一个数据 v.empty(); v.size(); v[n]; // 注意下标只能访问，但是不能够添加元素 3. 迭代器访问元素的作用 string s = &quot;abcde&quot;; if (s.begin() != s.end()) &#123; // 确保s非空 &#125; 4. 数组4.1 指针和数组int ia[] = &#123;1, 2, 3, 4, 5&#125;; auto p(ia); // 整型指针，指向ia的第一个元素 p++; // 指向第一个元素","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]},{"title":"Hexo-Permalink简化","slug":"Hexo/Hexo-Permalink简化","date":"2020-04-03T12:59:43.000Z","updated":"2020-04-03T12:59:43.000Z","comments":true,"path":"posts/838443af.html","link":"","permalink":"https://zhouzhuyan.com/posts/838443af.html","excerpt":"Permalink简化在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章 阮一峰 关于url编码 有两种方法优化。","text":"Permalink简化在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章 阮一峰 关于url编码 有两种方法优化。 方法一：自定义首先，在scaffolds的post.md中，加入urlname元素。 title: &#123;&#123; title &#125;&#125; urlname: date: &#123;&#123; date &#125;&#125; tags: categories: 然后，在配置文件_config.yml中，将永久链接permalink的形式改为 permalink: :category/:urlname/ 也就是类别加上自定义的url链接。 每次写文章时，可以自己设计该页的url，使得它变得简单，同时也利于区分。 但是，这种修改方法的链接会随着文件目录的改变而改变， 比如一篇文章HelloWorld.md本来放在_posts目录下，链接为https://xxx/_posts/HelloWorld.md 之后归类到_posts/A目录下，那么链接变为https://xxx/_posts/A/HelloWorld.md 这样不太利于分享，所以推荐使用第二种方法。 方法二：插件使用hexo-abbrlink这个插件 安装 npm install hexo-abbrlink --save 设置 在_config.yml文件中修改永久链接格式 permalink: posts/:abbrlink.html abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex posts部分是可以更改的，也可以仿照方法一添加一个关键词便于识别 permalink: :keywords/:abbrlink.html 生成 在根目录创建Gruntfile.js文件，让插件到source/_posts/下读取所有的.md文件，把文件中的@@abbrlink替换成文件内容的hash值。 module.exports = function(grunt) &#123; grunt.initConfig(&#123; rewrite: &#123; abbrlink: &#123; src: &#x27;source/_posts/**/*.md&#x27;, editor: function(contents, filepath)&#123; const crypto = require(&#x27;crypto&#x27;); const hash = crypto.createHash(&#x27;sha256&#x27;); hash.update(contents); var hashValue = hash.digest(&#x27;hex&#x27;); return contents.replace(/@@abbrlink/g, hashValue.substring(0, 16)); &#125; &#125;, &#125;, &#125;); grunt.loadNpmTasks(&#x27;grunt-rewrite&#x27;); &#125;; 这种方法生成的链接是不带目录的，直接就是第二步设置中permalink的样式，所以也没有了被改变的风险。 参考 http://blog.jvaeyhcd.wang/posts/05c9df7e0c47bd64.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"C++变量和基本类型","slug":"C++/变量和基本类型","date":"2020-04-03T12:44:47.000Z","updated":"2020-04-03T12:44:47.000Z","comments":true,"path":"posts/96db5496.html","link":"","permalink":"https://zhouzhuyan.com/posts/96db5496.html","excerpt":"变量和基本类型1. 复合类型(Compound type)基于其它类型定义的类型 1.1 引用(Reference)引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。","text":"变量和基本类型1. 复合类型(Compound type)基于其它类型定义的类型 1.1 引用(Reference)引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。 (在这里，引用指的是左值引用) int ival = 1024; int &amp;refval = ival; // refval指向ival，是ival的另外一个名字 int &amp;refVal2; // 报错；引用必须被初始化 定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。（与初始化变量时不同的） 无法令引用重新绑定到另一个对象，所以引用必须被初始化 引用即别名，它不是对象，而是为了一个已经存在的对象起了另外一个名字 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的 refVal = 2; // 把2赋值给与refVal绑定的对象上，这里就是绑定到iVal上 int ii = refVal; 除了两种特殊情况，其它所有引用的类型都要与之绑定的对象严格匹配。不能够与字面值或表达式的计算结果绑定。 int &amp;refVal4 = 10; // 错误：引用对象初始值必须是一个对象 double dval = 3.14; int &amp;refVal5 = dval; // 错误：此处引用类型的初始值必须是int型对象 1.2 指针指针是指向另外一种类型的符合类型，与引用类似，指针实现了对其它对象的间接访问。 不同： 指针本身是一个对象 指针无需在定义时赋初值 int *ip1; // ip1是指向int对象的指针 获取对象的地址指针存放某个对象的地址。 int ival = 42; int *p = &amp;ival; // p是存放变量ival的地址，或者说p是指向引用的指针。 指针值指针的值（即地址）应该属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针 无效指针 利用指针访问对象如果指针指向了一个对象，可以使用解引用符（操作符*）来访问对象 int ival = 42; int *p = &amp;ival; cout &lt;&lt; *p // 输出42 *p = 0; cout &lt;&lt; *p // 输出0，为*p赋值实际上是为p所指的对象赋值 空指针int *p1 = nullptr; int *p2 = 0; int *p3 = NULL; // 需要头文件cstdlib void*指针用于存放任意对象的地址，不能直接操作void*指针所指的对象 指向指针的指针指向指针的引用指针是对象，所以存在对指针的引用 int i = 42; int *p; int *&amp;r = p; // r是一个对p的引用 r = &amp;i; // r引用了一个指针，因此给r赋值&amp;就是令p指向i *r = 0; // 将i的值改为0 2. const限定符值不能被改变，所以const对象必须被初始化 const int bufSize = 512; // 输入缓冲区大小 如果要在多个文件之间共享const，必须在变量定义前加extern关键字 2.1 对const的引用对常量的引用，不能够修改其绑定的对象 对const的引用可以使一个并非const的对象，但是不能通过其改变值 const int ci = 1024; const int &amp;r1 = ci; // 正确 r1 = 42; // 错误：r1是对常量的引用 int &amp;r2 = ci; // 错误：非常量引用指向一个常量对象 int i = 42； const int &amp;r1 = i; // 允许将const int&amp;绑定到一个普通的int上 r1 = 10; // 错误 3. 处理类型3.1 类型别名某种类型的同义词，使得复杂的类型名字变得简单，易于理解和使用。 typedef double wages; // wages是double的同义词 using SI = Sales_item; // SI是Sales_item的同义词 3.2 auto类型说明符让编译器分析表达式所属的类型，必须有初始值 auto item = val1 + val2; // 由val1和val2相加的结果推断item的类型 // auto一条声明语句只能有一个基础数据类型 auto i = 0, *p = &amp;i; // 正确 auto sz = 0, pi = 3.14; // 错误，sz和pi的类型不一致 4. 自定义数据结构将一组相关的数据元素组织起来然后使用他们的策略和方法 struct Sales_data &#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0; &#125; Sales_data accum;","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]},{"title":"使用Github pages+Hexo 搭建个人博客","slug":"Hexo/使用Github-pages-Hexo-搭建个人博客","date":"2020-04-01T17:56:42.000Z","updated":"2020-04-01T17:56:42.000Z","comments":true,"path":"posts/ae6c038e.html","link":"","permalink":"https://zhouzhuyan.com/posts/ae6c038e.html","excerpt":"Github pages + Hexo 搭建个人博客2019年11月19日，我决定开始写博客，首先要用github pages+hexo搭建一个个人博客，其中的过程我就记录在这里面。","text":"Github pages + Hexo 搭建个人博客2019年11月19日，我决定开始写博客，首先要用github pages+hexo搭建一个个人博客，其中的过程我就记录在这里面。 准备工作 注册一个 GitHub 账户 安装 Node.js下载链接 https://nodejs.org/en/download/ 下面这个是中文网，对于国内用户来说下载速度非常快。 http://nodejs.cn/download/ 推荐菜鸟教程关于node的安装教程以及简易的语法介绍https://www.runoob.com/nodejs/nodejs-install-setup.html 安装git markdown语法学习https://www.jianshu.com/p/191d1e21f7ed git语法学习推荐廖雪峰的git教程https://www.liaoxuefeng.com/wiki/896043488029600 安装在终端检查node和npm的版本情况 node -v npm -v 然后输入命令安装hexo npm install -g hexo-cli 我使用的是Mac电脑，在这一步出现了问题，终端显示如下 rollbackFailedOptional verb npm-session 然后我又等了一会儿，终端又报错了。 npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules npm ERR! code EACCES npm ERR! syscall access npm ERR! path /usr/local/lib/node_modules npm ERR! errno -13 npm ERR! Error: EACCES: permission denied, access &#x27;/usr/local/lib/node_modules&#x27; npm ERR! [Error: EACCES: permission denied, access &#x27;/usr/local/lib/node_modules&#x27;] &#123; npm ERR! stack: &quot;Error: EACCES: permission denied, access &#x27;/usr/local/lib/node_modules&#x27;&quot;, npm ERR! errno: -13, npm ERR! code: &#x27;EACCES&#x27;, npm ERR! syscall: &#x27;access&#x27;, npm ERR! path: &#x27;/usr/local/lib/node_modules&#x27; npm ERR! &#125; npm ERR! npm ERR! The operation was rejected by your operating system. npm ERR! It is likely you do not have the permissions to access this file as the current user npm ERR! npm ERR! If you believe this might be a permissions issue, please double-check the npm ERR! permissions of the file and its containing directories, or try running npm ERR! the command again as root/Administrator. 根据官方文档，如果在尝试安装 Hexo 的过程中出现 EACCES权限错误，要遵循由npmjs发布的指导修复该问题。强烈建议不要使用 root、sudo 等方法覆盖权限。根据要求，下载了nvm，并且在终端利用nvm下载了最新版本的node和更新了npm后，hexo下载成功了。（以下是下载和使用nvm的教程链接）https://github.com/nvm-sh/nvm. 建站输入以下命令hexo就会出现在指定的文件夹中 hexo init &lt;folder&gt; cd &lt;folder&gt; npm install 如果出现错误 -bash: syntax error near unexpected token `newline&#x27; 这是占位符的问题，将第一行命令的&lt;&gt;去除，再重新输入即可。 到此，建站的基本操作就完成了。 界面的设计等就可以由自己来操作了。放一个hexo的官方网站供大家参考。https://hexo.io/zh-cn/docs/configuration 创建Github远程仓库注意仓库名为github的用户名.github.io，勾选readme 创建之后，进入仓库，点击Settings按钮，然后翻到GitHub Pages的部分，点击网页链接，就能够看到一个简易的网页了。 部署hexo进入本地的hexo文件，找到 _config.yml，打开后翻到最后，修改成 deploy: type: git repo: gitHub: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git branch: master repo后面的内容要修改成自己github仓库的SSH密匙。 然后在终端中输入 npm install hexo-deployer-git --save 开始安装hexo-deploy-git，安装完成后，开始部署，在终端中输入 hexo deploy 部署完成。 测试这个时候，再次进入刚刚进入过的网页链接，就会看到一个船新版本的界面，也就是本地的hexo库已经部署到github上了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"Hexo写作","slug":"Hexo/Hexo写作","date":"2020-04-01T15:58:14.000Z","updated":"2020-04-01T15:58:14.000Z","comments":true,"path":"posts/c4064b2b.html","link":"","permalink":"https://zhouzhuyan.com/posts/c4064b2b.html","excerpt":"Hexo写作本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。","text":"Hexo写作本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。 1. Hexo基本命令hexo g = hexo generate #生成 hexo s = hexo server #启动本地预览 hexo d = hexo deploy #远程部署 hexo n &quot;文章标题&quot; = hexo new &quot;文章标题&quot; #新建一篇博文 2. 整体配置\\hexo\\_config.yml # Site title: # 网站名，标签页显示 subtitle: # 副标题，网站名下显示 description: # 网站描述，便于搜索 keywords: author: # 作者 language: zh-CN # 中文 timezone: Asia/Shanghai # 时区 3. 更换主题推荐使用melody hexo-theme-melody快速开始) 这个主题就是我现在网站使用的主题，它有完整的中文教程，功能齐全。按照教程配置就可以了。 4. 写作步骤 新建文章 hexo new &quot;title&quot; 写作 \\hexo\\source\\_post中找到title.md，使用typora打开 注意文章的tags格式是[] 在信息栏填写top_img信息可以自定义该页图片情况，如false表示不显示 文章中&lt;!-- more --&gt;之前的部分会显示在主页上，并出现Read more按钮，点击阅读更多内容 预览 hexo s hexo s --debug // 在命令行生成debug信息 同步到远程 hexo d -g 5. 问题 Template render error: (unknown path) 在命令行输入hexo -g后报错，原因在于文章内容中有{}时，如果它没有被代码块包括，解析会出现错误，所以需要写成 &#123;% raw %&#125; 本地预览与远程显示不一致 删除缓存 hexo clean 在网页上刷新","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"C++基本语法","slug":"C++/学习cpp","date":"2020-01-27T03:49:27.000Z","updated":"2020-01-27T03:49:27.000Z","comments":true,"path":"posts/6b599344.html","link":"","permalink":"https://zhouzhuyan.com/posts/6b599344.html","excerpt":"C++学习笔记本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。","text":"C++学习笔记本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。 一、 变量1. 用sizeof运算符求某一类型或变量占据的字节数#include&lt;iostream&gt; using namespace std; int main() &#123; int a; cout &lt;&lt; sizeof(a) &lt;&lt; endl; // sizeof运算符可以求变量占据的字节数 cout &lt;&lt; a &lt;&lt; endl; // 未初始化的变量，其值是不确定的 int b = 1; cout &lt;&lt; b &lt;&lt; endl; &#125; 2. 数据类型的自动转换1. 数int a = 11.34; // 11.34被自动转化为11后赋值给a int b = 30; double d = b; // d的值是30.0 2. 字符类型与整型int k = &#x27;a&#x27;; printf(&quot;%d&quot;, k); // 输出97，即a的ASCII码 int n = 98; char k = n; printf(&quot;%c&quot;, k); // 输出b 3. 输入和输出1. scanf和printf#include&lt;iostream&gt; #include&lt;cstdio&gt; //使用scanf和printf时需要使用该库 int main() &#123; int n; char c; float m; scanf(&quot;%d%c%f&quot;, &amp;n, &amp;c, &amp;m); printf(&quot;%d %c %f\\n&quot;, n, c, m); return 0; &#125; 用scanf可以一次读入多个不同类型的变量，输入各项用空格隔开 注意在输入字符时，不会跳过空格（空格也会被当做字符读入） 输入其它数据时，会跳过空格 2. cin和cout#include&lt;iostream&gt; using namespace std; int main() &#123; int c; while ((c=cin.get()) != EOF) &#123; cout &lt;&lt; (char) c; &#125; return 0; &#125; 使用cin读入所有字符，包括空格和回车，EOF Mac（ctrl+D停止输入，ctrl+C停止程序) windows ctrl+Z停止 3. cin&amp;cout / scanf&amp;printf 比较 cin，cout速度慢，输入输出数据量大时用scanf/printf 一个程序不要同时出现cin和scanf，cout和prinf 4. 运算 加、减、乘运算的溢出 二、函数1. 数组作为函数的参数传递数组作为函数的参数时，是传引用的，即形参数组改变了，实参数组也会改变 二维数组作为函数的形参时，必须写明函数有多少列，不要写明有多少行 void PrintArray(int a[][5]) &#123; cout &lt;&lt; a[4][3]; &#125; 必须要写明列数，编译器才能够根据下标算出元素的地址 $\\color&#123;#F00&#125;&#123;a[i][j]的地址 = 数组首地址 + i \\times N \\times sizeof(a[0][0]) + j \\times sizeof(a[0][0])&#125;$ (N是数组列数) 形参数组的首地址就是实参数组的首地址 三、字符串1. 字符串的形式（1）字符串常量用双引号括起来的，如”China”, “C++ program”. 字符串常量占据内存的字节数等于字符中字符数目加1，结尾多出字符’\\0’. 但是字符串的长度不包含'\\0' “”也是合法的·1字符串常量，称为空串，仍然占据一个字节的内存空间，存放’\\0’ （2）存放于字符数组中，以’\\0’结尾用一维char数组存放字符串，结尾是’\\0’，数组元素个数至少为字符串长度+1。 用cin、scanf将字符串读入字符数组时，会自动在字符数组中字符串的末尾加上’\\0’。 （3）string对象。string是C++标准模板库里的一个类，专门用于处理字符串","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]}],"categories":[{"name":"需求与商业模式分析","slug":"需求与商业模式分析","permalink":"https://zhouzhuyan.com/categories/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/"},{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"折腾","slug":"折腾","permalink":"https://zhouzhuyan.com/categories/%E6%8A%98%E8%85%BE/"},{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"},{"name":"设计模式","slug":"设计模式","permalink":"https://zhouzhuyan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"数据科学","slug":"数据科学","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"商业模式","slug":"商业模式","permalink":"https://zhouzhuyan.com/tags/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://zhouzhuyan.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"mosh","slug":"mosh","permalink":"https://zhouzhuyan.com/tags/mosh/"},{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"},{"name":"线程","slug":"线程","permalink":"https://zhouzhuyan.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"云计算","slug":"云计算","permalink":"https://zhouzhuyan.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"递归","slug":"递归","permalink":"https://zhouzhuyan.com/tags/%E9%80%92%E5%BD%92/"},{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"},{"name":"策略模式","slug":"策略模式","permalink":"https://zhouzhuyan.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"概率论","slug":"概率论","permalink":"https://zhouzhuyan.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]}