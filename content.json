{"meta":{"title":"Blog of Adam","subtitle":"Today is a gift, that is why it is called the present.","description":"Take notes and write articles about Software Engineering","author":"ZZY","url":"https://zhouzhuyan.com","root":"/"},"pages":[{"title":"About me","date":"2020-04-02T05:26:58.000Z","updated":"2020-09-04T14:44:38.148Z","comments":true,"path":"about/index.html","permalink":"https://zhouzhuyan.com/about/index.html","excerpt":"","text":"Introduction 重度b站用户，动漫，日剧，美剧，游戏，时政，生活区，美剧，电影，什么都看一点。 正在练习长跑，目标是跑一次半马 早睡早起，多读书，多运动，做一个有趣的人。 Experience 2020 开了博客，好好学习，天天向上 2018 南京大学软件工程"}],"posts":[{"title":"数据结构与算法概述","slug":"数据结构与算法概述","date":"2020-09-10T12:23:52.000Z","updated":"2020-09-10T12:34:45.483Z","comments":true,"path":"posts/ddb07891.html","link":"","permalink":"https://zhouzhuyan.com/posts/ddb07891.html","excerpt":"本文对数据结构进行了介绍，讲述了什么是数据结构以及数据结构涉及到的3个层面。同时介绍了递归的思想和设计，并讲解了斐波那契数列，排列，汉诺塔问题的递归解决方式。","text":"概述1. 什么是数据结构？我们把这个词分解开来，首先回答什么是数据。数据是信息的载体，是数字，字符或其它符号的集合。数据结构是数据对象和组成对象的数据成员之间的关系。 Data_Structure = {D, R}D是数据对象R是D中所有数据成员的关系 数据结构涉及3个方面：逻辑结构：从用户视图看，是面向问题的物理结构：从具体实现视图看，是面向计算机的操作及其实现我们以一个学生表为例，它的逻辑结构式线性表，物理结构是数组，而操作是增删改查 2. 递归简论2.1 如何设计递归我们通过递归来引入数据结构与算法的学习。当一个函数用它自己来定义时，我们就称它是递归(recursive)的。我们可以看下面这个简单的例子 f(x) = \\begin{cases} 0, & x=0 \\\\\\\\ 2f(x-1)+x^2, & x > 0\\end{cases}我们用代码来实现它 public static int f(int x) &#123; if (x == 0) &#123; return 0; &#125; return 2 * f(x - 1) + x * x; &#125; 观察这段代码，函数体内首先有一个if结构，这是递归的基准情况(base case)，即此时函数的值可以直接算出而不用进行递归。再往下的return语句则进入了递归，要注意的是，递归调用将反复进行直到出现基准情况为止。比如我们计算f(3)，那么会调用f(2), f(1)直到出现基准情况f(0)，它的计算实际上是这样的 (2\\times(2\\times(2\\times f(0)+1\\times1) + 2\\times2)+3\\times3)下面我们再来看一种糟糕的递归设计 public static int bad(int n) &#123; if (n == 0) &#123; return 0; &#125; return bad(n / 3 + 1) + n - 1; &#125; 我们会发现，在上述的代码中，bad(1)被定义为bad(1)，而不知道具体是多少，计算机会反复调用它，程序无法停止，也求不出解。 通过上面的两个例子，可以得出递归的设计准则 基准情形(base case)。必须有某些基准的情形，不用递归就能够求解。 不断推进(make progress) 递归调用必须能够朝着一个基准情形推进。 2.2 递归实践我们通过几个经典的例子来加深对递归的理解。 2.2.1 菲波那切数列我们知道它的函数是$fib(0)=0,\\ fib(1)=1,\\ fib(n)=fib(n-1)+fib(n-2); n&gt;=2$可以很容易地将其用代码表示 public static long fib(long n) &#123; if (n == 0 || n == 1) &#123; // base case return n; &#125; return fib(n - 1) + fib(n - 2); &#125; 2.2.2 排列现在有一个数组{a, b, c}，要求对它进行全排列，即排列结果是abc,acb,bac,bca,cab,cba public class Permutation &#123; public static void permutation(char[] list, int k, int m) &#123; int i; if (k == m) &#123; for (i = 0; i &lt;= m; i++) &#123; System.out.print(list[i]); &#125; System.out.println(); &#125; else &#123; for (i = k; i &lt;= m; i++) &#123; char temp = list[k]; list[k] = list[i]; list[i] = temp; permutation(list, k + 1, m); temp = list[k]; list[k] = list[i]; list[i] = temp; &#125; &#125; &#125; public static void main(String[] args) &#123; char[] list = &#123;'a', 'b', 'c'&#125;; permutation(list, 0, 2); &#125; &#125; 2.2.3 汉诺塔问题汉诺塔问题是一个经典的问题。汉诺塔(Hanoi Tower)，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？64个圆盘对于当前的计算机，可能需要几百上千年才能算出，但是我们可以简化这个问题，使用3个圆盘来看一下如何用递归来实现。 根据我们的递归设计准则，首先要明确基准条件，也就是只有一个圆盘，那很简单，就是把它从第一根柱子移动到第三根柱子，然后设计不断推进的过程，有3根柱子，起点(fromTower)，终点(toTower)，中转(auxTower)。有一个非常易于理解的方式，我们首先将盘从起点移到中转点，这个时候的中转点实际上是终点，再从中转点移到终点，这个时候的中转点实际上是起点，所以设计的两个递归是这样的。 moveDisks(n - 1, fromTower, auxTower, toTower); moveDisks(n - 1, auxTower, toTower, fromTower); 下面是完整的代码实现。 public class HanoiTower &#123; public static void moveDisks(int n, char fromTower, char toTower, char auxTower) &#123; if (n == 1) &#123; System.out.println(\"move disk \" + n + \" from \" + fromTower + \" to \" + toTower); &#125; else &#123; moveDisks(n - 1, fromTower, auxTower, toTower); System.out.println(\"move disk \" + n + \" from \" + fromTower + \" to \" + toTower); moveDisks(n - 1, auxTower, toTower, fromTower); &#125; &#125; public static void main(String[] args) &#123; moveDisks(3, 'A', 'B', 'C'); &#125; &#125; 打印结果 move disk 1 from A to C move disk 2 from A to B move disk 1 from C to B move disk 3 from A to C move disk 1 from B to A move disk 2 from B to C move disk 1 from A to C 参考： 《数据结构与算法 Java语言描述》","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://zhouzhuyan.com/tags/%E9%80%92%E5%BD%92/"}]},{"title":"Java 接口","slug":"Java-接口","date":"2020-09-09T01:06:16.000Z","updated":"2020-09-09T01:13:43.654Z","comments":true,"path":"posts/d993c7e9.html","link":"","permalink":"https://zhouzhuyan.com/posts/d993c7e9.html","excerpt":"本文介绍了Java面向对象编程中的另外一个重要概念——接口，介绍了接口的基本含义，属性，接口的回调，以Comparator接口为例展示了如何自定义和使用接口。","text":"接口接口(interface)用来描述类应该做什么，而不指定它们具体该如何做。一个类可以实现(implement)一个或多个接口。 1. 接口的概念接口不是类，而是对希望符合这个接口的类的一组需求 Tip 接口中的所有方法都自动是public，因此在接口中声明方法时，不必提供关键字public 接口绝不会有实例字段 public class Employee implement Comparable&lt;Employee&gt; &#123; // blablabla @Override public int compareTo(Employee other) &#123; return Integer.compare(salary, other.salary); &#125; &#125; 2. 接口的属性接口不是类，不能够使用new实例化一个接口，但是可以声明接口的变量，接口变量必须引用实现这个接口的类对象 Comparable x = new Employee(. . .); Tip为什么需要接口，而不是直接使用抽象类？因为Java不支持多继承，所以每个类只能扩展一个类。而接口提供了多继承的好处，而避免了多重继承的复杂性和低效性。 3. 接口与回调回调(callback)是一种常见的程序设计模式。在这种模式中，可以指定某个特定事件发生时应该采取的动作。比如我们设计了一个时钟，可以请求每秒更新一次，以便更新时钟的表盘。 下面是一个定时器和动作监听的具体使用的例子，定时器启动之后，程序将弹出一个消息对话框，并等待用户点击OK来终止程序的运行，在程序等待用户操作的同时，每隔1秒显示一次当前时间 import java.awt.*; import java.awt.event.*; import java.time.*; import javax.swing.*; public class TimerTest &#123; public static void main(String[] args) &#123; TimePrinter listener = new TimePrinter(); // construct a timer that calls the listener // once every second Timer timer = new Timer(1000, listener); timer.start(); // keep program running until the user selects \"OK\" JOptionPane.showMessageDialog(null, \"Quit program?\"); System.exit(0); &#125; &#125; class TimePrinter implements ActionListener &#123; @Override public void actionPerformed(ActionEvent event) &#123; System.out.println(\"At the tone, the time is \" + Instant.ofEpochMilli(event.getWhen())); Toolkit.getDefaultToolkit().beep(); &#125; &#125; 4. Comparator接口如果我们想要对字符串数组进行排序，可以直接使用String.compareTo方法按字典顺序比较字符串。如果我们希望按照字符串长度来进行比较，可以自己实现一个比较器(comparator)，如下面的例子中，将比较器作为参数传入Arrays.sort方法中。 import java.util.Arrays; import java.util.Comparator; public class LengthCompare &#123; public static void main(String[] args) &#123; String[] friends = &#123;\"Adam\", \"Ben\", \"Peter\", \"Noah\"&#125;; Arrays.sort(friends, new LengthComparator()); System.out.println(Arrays.toString(friends)); &#125; &#125; class LengthComparator implements Comparator&lt;String&gt; &#123; @Override public int compare(String o1, String o2) &#123; return o1.length() - o2.length(); &#125; &#125; 参考： 《Java核心技术 卷I》","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"},{"name":"面向对象","slug":"Java/面向对象","permalink":"https://zhouzhuyan.com/categories/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"Java 继承","slug":"Java-继承","date":"2020-09-08T08:09:47.000Z","updated":"2020-09-08T08:16:52.745Z","comments":true,"path":"posts/8b3a0e63.html","link":"","permalink":"https://zhouzhuyan.com/posts/8b3a0e63.html","excerpt":"本位介绍了Java面向对象编程中的重要思想——继承，包括对超类和子类，对象包装器和继承的设计技巧的介绍。","text":"继承继承(inheritance)的基本思想是基于已经有的类创建新的类，复用这些类的方法。 一、类，超类和子类在前面的文章中我们实现了一个Employee类，假设你在某个公司工作，这个公司的经理和员工的待遇不一样，普通员工在完成任务后仅领取薪水，而经理还拥有奖金。这个时候，我们可以定义一个新类Manager，使用继承重用Employee中的代码，同时定义新的方法来增加奖金这一功能。 TipManager is-a Employeeis-a关系是继承的一个明显特征 1. 定义子类使用extends关键字来表示继承 public class Manager extends Employee &#123; // blablabla &#125; 关键字extends表明正在构造的新类派生于一个已经存在的类。这个类被称为超类(superclass) 或父类(parent class)，新类称为子类(subclass)在设计类时，应该将一般方法放在超类中，将更特殊的方法放在子类中比如我们在Manager类中应该实现一个设置奖金金额的方法。 public class Manager extends Employee &#123; private int bonus; public void setBonus(double bonus) &#123; this.bonus = bonus; &#125; &#125; 2. 覆盖方法超类中的某些方法对子类不一定适用，比如Manager类中的getSalary方法应该返回薪水和奖金的总和，所以要提供一个新的方法来覆盖(override)超类中的某个方法。要注意的是，Manager类的getSalary方法不能够直接访问salary字段，因为其实Employee类的私有字段，所以需要使用super关键字 public int getSalary() &#123; int baseSalary = super.getSalary(); return baseSalary + bonus; &#125; 3. 子类构造器public Manager(int id, String name, int salary) &#123; super(id, name, salary); bonus = 0; &#125; 语句super(id, name, salary);实现了对Employee中私有字段的调用 4. 多态我们可以通过is-a来判断是否将数据设计为继承关系，它的另外一种表述是替换原则，即程序中出现超类对象的任何地方都可以使用子类对象替换。 在Java中，对象变量时多态(polymophic)的。一个Employee类型的变量既可以引用一个Employee类型的对象,也可以引用Employee类的任何一个子类的对象(比如Manager) Employee e; e = new Employee(1, \"A\", 10000); e = new Manager(2, \"B\", 20000); 虽然这里的e引用了Manager类型的对象，但是编译器只将e看成是一个Employee对象，所以如下的调用是错误的。 e.setBonus(10000); // ERROR 5. 阻止继承: final类和方法如果我们需要阻止某个类被继承，可以使用final关键字 public final class Child extends Father &#123; // blablabla &#125; 类中的某个特定的方法也可以声明为final，这样子类就不能够覆盖这个方法。 Tip为什么要将类或方法声明为final？确保它们不会在子类中改变语义。比如String类是final类，所以一个String引用引用的一定是String对象，而不是其它。 6. 抽象类在继承层次结构中，位于上层的类更具有一般性比如我们加入Person类和Student类，下图是这三个类之间的继承关系 每个人都有一些属性，比如姓名，年龄，引入一个公共的超类，就可以把getName方法放在继承层次结构中的更高一层，使用abstract关键字来定义抽象类 public abstract class Person &#123; private String name; public Person (String name) &#123; this.name = name; &#125; public abstract String getDescription(); public String getName() &#123; return name; &#125; &#125; 抽象类不能够实例化，如下的表达式是错误的 new Person(); // ERROR 二、对象包装器与自动装箱所有的基本类型都有一个与之对应的类，这些类被称为包装器(wrapper)，分别是Integer, Long, Float, Double, Short, Byte, Character, Boolean。包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值，同时，包装器还是final，不能够派生它们的子类。 Tip为什么需要包装类？因为Java是一种面向对象程序设计语言，很多地方需要使用对象而不是基本类型。比如在ArrayList中，我们不能够写成ArrayList&lt;int&gt;，而要写成ArrayList&lt;Integer&gt;。 2. 自动拆箱与装箱自动装箱: 就是将基本数据类型自动转换成对应的包装类。自动拆箱：就是将包装类自动转换成对应的基本数据类型。 Integer n = 3; // 自动装箱 int m = n; // 自动拆箱 三、继承的设计技巧 将公共操作和字段放在超类中 使用继承实现is-a关系 除非所有继承的方法都有意义，否则不要使用继承 在覆盖方法时，不要改变预期的行为 使用多态，而不要使用类型信息 参考： Java工程师成神之路 《Java核心技术 卷I》","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"},{"name":"面向对象","slug":"Java/面向对象","permalink":"https://zhouzhuyan.com/categories/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"Java 面向对象概述","slug":"Java面向对象概述","date":"2020-09-04T08:08:48.000Z","updated":"2020-09-08T08:15:25.515Z","comments":true,"path":"posts/e27767b2.html","link":"","permalink":"https://zhouzhuyan.com/posts/e27767b2.html","excerpt":"本文介绍了Java面向对象的相关内容，包括面向对象的思想和特点，类的使用以及静态变量和方法。","text":"对象与类概述一、面向对象程序设计概述结构化程序：算法+数据结构 = 程序 （即确定如何操作数据，再决定如何组织数据的结构） 面向对象程序设计(OOP)：将数据放在第一位，再考虑操作数据的算法 1. 类 类(class)是构造对象的模板或蓝图，就好像一个制作某件工艺品的模具，对象就是工艺品 由类构造(construct)对象的过程称为创建类的实例(instance) 封装(encapsulation)将数据和行为组合在一个包中，对对象的使用者隐藏具体的实现方式，也称为数据隐藏 对象中的数据称为实例字段(instance field)，操作数据的过程称为方法(method) 对象拥有的实例字段值的集合就是这个对象的当前状态(state) 程序只能通过对象的方法和对象数据进行交互，对象被赋予了“黑盒”的特征，提高了重用性和可靠性 可以通过扩展一个类来构建新的类，这使得用户自定义类更加容易。在Java中，所有类都来自于一个超类，即Object。 通过扩展一个类来建立一个新的类的过程就是继承(inheritance)，新类具有被扩展的类的全部属性和方法，可以自定义新的属性和方法。 2. 对象对象的3个特性： 行为(behavior)——可以对对象完成的操作（应用的方法） 状态(state)——描述当前状况的信息，状态的改变必须通过调用方法实现 标识(identity)——每个对象有唯一的标识来区分（如两个订单的编号肯定不相同） 3. 识别类编写程序从识别类开始，然后为各个类添加方法。 一个简单的方法是在分析问题的过程中寻找名词——类，寻找动词——方法 例如我们有商品，订单，账户这样的名词作为类，即Item，Order，Account 那么在账户这个类中，就可以有增加账户，修改账户等方法。 4. 类之间的关系类之间最常见的关系有： 依赖（”uses-a“） 聚合 （”has-a“） 继承（“is-a”) 4.1 依赖（dependence）如果一个类的方法使用或操纵另一个类的对象，我们就可以说一个类依赖于另一个类 比如Order对象访问Account对象查看信用状态，这就是一个使用(“uses-a”)的关系。 （尽可能减少相互依赖的类，做到低耦合） 4.2 聚合（aggregation）类A的对象包含（”has-a”）类B的对象 如一个Order对象就包含了一些Item对象 4.3 继承（inheritance）一个更特殊的类与一个更一般的类之间的关系 也就是前面提到的扩展，比如现在我们定义一个加急订单RushOrder类，那么它是一个（”is-a”)Order类 也就是有Order类继承而来。 下图展示了上述的三种关系。 二、使用预定义类我们通过可以Java中的预定于类来了解如何构造对象，以及如何使用类的方法。如下的例子： import java.util.Date; public class DateTest &#123; public static void main(String[] args) &#123; Date birthday = new Date(); System.out.println(birthday.toString()); &#125; &#125; 在Java中，要使用构造器(constructor)来构造新的实例，比如上面的代码中new Date()就构造了一个新的对象，这个对象被初始化为当前的日期和时间。 Tip需要注意的是，单独的定义Date birthday中的birthday并不是对象，对它进行操作编译器会报错。一定要初始化变量birthday。对象变量本身并不包含一个对象，而是引用一个对象，new操作符的返回值也是一个引用。 三、自定义类1. 对象与对象变量要想使用对象，就需要先构造对象，并指定其初始状态。在Java中，使用构造器（构造函数）来构造。 比如某公司有一个职员管理系统，其中有一个关于职员信息的类Employee 那么我们可以通过下面这个表达式构造一个新对象 Employee employee = new Employee(1, \"Allen\", 10000); 其中employee是一个对象变量，我们用new Employee(int id, String name, int salary)构造了一个新对象，初始化该对象变量，要注意的是对象变量并没有包含一个对象，而是引用一个对象。 在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。 public class Employee &#123; private int id; private String name; private int salary; public Employee(int id, String name, int salary) &#123; this.id = id; this.name = name; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public int getSalary() &#123; return salary; &#125; public static void main(String[] args) &#123; Employee[] staff = new Employee[3]; staff[0] = new Employee(1, \"Allen\", 10000); staff[1] = new Employee(2, \"Ben\", 12000); staff[2] = new Employee(3, \"David\", 15000); for (Employee e : staff) &#123; System.out.println(\"id=\" + e.getId() + \",name=\" + e.getName() + \",salary=\" + e.getSalary()); &#125; &#125; &#125; /** Output: id=1,name=Allen,salary=10000 id=2,name=Ben,salary=12000 id=3,name=David,salary=15000 */ 2. 构造函数构造函数，与类同名，将实例初始化为指定的初始状态 public Employee(int id, String name, int salary) &#123; this.id = id; this.name = name; this.salary = salary; &#125; Tip 构造函数根据参数的不同可以有多个， 构造函数没有返回值。 4. 封装的优点如下是一个访问器方法，又称为字段访问器 public int getId() &#123; return id; &#125; Tip为什么不直接将这些变量设为public公共访问呢？因为这样的话这些变量就可以轻易的被外界修改，受到破坏比如这里的职员id应该是只读的，不能够设置为public被外界随意更改。 4. final定义为final的实例字段必须在构造对象时初始化，否则编辑器会报错，顾名思义，final表示最终的，在初始化之后不能够再修改这个值。 private final String name = \"John\"; Tipfinal修饰符对于基本类型和不可变类，如String类适用，但是对于可变的类，如StringBuilder就会出现问题，因为它仅仅保证了引用不会指向另外一个对象，但是这个对象是可以更改的。 四、静态字段和静态方法1. 静态字段回到我们之前的Employee类中，如果我们需要一个变量来记录公司有多少雇员，就可以使用static修饰符，定义一个静态变量 private static int count; 静态变量是属于类的变量，而不属于单个对象，对于Employee类的所有实例，共享一个count。而对非静态的变量，每个对象都有一个自己的副本 2. 静态常量Math类中定义了一个静态常量PI public class Math &#123; public static final double PI = 3.1415926535897932846; &#125; 我们可以通过Math.PI来直接访问它，如果没有static，那么就需要创建Math类的对象来访问它，效率比较低。 3. 静态方法如果我们想要知道公司的雇员人数，就可以使用静态方法 public static int getCount() &#123; // 返回静态变量 return count; &#125; 使用静态方法的两种情况： 方法不需要访问对象状态 方法只需要访问类的静态字段（比如上面的例子）","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"},{"name":"面向对象","slug":"Java/面向对象","permalink":"https://zhouzhuyan.com/categories/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"}]},{"title":"Hexo部署到云服务器","slug":"Hexo部署到云服务器","date":"2020-09-03T14:57:59.000Z","updated":"2020-09-03T15:05:57.872Z","comments":true,"path":"posts/e80e623c.html","link":"","permalink":"https://zhouzhuyan.com/posts/e80e623c.html","excerpt":"","text":"0. 准备工作博客的搭建和域名的绑定可以参考我以前的博客。使用Github pages + Hexo搭建个人博客Hexo个人博客绑定域名 由于博客是基于Github pages搭建的，所以在国内的访问速度比较慢，可以部署到云服务器上加快访问的速度，我使用的是腾讯云学生机。注意在国内使用云服务器部署网站需要对网站进行备案，详细步骤可以参考腾讯的官方文档。在备案完成后，就可以进行网站的部署了。 1. 配置gitTip我的服务器型号是CentOS 7.5 1.1 安装gityum install -y git 看到complete字样说明安装完成了，可以通过如下命令验证 git --version 出现版本则说明安装成功。 1.2 创建git账户adduser git passwd git 注意一定要有第二步passwd git，这是给git账户设置密码，否则账户不会使用。 1.3 设置免密登录git使用su命令切换至git用户，并进入用户git的根目录 su git cd 创建~/.ssh文件夹和~/.ssh/authorized_keys文件 mkdir ~/.ssh touch ~/.ssh/authorized_keys 将本地的id_rsa.pub文件中的公匙复制到authorized_keys文件中，在mac中，该文件的地址是/Users/你的用户名/.ssh/id_rsa.pub，可以在终端中使用如下命令打开.ssh文件夹，然后使用vs code打开该文件 open /Users/galahad/.ssh 复制其中的内容，然后打开authorized_keys文件 vi ~/.ssh/authorized_keys 按i进入插入模式，复制内容按esc键进入命令模式，输入:wq保存并退出最后对文件赋予对应的权限 chmod 600 /home/git/.ssh/authorized_keys chmod 700 /home/git/.ssh 这样就可以使得本地终端可以免密登录git用户，可以在本地终端使用ssh远程连接测试 ssh git@你的IP 如果仍需输入密码，那说明配置有问题，可以重新按照1.3的步骤再配置一遍，当然，1.3的部分不是必须的，这只是为了在本地提交文件到服务器的时候不用输入密码，省点儿力气。 1.4 配置git仓库在git用户的根目录下创建hexo存储的目录 mkdir -p projects/blog 再创建一个git仓库，并初始化一个仓库 mkdir repos cd repos git init --bare blog.git 之后，在blog.git文件夹下会产生一个hooks文件夹，在其中创建一个文件post-receive，在其中配置一个钩子 cd blog.git/hooks vi post-receive 将如下内容复制到其中 #!/bin/sh git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f 保存退出之后，赋予文件可执行权限 chmod +x post-receive 然后输入exit回到root用户下，输入如下命令 chown -R git:git /home/git/repos/blog.git 配置完仓库后，可以在本地使用git clone命令测试是否能够成功克隆仓库 git clone git@server_ip:/home/git/repos/blog.git 2 配置Nginx2.1 安装Nginxyum install -y nginx 启动nginx nginx 2.2 配置文件先暂停服务 nginx -s stop 进入nginx目录，编辑配置文件 cd /etc/nginx vi nginx.conf 注意要修改两个地方，一个是将user nginx改为user root第二个就是在server的位置，添加root解析路径/home/git/projects/blog/，如果你已经有了域名，那么在server_name后面添加上你的域名。其它保持不变。 server &#123; listen 80 default_server; listen [::]:80 default_server; server_name zhouzhuyan.com www.zhouzhuyan.com; root /home/git/projects/blog/; index index.html index.htm; &#125; 保存退出重新启动nginx systemctl restart nginx 2.3 检查检查nginx状态 systemctl status nginx 如果看到绿色的active就表示配置成功了。我在这里遇到了一个问题，它的状态显示红色的failed,，错误是98: Address already in use，80端口已经被占用，这个时候可以用如下命令检查一下是谁占用了80端口 netstat -ntpl 如果就是nginx的话，应该是由于之前的配置文件中，listen 80 default_server;监听ipv4的80端口，而listen [::]:80 default_server;监听的是ipv6的80端口，于是就重复占用了。可以在配置文件中这样更改 listen [::]:80 ipv6only=on default_server; 然后重启nginx应该就可以了。 3. Hexo本地配置hexo的站点配置文件_config.yml deploy: type: git repo: git@你的IP:/home/git/repos/blog.git branch: master 然后进行部署 hexo clean hexo g -d 4. 启用https由于nginx默认使用的是http，所以在网站访问的时候，会显示不安全，可以通过配置来开启https 4.1 申请SSL证书阿里云和腾讯云都提供免费的SSL证书下载，因为我的域名是在腾讯云云购买的，所以我就从腾讯云上下载了SSL证书 4.2 传输文件到服务器从腾讯云上下载证书到本地，会得到一个自己域名命名的文件夹，里面有Apache，Nginx，Tomcat，IIS的证书，由于我们使用的是nginx服务，所以只需要Nginx文件夹内的xxx.crt和xxx.key两个文件。在服务端创建文件夹存储证书 mkdir /home/git/SSL 我们可以使用scp命令将本地的文件传输到服务器 scp -r xxx/Nginx git@你的IP /home/git/SSL 4.3 配置nginx然后再次编辑nginx.conf文件，这里可以参考官方文档Nginx 服务器证书安装，文档写的很清晰，按照其中的步骤配置一下就可以完成了。之后我们就可以通过https访问网页，在网址旁边会出现一把锁。 参考：[1]HJX.将Hexo部署到阿里云轻量级服务器(保姆级教程)[EB/OL].https://hjxlog.com/posts/20191130a1.html,2019-11-30.[2]Dreamy.TZK.将Hexo部署到云服务器[EB/OL].https://cloud.tencent.com/developer/article/1632020,2020-05-25.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"策略模式","slug":"策略模式","date":"2020-09-02T04:29:06.000Z","updated":"2020-09-04T08:28:26.301Z","comments":true,"path":"posts/72e3b671.html","link":"","permalink":"https://zhouzhuyan.com/posts/72e3b671.html","excerpt":"","text":"策略模式 问题：假设有一个模拟鸭子的游戏，游戏中拥有各种鸭子，我们设计了一个鸭子的超类，并且让各种鸭子，比如红头鸭，橡皮鸭等，继承它。现在，我们需要更新这个游戏，使得鸭子可以飞起来，该怎么做？ 使用继承？如果依然使用继承，在超类中添加一个fly()方法，会出现不适合该行为的子类也具有该行为的问题，比如橡皮鸭就不会飞，但继承的做法使得它也可以飞起来。 如果选择覆盖fly()方法，那么在后续的更新中，我们需要不断地检查可能需要覆盖的fly()方法。所以使用继承来提供行为，会造成代码在多个子类最终重复，复用性差，难以知道鸭子的全部行为，运行时的行为不容易改变等问题。 使用接口？如果抽象出一个Flyable接口，只有会飞的鸭子才实现这个接口呢？设想一下，如果我们有上百种会飞的鸭子，那么就会造成大量的代码重复，每个子类中都要实现一次fly()方法，而且代码无法复用，如果我们需要修改这个方法，想象一下，这简直就是一场灾难。 策略模式实现软件开发过程中总是伴随着变更。设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码放在一起。也就是说我们把会变化的部分取出并封装起来，以便以后的改动和扩充。 分离变化与不变的部分在鸭子类中，我们可以发现fly()和quack()两个方法经常需要修改，那么我们就可以建立两组远离Duck类的类，一个与fly相关，一个与quack相关，每一组类实现各自的动作，比如让一个类实现“呱呱叫”，一个类实现“吱吱叫”，还有一个类实现“安静” 设计行为设计原则 针对接口编程，而不是针对实现编程用接口代表每个行为，鸭子类不会实现Flying的接口，而是制造一组专门的类来实现FlyBahavior public interface FlyBehavior &#123; public void fly(); &#125; 实现行为现在有一个FlyBehavior接口，还有对应的类，负责实现具体的行为。 public class FlyWithWings implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\"I'm flying.\"); &#125; &#125; public class FlyNoWay implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\"I can't fly\"); &#125; &#125; 整合行为鸭子将飞行的动作委托给别人处理，而不是在鸭子类内部定义飞行方法。在鸭子类中加入实例变量flyBahavior，声明为接口类型。 public abstract class Duck &#123; FlyBehavior flyBehavior; public abstract void display(); public void performFly() &#123; flyBehavior.fly(); &#125; &#125; 每个鸭子对象都会动态的设置这些变量以在运行时引用正确的类型。 public class MallardDuck extends Duck &#123; public MallardDuck() &#123; flyBehavior = new FlyWithWings(); // 使用FlyWithWings作为FlyBehavior类型 &#125; @Override public void display() &#123; System.out.println(\"I'm a real Mallard duck.\"); &#125; &#125; 测试 public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck mallard = new MallardDuck(); mallard.performFly(); &#125; &#125; // Output: I'm flying. 动态设定行为如果想要在运行时改变鸭子的行为，只需要调用鸭子的setter方法就可以了。我们在鸭子类中增加设定方法 public void setFlyBehavior(FlyBehavior fb) &#123; flyBehavior = fb; &#125; 创造一个新的类模型鸭 public class ModelDuck extends Duck &#123; public ModelDuck() &#123; flyBehavior = new FlyNoWay(); &#125; @Override public void display() &#123; System.out.println(\"I'm a model duck.\"); &#125; &#125; 建立一个新的FlyBehavior类型 public class FlyRocketPowered implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\"I'm flying with a rocket.\"); &#125; &#125; 测试调用setter方法，改变了模型鸭的飞行行为 public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck model = new ModelDuck(); model.performFly();; model.setFlyBehavior(new FlyRocketPowered()); model.performFly(); &#125; &#125; /* Output: I can't fly; I'm flying with a rocket. */ 每一个鸭子都有一个(HAS-A)FlyBahavior，将飞行委托给它处理。设计原则 多用组合，少用继承使用组合建立系统具有很大的弹性，可以将算法族封装成类，还可以在运行时动态地改变行为。 策略模式小结意图定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。使得算法可以独立于它的客户变化。 适用 许多相关的类仅仅只是行为有差别，比如鸭子类中的飞行 需要使用一个算法的不同变体 算法使用客户不应该知道的数据 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现（switch或if） 结构与参与者 Strategy (策略)定义所有支持的算法的公共接口，Context使用这个接口来调用ConcreteStrategy定义的算法，比如FlyBehavior就是一个策略ConcreteStrategy(具体策略)以Strategy接口实现某具体的算法，比如FlyWithWings,FlyNoWay等Context (上下文) 用一个ConcreteStrategy对象来配置 维护一个对Strategy对象的引用 可定义一个接口让Strategy来访问它的数据比如Duck类 效果优点 相关算法系列 Strategy类层次为Context定义了一系列可供复用的算法或行为 替代继承的方法 使用继承可以直接生成一个Context的子类，给它不同的行为，但这样会使得Context难以理解，维护和扩展，不能动态改变算法。而将算法封装在独立的Strategy类中使得我们可以独立于Context改变它，易于理解，修改和扩展。 消除可一些条件语句 含有许多条件语句的代码通常需要使用策略模式 实现的选择 策略模式可以提供相同行为的不同实现供客户选择 缺点 客户必须了解不同的策略 需要向客户暴露具体问题，所以只有当不同行为的变体与客户有关时，才使用策略模式 Strategy和Context之间的通信开销 增加了对象的数目","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhouzhuyan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"策略模式","slug":"策略模式","permalink":"https://zhouzhuyan.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"概率论的基本概念","slug":"概率论的基本概念","date":"2020-04-09T15:23:48.000Z","updated":"2020-09-03T15:44:49.340Z","comments":true,"path":"posts/36736857.html","link":"","permalink":"https://zhouzhuyan.com/posts/36736857.html","excerpt":"本文介绍了概率论的基本概念，包括概率的定义，概率的计算，同时还有随机测试的简单介绍。 重点 概率的定义 条件概率 乘法公式 全概率公式 贝叶斯公式","text":"本文介绍了概率论的基本概念，包括概率的定义，概率的计算，同时还有随机测试的简单介绍。 重点 概率的定义 条件概率 乘法公式 全概率公式 贝叶斯公式 一、概率的定义当我们还不能用数学符号描述一件事情，那么说明我们还没有想清楚这件事。 所以，我们需要建立元素到数据的映射 1. 基本概念1.1 随机实验 可以在相同的条件下重复进行 每次实验结果不止一个，并且事先明确实验的所有可能结果 进行一次实验前不能够确定那一个结果会出现 例：抛一枚硬币，观察正面H与反面T出现的情况 1.2 样本空间随机试验$E$的所有可能结果组成的集合称为$E$的样本空间，记为$\\Omega$ 样本空间中的每个元素，即$E$的每个结果，称为样本点，记为$e$ 1.3 随机事件样本空间$\\Omega$的任意子集$A$称为随机事件 观察到样本点$e$，若$e\\in A$，则称这一事件发生。 基本事件：由一个样本点组成的单点集 复合事件：由两个或两个以上样本点组成的集合 必然事件：全集$\\Omega$ 不可能事件：空集$\\emptyset$ 2. 事件的集合运算 包含：$A\\subset B$，事件B包含事件A，则事件A发生必然导致事件B发生 相等：$A=B$，即$A\\subset B$且$B\\subset A$ 和：$A\\bigcup B$，即A和B至少有一个发生 差：$A-B$，即事件A发生且事件B不发生 积：$A\\bigcup B$，记作$AB$，即事件A和事件B都发生 互不相容：$AB = \\emptyset$，即A和B不能同时发生 互逆：$A\\bigcup B=\\Omega$ 且$AB = \\emptyset$，A和B互逆，通常B记为$\\overline{A}$ 2.1 复杂事件的集合运算 A发生而B和C都不发生：$A\\overline{B} \\overline{C}=A-B-C=A-(B\\bigcup C)$ A与B都发生而C不发生：$AB\\overline{C}=AB-C=AB-ABC$ 三个事件都发生：$ABC$ 三个事件恰好有一个发生：$A\\overline{B}\\overline{C}+\\overline{A}B\\overline{C}+\\overline{A}\\overline{B}C$ 三个事件至少发生一个：$A\\bigcup B\\bigcup C$ 2.2 常用定律 交换律 结合律 分配率：$A\\, \\bigcup \\,(B\\bigcap C)=(A\\bigcup B)\\bigcap (A\\bigcup C)$ $A\\, \\bigcap \\,(B\\bigcup C)=(A\\bigcap B)\\,\\bigcup \\,(A\\bigcap C)$ 德摩根定律：$\\overline{A\\bigcup B}=\\overline{A}\\bigcap\\overline{B}$ $\\overline{A\\bigcap B}=\\overline{A}\\bigcup\\overline{B}$ 3. 频率描述了事件发生的频繁程度 定义 重复观察n次事件A发生的次数$n_A$称为A的频数 比值$\\frac{n_A}{n}$称为事件A发生的频率，并记为$f_n(A)$ 性质 $0\\,\\leq\\, f_n(A)\\, \\leq\\, 1$ $f_n(\\Omega)=1$ 若$A_1,\\cdots,A_k$两两互不相容，则 f_n(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=f_n(A_1)+\\cdots+f_n(A_k) 收敛性 当n足够大，$f_n(A)$收敛于某个常数，这个常数就是概率（证明见后续） 我们应该都听说过德摩根抛硬币的故事，对一个事件进行大量的实验可以得到频率，但是我们不可能对所有事件都做类似的事情，所以就有了概率 4. 概率表征事件发生的可能性大小 定义 $\\Omega$为样本空间，对于每一事件A赋予一实数$P(A)$，若P(A)满足下列条件则被称为概率： 非负性：$0\\leq P(A)\\leq 1$ 规范性：$P(\\Omega)=1$ 可列可加性：$A_1,\\cdots,A_n$互不相容，则$P(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=P(A_1)+\\cdots+P(A_k)$ 性质 $P(\\emptyset)=0$ $P(\\overline{A})=1-P(A)$ 若$A\\subset B$，则有$P(A)\\leq P(B),\\quad P(B-A)=P(B)-P(A)$ 对于任意两个事件A和B，$P(A\\bigcup B)=P(A)+P(B)-P(A+B)$ 4.1 古典概型(等可能概型)定义 若$\\Omega$是**有限样本空间，其样本点为$e_1,\\cdots e_n$，在有限样本空间中引进概率。 1/n称为事件${e_i}$的概率，记为$P({e_i})$ P(\\{e_1\\})+\\cdots +P(\\{e_n\\})=P(\\Omega)=1从定义中不难发现古典概型的两个特点： 样本空间包含有限个元素 试验中每个基本事件发生的可能性相同 注：基本事件是两两不相容的 若事件A包含k个基本事件，则有 P(A)=\\sum_{i=1}^kP(\\{e_{i_k}\\})=\\frac{k}{n}4.2 几何概型数据从有限集合推广到无限集合 例：约会问题 两人约定7点到8点在某地会面，先到者等候另一人20分钟，过时就离去，试求这两人会面的概率。 解：以$x,y$分别表示两人到达的时刻，则会面的充要条件为$|x-y|\\leq20$，这就是一个几何概率的问题，可能的结果全体是边长60的正方形里面的点，结果为 P(A)=\\frac{60^2-40^2}{60^2}从上面的例子不难看出，样本空间从原来的有限的个数，变成了无限的点。 如果要在半径为1的圆内随机地取一条弦，问弦长超过$\\sqrt{3}$的概率是多少？ 3种思路有3种不同的答案 在数据映射中，我们需要遵循物理世界到数据集合的某种结构保持 二、概率的计算1. 条件概率事件A发生的条件下事件B发生的概率 1.1 定义设A，B是两事件，且$P(A)&gt;0$，称 P(B|A)=\\frac{P(AB)}{P(A)}为在事件A发生的条件下事件B发生的条件概率 条件概率符合概率定义中的3个条件 非负性 规范性 可列可加性：$B_1,\\cdots,B_n$两两互不相容 P(\\bigcup_{i=1}^\\infty B_i\\,\\mid\\,A)=\\sum_{i=1}^\\infty P(B_i\\mid A)同时也可以使用概率的性质 P(B_1\\bigcup B_2)=P(B_1\\mid A)+P(B_2\\mid A)-P(B_1B_2\\mid A)注意这里是对任意事件$B_1,B_2$，两者不一定互不相容，如果互不相容，那么$P(B_1B_2)=\\emptyset$，与可列可加性不矛盾。 1.2 乘法公式P(AB)=P(A)P(B|A)推广：一般地，我们有： P(A_1A_2\\cdots A_n)=P(A_1)P(A_2\\mid A_1)\\cdots P(A_n\\mid A_1A_2\\cdots A_{n-1})大多数应用中，我们会直接获取条件概率，通过它进行计算 1.3 完备事件组设$B_1,\\cdots,B_n$是样本空间$\\Omega$的一个事件组，若满足 $B_i\\bigcap B_j=\\emptyset$ ，对于任意$i\\neq j$ $\\bigcup_iB_i=\\Omega$ 则$B_1,\\cdots,B_n$称为一个完备事件组 1.4 全概率公式设$B_1,\\cdots,B_n$是样本空间$\\Omega$的一个完备事件组，且$P(B_i)&gt;0(i=1,2,\\cdots,n)$，则对于任一随机事件A，有 P(A)=\\sum_{i=1}^nP(B_i)P(A\\mid B_i)当$P(A)$不易求得时，利用此公式 1.5 贝叶斯公式设实验E的样本空间为$\\Omega$，$A$为$\\Omega$的事件，$B_1,\\cdots,B_n$为$S$的一个划分，且$P(A)&gt;0,P(B_i)&gt;0$，则 P(B_i\\mid A)=\\frac{P(A\\mid B_i)P(B_i)}{\\sum_{j=1}^nP(A\\mid B_j)P(B_j)},i=1,2,\\cdots,n如：设$A,B$为两事件，$P(B)&gt;0$，则 P(A\\mid B)=\\frac{P(B\\mid A)\\times P(A)}{P(B)}贝叶斯定理往往与全概率公式同时使用。全概率公式用于”由因求果“的问题，而贝叶斯定理用于”执果寻因“问题。 常用：令$n=2$，那么全概率公式和贝叶斯公式分别为： P(A)=P(A\\mid B)P(B)+P(A\\mid \\overline{B})P(\\overline{B})P(B\\mid A)=\\frac{P(AB)}{P(A)}=\\frac{P(A\\mid B)P(B)}{P(A\\mid B)P(B)+P(A\\mid \\overline{B})P(\\overline{B})}1.6 独立性定义：设$A,B$是两事件，如果满足等式 P(AB)=P(A)P(B)则称事件$A$和事件$B$相互独立 定理：设$A,B$是两事件，且$P(A)&gt;0$，若$A,B$相互独立，则$P(B\\mid A)=P(B)$，反之亦然 定理：若事件$A,B$相互独立，则下列各对事件也相互独立，$A\\&amp;\\overline{B},B\\&amp;\\overline{A},\\overline{A}\\&amp;\\overline{B}$ 定义：设$A,B,C$是三个事件，如果满足等式 P(AB)=P(A)P(B),\\\\ P(BC)=P(B)P(C)\\\\P(AC)=P(A)P(C)\\\\P(ABC)=P(A)P(B)P(C)则称事件$A,B,C$相互独立 三、随机测试示例实际应用中使用概率论 1. 随机测试初步假设有一个计算多项式乘法的程序。 程序可能采用左右两边的某一方式实现： (x+1)(x-2)(x+3)(x-4)(x+5)(x-6)=x^6-7x^3+25思考： 如何验证左右两边的多项式相等 假设有一个超大规模的多项式呢？ F(X)?\\equiv G(x)1.1 规范化两个多项式相等当且仅当他们的规范式中所有的对应系数相等， 那么把$F(x)$变换为规范式，有$O(d^2)$的复杂度 1.2 随机测试-初步设$F(X),G(x)$的最高阶为的$d$，随机算法首先是从${1,\\cdots,100d}$中均匀随机（等可能）地选择一个整数$r$，然后计算两个式子的值，进行判断。有$O(d)$的复杂度，大大提高了速度。 当然，这种算法可能会给出错误的答案。 $F(x)\\neq G(x), F(r)=G(r)$，算法检测结果错误 错误的概率是多少？可以接受吗？ 当$r$是方程$F(x)-G(x)=0$的根时，必然会出现错误结果。 $F(x)-G(x)$的次数不高于$d$，由代数的基本定理可知，$F(x)-G(x)=0$不可能多于$d$个根。 那么在${1,\\cdots,100d}$中，给出错误答案的概率不会高于$\\frac{1}{100}$ 2. 随机测试改进如何改进算法正确率？ 很容易想到两个方向，扩大检测范围，重复多次检测 2.1 扩大范围在更大的范围进行取值，比如在${1,\\cdots,1000d}$中进行检测，那么错误答案概率不会超过$\\frac{1}{1000}$ 2.2 重复检测重复多次进行随机检测 有放回抽样 $k$次有放回抽样错误率为 P(E_1\\,\\bigcap\\cdots\\bigcap\\,E_k)=\\prod_{i=1}^kP(E_i)\\leq(\\frac{1}{100})^k可以看到，错误率指数级降低 无放回抽样 总结： 无放回比有放回准确率高 有放回实现比无放回简单 当$d+1$次无放回抽样后，能够确保准确性，但是算法复杂度提升到$O(d^2)$ 四、总结1. 概率的定义$\\Omega$为样本空间，对于每一事件A赋予一实数$P(A)$，若P(A)满足下列条件则被称为概率： 非负性：$0\\leq P(A)\\leq 1$ 规范性：$P(\\Omega)=1$ 可列可加性：$A_1,\\cdots,A_n$互不相容，则$P(A_1\\,\\bigcup\\,\\cdots\\bigcup\\,A_k)=P(A_1)+\\cdots+P(A_k)$ 2. 条件概率P(B|A)=\\frac{P(AB)}{P(A)}3. 乘法公式P(A_1A_2\\cdots A_n)=P(A_1)P(A_2\\mid A_1)\\cdots P(A_n\\mid A_1A_2\\cdots A_{n-1})4. 全概率公式P(A)=P(A\\mid B_1)P(B_1)+\\cdots+P(A\\mid B_n)P(B_n)5. 贝叶斯公式P(A\\mid B)=\\frac{P(B\\mid A)P(A)}{P(B)}参考： 中国大学MOOC-南京大学-数据科学基础 《概率论与数理统计》浙江大学第四版","categories":[{"name":"数据科学","slug":"数据科学","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://zhouzhuyan.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"}]},{"title":"Hexo个人博客绑定域名和配置SSL证书","slug":"Hexo个人博客绑定域名和配置SSL证书","date":"2020-04-09T13:29:25.000Z","updated":"2020-09-03T15:05:31.618Z","comments":true,"path":"posts/2cd2c226.html","link":"","permalink":"https://zhouzhuyan.com/posts/2cd2c226.html","excerpt":"Hexo 个人博客绑定域名和配置SSL证书在完成个人博客的搭建以后，我们可以通过一个https://xxx.github.io形式的链接在访问我们的个人博客网站，那么如果想拥有一个个性的域名，该如何操作呢？","text":"Hexo 个人博客绑定域名和配置SSL证书在完成个人博客的搭建以后，我们可以通过一个https://xxx.github.io形式的链接在访问我们的个人博客网站，那么如果想拥有一个个性的域名，该如何操作呢？ 一、 绑定域名1. 购买域名可以在阿里云或者腾讯云上购买，不同形式的有不同的价格，根据自己的情况购买即可。我在腾讯云上购买了我现在的域名zhouzhuyan.com 注意：如果不使用国内的服务器的话不用备案，只要完成实名认证就可以了。 现在实名认证，审核都很快，虽然说一个工作日审批，但是我的话几分钟成功了。在域名的状态显示正常以后，就可以使用了。 2. 域名解析这个时候，网站时访问不了的，因为还需要去解析你的域名，将你的域名指向你的个人网站。 到腾讯云控制台的域名管理界面，找到你的域名，点击解析，选择添加记录 主机记录 记录类型 线路类型 记录值 www CNAME 默认 你的Github项目仓库名 @ CNAME 默认 你的Github项目仓库名 两个主机记录是为了让你的网站在有www和没有的情况下都可以访问，仓库名可以在Github仓库的Settings里面找到。解析需要10分钟，耐心等待。 3. 在项目中更换到Github中找到自己的网站所在的仓库，进入Settings界面 在Custom domain里面填写自己的域名，选择save，这样就会出现上图的形式，显示Your site is published at https://你的域名，勾选Enforce HTTPS 4. 创建CNAME文件进入你的Hexo本地文件所在的根目录，找到\\source目录，在里面创建一个文件CNAME，注意它是没有类型的，不是.txt。 在里面加入你的域名，注意不要在前面加入https www这样的前缀，就是你的域名。 然后hexo d -g部署你的网站，等待一段时间后，就可以通过你的个性域名访问网站了。 二、 SSL安全证书注册好域名后，用google访问时，可能会出现您访问的不是安全链接的提示，或者能够正常访问，但是域名旁边显示的是一个感叹号，表示不安全，这是因为我们还没有申请安全证书，在申请了证书之后，域名旁边显示的就是一把锁，表示安全。 腾讯云和阿里云都提供免费的SSL证书下载，具体安装也有相关的文档，按照步骤操作就行。 腾讯云Nginx服务器证书安装 Mac下nginx的使用 在证书安装好了以后，可以看到域名解析里面多出了一条TXT类型的解析。 在Chrome浏览器中，打开网站后如果仍然显示不安全，即没有出现锁的图标，右击选择检查元素，进入开发者模式，看Security里面有什么问题。 踩坑：我发现我用阿里云图床的图片引用的是http头，把它改为https，锁就出现了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"C++字符串,向量和数组","slug":"字符串-向量和数组","date":"2020-04-03T14:03:24.000Z","updated":"2020-09-03T15:45:27.515Z","comments":true,"path":"posts/869e4b19.html","link":"","permalink":"https://zhouzhuyan.com/posts/869e4b19.html","excerpt":"二、字符串，向量和数组作用域操作符:: 含义：编译器应从操作符左侧的作用域中寻找右边那个名字 比如std::cin是要使用命名空间std中的cin 这样做是为了避免某些名字被重复使用 使用using声明可以更加简便的使用命名空间中的成员。","text":"二、字符串，向量和数组作用域操作符:: 含义：编译器应从操作符左侧的作用域中寻找右边那个名字 比如std::cin是要使用命名空间std中的cin 这样做是为了避免某些名字被重复使用 使用using声明可以更加简便的使用命名空间中的成员。 1. String类型表示可变长的字符串 1.1 定义和初始化 使用需要头文件和命名空间 #include&lt;string&gt; using std::string; 初始化 string s1; // 空字符串 string s2 = s1; // s2是s1的副本 string s3 = \"abc\"; string s4(10, 'c'); // 十个c 1.2 string对象上的操作 使用getline读取一整行 string line; getline(cin, line); 当读取到换行符时结束，并将读到的内容存入string中，但是不存换行符 empty和size操作 str.empty()根据字符串是否为空返回一个布尔值 str.size()返回字符串长度 使用visual studio编程的时候，碰到过一个warning，将无符号数赋值给了有符号数。 这是由于size函数的返回值类型引起的，它是一个string::size_type类型的值，是无符号类型的， 可以用auto来推断变量的值 auto len = str.size(); 比较，赋值，相加 string s1 = \"abc\"; string s2 = \"xcvd\"; // s1 &lt; s2 比较第一个不同的字符 string s3 = s1; // 赋值 string s4 = s1 + s2; // abcxcvd 处理string中的字符 #include&lt;cctype&gt; isalnum(c); isalpha(c); islower(c); isupper(c); ispunct(c); // 是标点符号为真 2. Vector类型可变长数组，类似于Java中的ArrayList 2.1 初始化vector&lt;T&gt; v; vector&lt;T&gt; v1 = &#123;a, b, c&#125;; // 注意是花括号 vector&lt;T&gt; v2&#123;a, b&#125;; // 花括号，两个元素 vector&lt;int&gt; v3(10, 1); // 圆括号 10个元素，每个初始化为1 2.2 操作vector&lt;int&gt; v; v.push_back(1); // 添加1 v.pop_back(); // 去掉最后一个数据 v.empty(); v.size(); v[n]; // 注意下标只能访问，但是不能够添加元素 3. 迭代器访问元素的作用 string s = \"abcde\"; if (s.begin() != s.end()) &#123; // 确保s非空 &#125; 4. 数组4.1 指针和数组int ia[] = &#123;1, 2, 3, 4, 5&#125;; auto p(ia); // 整型指针，指向ia的第一个元素 p++; // 指向第一个元素","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]},{"title":"Hexo-Permalink简化","slug":"Hexo-Permalink简化","date":"2020-04-03T12:59:43.000Z","updated":"2020-09-03T15:05:36.963Z","comments":true,"path":"posts/838443af.html","link":"","permalink":"https://zhouzhuyan.com/posts/838443af.html","excerpt":"Permalink简化在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章 阮一峰 关于url编码 有两种方法优化。","text":"Permalink简化在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章 阮一峰 关于url编码 有两种方法优化。 方法一：自定义首先，在scaffolds的post.md中，加入urlname元素。 title: &#123;&#123; title &#125;&#125; urlname: date: &#123;&#123; date &#125;&#125; tags: categories: 然后，在配置文件_config.yml中，将永久链接permalink的形式改为 permalink: :category/:urlname/ 也就是类别加上自定义的url链接。 每次写文章时，可以自己设计该页的url，使得它变得简单，同时也利于区分。 但是，这种修改方法的链接会随着文件目录的改变而改变， 比如一篇文章HelloWorld.md本来放在_posts目录下，链接为https://xxx/_posts/HelloWorld.md 之后归类到_posts/A目录下，那么链接变为https://xxx/_posts/A/HelloWorld.md 这样不太利于分享，所以推荐使用第二种方法。 方法二：插件使用hexo-abbrlink这个插件 安装 npm install hexo-abbrlink --save 设置 在_config.yml文件中修改永久链接格式 permalink: posts/:abbrlink.html abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex posts部分是可以更改的，也可以仿照方法一添加一个关键词便于识别 permalink: :keywords/:abbrlink.html 生成 在根目录创建Gruntfile.js文件，让插件到source/_posts/下读取所有的.md文件，把文件中的@@abbrlink替换成文件内容的hash值。 module.exports = function(grunt) &#123; grunt.initConfig(&#123; rewrite: &#123; abbrlink: &#123; src: 'source/_posts/**/*.md', editor: function(contents, filepath)&#123; const crypto = require('crypto'); const hash = crypto.createHash('sha256'); hash.update(contents); var hashValue = hash.digest('hex'); return contents.replace(/@@abbrlink/g, hashValue.substring(0, 16)); &#125; &#125;, &#125;, &#125;); grunt.loadNpmTasks('grunt-rewrite'); &#125;; 这种方法生成的链接是不带目录的，直接就是第二步设置中permalink的样式，所以也没有了被改变的风险。 参考 http://blog.jvaeyhcd.wang/posts/05c9df7e0c47bd64.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"C++变量和基本类型","slug":"变量和基本类型","date":"2020-04-03T12:44:47.000Z","updated":"2020-09-03T15:36:13.561Z","comments":true,"path":"posts/96db5496.html","link":"","permalink":"https://zhouzhuyan.com/posts/96db5496.html","excerpt":"变量和基本类型1. 复合类型(Compound type)基于其它类型定义的类型 1.1 引用(Reference)引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。","text":"变量和基本类型1. 复合类型(Compound type)基于其它类型定义的类型 1.1 引用(Reference)引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。 (在这里，引用指的是左值引用) int ival = 1024; int &amp;refval = ival; // refval指向ival，是ival的另外一个名字 int &amp;refVal2; // 报错；引用必须被初始化 定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。（与初始化变量时不同的） 无法令引用重新绑定到另一个对象，所以引用必须被初始化 引用即别名，它不是对象，而是为了一个已经存在的对象起了另外一个名字 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的 refVal = 2; // 把2赋值给与refVal绑定的对象上，这里就是绑定到iVal上 int ii = refVal; 除了两种特殊情况，其它所有引用的类型都要与之绑定的对象严格匹配。不能够与字面值或表达式的计算结果绑定。 int &amp;refVal4 = 10; // 错误：引用对象初始值必须是一个对象 double dval = 3.14; int &amp;refVal5 = dval; // 错误：此处引用类型的初始值必须是int型对象 1.2 指针指针是指向另外一种类型的符合类型，与引用类似，指针实现了对其它对象的间接访问。 不同： 指针本身是一个对象 指针无需在定义时赋初值 int *ip1; // ip1是指向int对象的指针 获取对象的地址指针存放某个对象的地址。 int ival = 42; int *p = &amp;ival; // p是存放变量ival的地址，或者说p是指向引用的指针。 指针值指针的值（即地址）应该属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针 无效指针 利用指针访问对象如果指针指向了一个对象，可以使用解引用符（操作符*）来访问对象 int ival = 42; int *p = &amp;ival; cout &lt;&lt; *p // 输出42 *p = 0; cout &lt;&lt; *p // 输出0，为*p赋值实际上是为p所指的对象赋值 空指针int *p1 = nullptr; int *p2 = 0; int *p3 = NULL; // 需要头文件cstdlib void*指针用于存放任意对象的地址，不能直接操作void*指针所指的对象 指向指针的指针指向指针的引用指针是对象，所以存在对指针的引用 int i = 42; int *p; int *&amp;r = p; // r是一个对p的引用 r = &amp;i; // r引用了一个指针，因此给r赋值&amp;就是令p指向i *r = 0; // 将i的值改为0 2. const限定符值不能被改变，所以const对象必须被初始化 const int bufSize = 512; // 输入缓冲区大小 如果要在多个文件之间共享const，必须在变量定义前加extern关键字 2.1 对const的引用对常量的引用，不能够修改其绑定的对象 对const的引用可以使一个并非const的对象，但是不能通过其改变值 const int ci = 1024; const int &amp;r1 = ci; // 正确 r1 = 42; // 错误：r1是对常量的引用 int &amp;r2 = ci; // 错误：非常量引用指向一个常量对象 int i = 42； const int &amp;r1 = i; // 允许将const int&amp;绑定到一个普通的int上 r1 = 10; // 错误 3. 处理类型3.1 类型别名某种类型的同义词，使得复杂的类型名字变得简单，易于理解和使用。 typedef double wages; // wages是double的同义词 using SI = Sales_item; // SI是Sales_item的同义词 3.2 auto类型说明符让编译器分析表达式所属的类型，必须有初始值 auto item = val1 + val2; // 由val1和val2相加的结果推断item的类型 // auto一条声明语句只能有一个基础数据类型 auto i = 0, *p = &amp;i; // 正确 auto sz = 0, pi = 3.14; // 错误，sz和pi的类型不一致 4. 自定义数据结构将一组相关的数据元素组织起来然后使用他们的策略和方法 struct Sales_data &#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0; &#125; Sales_data accum;","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]},{"title":"使用Github pages+Hexo 搭建个人博客","slug":"使用Github-pages-Hexo-搭建个人博客","date":"2020-04-01T17:56:42.000Z","updated":"2020-09-03T15:05:19.386Z","comments":true,"path":"posts/ae6c038e.html","link":"","permalink":"https://zhouzhuyan.com/posts/ae6c038e.html","excerpt":"Github pages + Hexo 搭建个人博客2019年11月19日，我决定开始写博客，首先要用github pages+hexo搭建一个个人博客，其中的过程我就记录在这里面。","text":"Github pages + Hexo 搭建个人博客2019年11月19日，我决定开始写博客，首先要用github pages+hexo搭建一个个人博客，其中的过程我就记录在这里面。 准备工作 注册一个 GitHub 账户 安装 Node.js下载链接 https://nodejs.org/en/download/ 下面这个是中文网，对于国内用户来说下载速度非常快。 http://nodejs.cn/download/ 推荐菜鸟教程关于node的安装教程以及简易的语法介绍https://www.runoob.com/nodejs/nodejs-install-setup.html 安装git markdown语法学习https://www.jianshu.com/p/191d1e21f7ed git语法学习推荐廖雪峰的git教程https://www.liaoxuefeng.com/wiki/896043488029600 安装在终端检查node和npm的版本情况 node -v npm -v 然后输入命令安装hexo npm install -g hexo-cli 我使用的是Mac电脑，在这一步出现了问题，终端显示如下 rollbackFailedOptional verb npm-session 然后我又等了一会儿，终端又报错了。 npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules npm ERR! code EACCES npm ERR! syscall access npm ERR! path /usr/local/lib/node_modules npm ERR! errno -13 npm ERR! Error: EACCES: permission denied, access '/usr/local/lib/node_modules' npm ERR! [Error: EACCES: permission denied, access '/usr/local/lib/node_modules'] &#123; npm ERR! stack: \"Error: EACCES: permission denied, access '/usr/local/lib/node_modules'\", npm ERR! errno: -13, npm ERR! code: 'EACCES', npm ERR! syscall: 'access', npm ERR! path: '/usr/local/lib/node_modules' npm ERR! &#125; npm ERR! npm ERR! The operation was rejected by your operating system. npm ERR! It is likely you do not have the permissions to access this file as the current user npm ERR! npm ERR! If you believe this might be a permissions issue, please double-check the npm ERR! permissions of the file and its containing directories, or try running npm ERR! the command again as root/Administrator. 根据官方文档，如果在尝试安装 Hexo 的过程中出现 EACCES权限错误，要遵循由npmjs发布的指导修复该问题。强烈建议不要使用 root、sudo 等方法覆盖权限。根据要求，下载了nvm，并且在终端利用nvm下载了最新版本的node和更新了npm后，hexo下载成功了。（以下是下载和使用nvm的教程链接）https://github.com/nvm-sh/nvm. 建站输入以下命令hexo就会出现在指定的文件夹中 hexo init &lt;folder&gt; cd &lt;folder&gt; npm install 如果出现错误 -bash: syntax error near unexpected token `newline' 这是占位符的问题，将第一行命令的&lt;&gt;去除，再重新输入即可。 到此，建站的基本操作就完成了。 界面的设计等就可以由自己来操作了。放一个hexo的官方网站供大家参考。https://hexo.io/zh-cn/docs/configuration 创建Github远程仓库注意仓库名为github的用户名.github.io，勾选readme 创建之后，进入仓库，点击Settings按钮，然后翻到GitHub Pages的部分，点击网页链接，就能够看到一个简易的网页了。 部署hexo进入本地的hexo文件，找到 _config.yml，打开后翻到最后，修改成 deploy: type: git repo: gitHub: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git branch: master repo后面的内容要修改成自己github仓库的SSH密匙。 然后在终端中输入 npm install hexo-deployer-git --save 开始安装hexo-deploy-git，安装完成后，开始部署，在终端中输入 hexo deploy 部署完成。 测试这个时候，再次进入刚刚进入过的网页链接，就会看到一个船新版本的界面，也就是本地的hexo库已经部署到github上了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"Hexo写作","slug":"Hexo写作","date":"2020-04-01T15:58:14.000Z","updated":"2020-09-03T15:05:25.861Z","comments":true,"path":"posts/c4064b2b.html","link":"","permalink":"https://zhouzhuyan.com/posts/c4064b2b.html","excerpt":"Hexo写作本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。","text":"Hexo写作本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。 1. Hexo基本命令hexo g = hexo generate #生成 hexo s = hexo server #启动本地预览 hexo d = hexo deploy #远程部署 hexo n \"文章标题\" = hexo new \"文章标题\" #新建一篇博文 2. 整体配置\\hexo\\_config.yml # Site title: # 网站名，标签页显示 subtitle: # 副标题，网站名下显示 description: # 网站描述，便于搜索 keywords: author: # 作者 language: zh-CN # 中文 timezone: Asia/Shanghai # 时区 3. 更换主题推荐使用melody hexo-theme-melody快速开始) 这个主题就是我现在网站使用的主题，它有完整的中文教程，功能齐全。按照教程配置就可以了。 4. 写作步骤 新建文章 hexo new \"title\" 写作 \\hexo\\source\\_post中找到title.md，使用typora打开 注意文章的tags格式是[] 在信息栏填写top_img信息可以自定义该页图片情况，如false表示不显示 文章中&lt;!-- more --&gt;之前的部分会显示在主页上，并出现Read more按钮，点击阅读更多内容 预览 hexo s hexo s --debug // 在命令行生成debug信息 同步到远程 hexo d -g 5. 问题 Template render error: (unknown path) 在命令行输入hexo -g后报错，原因在于文章内容中有{}时，如果它没有被代码块包括，解析会出现错误，所以需要写成 &#123;% raw %&#125; 本地预览与远程显示不一致 删除缓存 hexo clean 在网页上刷新","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"}]},{"title":"C++基本语法","slug":"学习cpp","date":"2020-01-27T03:49:27.000Z","updated":"2020-09-08T08:14:54.979Z","comments":true,"path":"posts/6b599344.html","link":"","permalink":"https://zhouzhuyan.com/posts/6b599344.html","excerpt":"C++学习笔记本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。","text":"C++学习笔记本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。 一、 变量1. 用sizeof运算符求某一类型或变量占据的字节数#include&lt;iostream&gt; using namespace std; int main() &#123; int a; cout &lt;&lt; sizeof(a) &lt;&lt; endl; // sizeof运算符可以求变量占据的字节数 cout &lt;&lt; a &lt;&lt; endl; // 未初始化的变量，其值是不确定的 int b = 1; cout &lt;&lt; b &lt;&lt; endl; &#125; 2. 数据类型的自动转换1. 数int a = 11.34; // 11.34被自动转化为11后赋值给a int b = 30; double d = b; // d的值是30.0 2. 字符类型与整型int k = 'a'; printf(\"%d\", k); // 输出97，即a的ASCII码 int n = 98; char k = n; printf(\"%c\", k); // 输出b 3. 输入和输出1. scanf和printf#include&lt;iostream&gt; #include&lt;cstdio&gt; //使用scanf和printf时需要使用该库 int main() &#123; int n; char c; float m; scanf(\"%d%c%f\", &amp;n, &amp;c, &amp;m); printf(\"%d %c %f\\n\", n, c, m); return 0; &#125; 用scanf可以一次读入多个不同类型的变量，输入各项用空格隔开 注意在输入字符时，不会跳过空格（空格也会被当做字符读入） 输入其它数据时，会跳过空格 2. cin和cout#include&lt;iostream&gt; using namespace std; int main() &#123; int c; while ((c=cin.get()) != EOF) &#123; cout &lt;&lt; (char) c; &#125; return 0; &#125; 使用cin读入所有字符，包括空格和回车，EOF Mac（ctrl+D停止输入，ctrl+C停止程序) windows ctrl+Z停止 3. cin&amp;cout / scanf&amp;printf 比较 cin，cout速度慢，输入输出数据量大时用scanf/printf 一个程序不要同时出现cin和scanf，cout和prinf 4. 运算 加、减、乘运算的溢出 二、函数1. 数组作为函数的参数传递数组作为函数的参数时，是传引用的，即形参数组改变了，实参数组也会改变 二维数组作为函数的形参时，必须写明函数有多少列，不要写明有多少行 void PrintArray(int a[][5]) &#123; cout &lt;&lt; a[4][3]; &#125; 必须要写明列数，编译器才能够根据下标算出元素的地址 $\\color&#123;#F00&#125;&#123;a[i][j]的地址 = 数组首地址 + i \\times N \\times sizeof(a[0][0]) + j \\times sizeof(a[0][0])&#125;$ (N是数组列数) 形参数组的首地址就是实参数组的首地址 三、字符串1. 字符串的形式（1）字符串常量用双引号括起来的，如”China”, “C++ program”. 字符串常量占据内存的字节数等于字符中字符数目加1，结尾多出字符’\\0’. 但是字符串的长度不包含'\\0' “”也是合法的·1字符串常量，称为空串，仍然占据一个字节的内存空间，存放’\\0’ （2）存放于字符数组中，以’\\0’结尾用一维char数组存放字符串，结尾是’\\0’，数组元素个数至少为字符串长度+1。 用cin、scanf将字符串读入字符数组时，会自动在字符数组中字符串的末尾加上’\\0’。 （3）string对象。string是C++标准模板库里的一个类，专门用于处理字符串","categories":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/categories/Java/"},{"name":"面向对象","slug":"Java/面向对象","permalink":"https://zhouzhuyan.com/categories/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zhouzhuyan.com/categories/Hexo/"},{"name":"设计模式","slug":"设计模式","permalink":"https://zhouzhuyan.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"数据科学","slug":"数据科学","permalink":"https://zhouzhuyan.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/categories/C/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://zhouzhuyan.com/tags/%E9%80%92%E5%BD%92/"},{"name":"Java","slug":"Java","permalink":"https://zhouzhuyan.com/tags/Java/"},{"name":"hexo","slug":"hexo","permalink":"https://zhouzhuyan.com/tags/hexo/"},{"name":"策略模式","slug":"策略模式","permalink":"https://zhouzhuyan.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"概率论","slug":"概率论","permalink":"https://zhouzhuyan.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"C++","slug":"C","permalink":"https://zhouzhuyan.com/tags/C/"}]}