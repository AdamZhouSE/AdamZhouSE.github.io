<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 接口</title>
    <link href="/posts/d993c7e9.html"/>
    <url>/posts/d993c7e9.html</url>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><strong>接口</strong>(<em>interface</em>)用来描述类应该做什么，而不指定它们具体该如何做。一个类可以<strong>实现</strong>(<em>implement</em>)一个或多个接口。</p><h2 id="1-接口的概念"><a href="#1-接口的概念" class="headerlink" title="1. 接口的概念"></a>1. 接口的概念</h2><p>接口不是类，而是对希望符合这个接口的类的一组<strong>需求</strong></p><p><strong>Tip</strong></p><ul><li>接口中的所有方法都自动是<code>public</code>，因此在接口中声明方法时，不必提供关键字<code>public</code></li><li>接口绝不会有实例字段</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-title">implement</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Employee</span>&gt; </span>&#123;    <span class="hljs-comment">// blablabla</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Employee other)</span> </span>&#123;        <span class="hljs-keyword">return</span> Integer.compare(salary, other.salary);    &#125;&#125;</code></pre></div><h2 id="2-接口的属性"><a href="#2-接口的属性" class="headerlink" title="2. 接口的属性"></a>2. 接口的属性</h2><p>接口不是类，不能够使用<code>new</code>实例化一个接口，但是可以声明接口的变量，接口变量必须引用实现这个接口的类对象</p><div class="hljs"><pre><code class="hljs java">Comparable x = <span class="hljs-keyword">new</span> Employee(. . .);</code></pre></div><p><strong>Tip</strong><br>为什么需要接口，而不是直接使用抽象类？<br>因为Java不支持多继承，所以每个类只能扩展一个类。<br>而接口提供了多继承的好处，而避免了多重继承的复杂性和低效性。</p><h2 id="3-接口与回调"><a href="#3-接口与回调" class="headerlink" title="3. 接口与回调"></a>3. 接口与回调</h2><p><strong>回调</strong>(<em>callback</em>)是一种常见的程序设计模式。在这种模式中，可以指定某个特定事件发生时应该采取的动作。比如我们设计了一个时钟，可以请求每秒更新一次，以便更新时钟的表盘。</p><p>下面是一个定时器和动作监听的具体使用的例子，定时器启动之后，程序将弹出一个消息对话框，并等待用户点击OK来终止程序的运行，在程序等待用户操作的同时，每隔1秒显示一次当前时间</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<span class="hljs-keyword">import</span> java.awt.event.*;<span class="hljs-keyword">import</span> java.time.*;<span class="hljs-keyword">import</span> javax.swing.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerTest</span></span>&#123;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>   </span>&#123;        TimePrinter listener = <span class="hljs-keyword">new</span> TimePrinter();      <span class="hljs-comment">// construct a timer that calls the listener</span>      <span class="hljs-comment">// once every second</span>      Timer timer = <span class="hljs-keyword">new</span> Timer(<span class="hljs-number">1000</span>, listener);      timer.start();      <span class="hljs-comment">// keep program running until the user selects "OK"</span>      JOptionPane.showMessageDialog(<span class="hljs-keyword">null</span>, <span class="hljs-string">"Quit program?"</span>);      System.exit(<span class="hljs-number">0</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimePrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ActionListener</span></span>&#123;     <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent event)</span>   </span>&#123;        System.out.println(<span class="hljs-string">"At the tone, the time is "</span>          + Instant.ofEpochMilli(event.getWhen()));      Toolkit.getDefaultToolkit().beep();   &#125;&#125;</code></pre></div><h2 id="4-Comparator接口"><a href="#4-Comparator接口" class="headerlink" title="4. Comparator接口"></a>4. Comparator接口</h2><p>如果我们想要对字符串数组进行排序，可以直接使用<code>String.compareTo</code>方法按字典顺序比较字符串。<br>如果我们希望按照字符串长度来进行比较，可以自己实现一个<strong>比较器</strong>(<em>comparator</em>)，如下面的例子中，将比较器作为参数传入<code>Arrays.sort</code>方法中。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.Comparator;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LengthCompare</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String[] friends = &#123;<span class="hljs-string">"Adam"</span>, <span class="hljs-string">"Ben"</span>, <span class="hljs-string">"Peter"</span>, <span class="hljs-string">"Noah"</span>&#125;;        Arrays.sort(friends, <span class="hljs-keyword">new</span> LengthComparator());        System.out.println(Arrays.toString(friends));    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LengthComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;        <span class="hljs-keyword">return</span> o1.length() - o2.length();    &#125;&#125;</code></pre></div><p>参考：</p><ol><li>《Java核心技术 卷I》</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>面向对象</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 继承</title>
    <link href="/posts/8b3a0e63.html"/>
    <url>/posts/8b3a0e63.html</url>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承(inheritance)的基本思想是基于已经有的类创建新的类，复用这些类的方法。</p><h2 id="一、类，超类和子类"><a href="#一、类，超类和子类" class="headerlink" title="一、类，超类和子类"></a>一、类，超类和子类</h2><p>在前面的文章中我们实现了一个<code>Employee</code>类，假设你在某个公司工作，这个公司的经理和员工的待遇不一样，普通员工在完成任务后仅领取薪水，而经理还拥有奖金。<br>这个时候，我们可以定义一个新类<code>Manager</code>，使用继承重用<code>Employee</code>中的代码，同时定义新的方法来增加奖金这一功能。</p><p><strong>Tip</strong><br><code>Manager</code> <strong>is-a</strong> <code>Employee</code><br><strong>is-a</strong>关系是继承的一个明显特征</p><h3 id="1-定义子类"><a href="#1-定义子类" class="headerlink" title="1. 定义子类"></a>1. 定义子类</h3><p>使用<code>extends</code>关键字来表示继承</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-comment">// blablabla</span>&#125;</code></pre></div><p>关键字<code>extends</code>表明正在构造的新类派生于一个已经存在的类。这个类被称为<strong>超类</strong>(<em>superclass</em>) 或<strong>父类</strong>(<em>parent class</em>)，新类称为<strong>子类</strong>(<em>subclass</em>)<br>在设计类时，应该将一般方法放在超类中，将更特殊的方法放在子类中<br>比如我们在<code>Manager</code>类中应该实现一个设置奖金金额的方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bonus;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBonus</span><span class="hljs-params">(<span class="hljs-keyword">double</span> bonus)</span> </span>&#123;        <span class="hljs-keyword">this</span>.bonus = bonus;    &#125;&#125;</code></pre></div><h3 id="2-覆盖方法"><a href="#2-覆盖方法" class="headerlink" title="2. 覆盖方法"></a>2. 覆盖方法</h3><p>超类中的某些方法对子类不一定适用，比如<code>Manager</code>类中的<code>getSalary</code>方法应该返回薪水和奖金的总和，所以要提供一个新的方法来<strong>覆盖</strong>(<em>override</em>)超类中的某个方法。<br>要注意的是，<code>Manager</code>类的<code>getSalary</code>方法不能够直接访问<code>salary</code>字段，因为其实<code>Employee</code>类的私有字段，所以需要使用<code>super</code>关键字</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> baseSalary = <span class="hljs-keyword">super</span>.getSalary();    <span class="hljs-keyword">return</span> baseSalary + bonus;&#125;</code></pre></div><h3 id="3-子类构造器"><a href="#3-子类构造器" class="headerlink" title="3. 子类构造器"></a>3. 子类构造器</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> salary)</span> </span>&#123;    <span class="hljs-keyword">super</span>(id, name, salary);    bonus = <span class="hljs-number">0</span>;&#125;</code></pre></div><p>语句<code>super(id, name, salary);</code>实现了对<code>Employee</code>中私有字段的调用</p><h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4. 多态"></a>4. 多态</h3><p>我们可以通过<code>is-a</code>来判断是否将数据设计为继承关系，它的另外一种表述是<strong>替换原则</strong>，即程序中出现超类对象的任何地方都可以使用子类对象替换。</p><p>在Java中，对象变量时<strong>多态</strong>(<em>polymophic</em>)的。<br>一个<code>Employee</code>类型的变量既可以引用一个<code>Employee</code>类型的对象,也可以引用<code>Employee</code>类的任何一个子类的对象(比如<code>Manager</code>)</p><div class="hljs"><pre><code class="hljs java">Employee e;e = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1</span>, <span class="hljs-string">"A"</span>, <span class="hljs-number">10000</span>);e = <span class="hljs-keyword">new</span> Manager(<span class="hljs-number">2</span>, <span class="hljs-string">"B"</span>, <span class="hljs-number">20000</span>);</code></pre></div><p>虽然这里的<code>e</code>引用了<code>Manager</code>类型的对象，但是编译器只将<code>e</code>看成是一个<code>Employee</code>对象，所以如下的调用是错误的。</p><div class="hljs"><pre><code class="hljs java">e.setBonus(<span class="hljs-number">10000</span>); <span class="hljs-comment">// ERROR</span></code></pre></div><h3 id="5-阻止继承-final类和方法"><a href="#5-阻止继承-final类和方法" class="headerlink" title="5. 阻止继承: final类和方法"></a>5. 阻止继承: final类和方法</h3><p>如果我们需要阻止某个类被继承，可以使用<code>final</code>关键字</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;    <span class="hljs-comment">// blablabla</span>&#125;</code></pre></div><p>类中的某个特定的方法也可以声明为<code>final</code>，这样子类就不能够覆盖这个方法。</p><p><strong>Tip</strong><br>为什么要将类或方法声明为<code>final</code>？<br>确保它们不会在子类中改变语义。比如<code>String</code>类是<code>final</code>类，所以一个<code>String</code>引用引用的一定是<code>String</code>对象，而不是其它。</p><h3 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6. 抽象类"></a>6. 抽象类</h3><p>在继承层次结构中，位于上层的类更具有一般性<br>比如我们加入<code>Person</code>类和<code>Student</code>类，下图是这三个类之间的继承关系</p><p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200908-02.png" srcset="/img/loading.gif" alt=""></p><p>每个人都有一些属性，比如姓名，年龄，引入一个公共的超类，就可以把<code>getName</code>方法放在继承层次结构中的更高一层，使用<code>abstract</code>关键字来定义抽象类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span> <span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre></div><p>抽象类不能够实例化，如下的表达式是错误的</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Person(); <span class="hljs-comment">// ERROR</span></code></pre></div><h2 id="二、对象包装器与自动装箱"><a href="#二、对象包装器与自动装箱" class="headerlink" title="二、对象包装器与自动装箱"></a>二、对象包装器与自动装箱</h2><p>所有的基本类型都有一个与之对应的类，这些类被称为<strong>包装器</strong>(<em>wrapper</em>)，分别是<code>Integer, Long, Float, Double, Short, Byte, Character, Boolean</code>。<br>包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值，同时，包装器还是<code>final</code>，不能够派生它们的子类。</p><p><strong>Tip</strong><br>为什么需要包装类？<br>因为Java是一种面向对象程序设计语言，很多地方需要使用对象而不是基本类型。比如在<code>ArrayList</code>中，我们不能够写成<code>ArrayList&lt;int&gt;</code>，而要写成<code>ArrayList&lt;Integer&gt;</code>。</p><h3 id="2-自动拆箱与装箱"><a href="#2-自动拆箱与装箱" class="headerlink" title="2. 自动拆箱与装箱"></a>2. 自动拆箱与装箱</h3><p>自动装箱: 就是将基本数据类型自动转换成对应的包装类。<br>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</p><div class="hljs"><pre><code class="hljs java">Integer n = <span class="hljs-number">3</span>; <span class="hljs-comment">// 自动装箱</span><span class="hljs-keyword">int</span> m = n; <span class="hljs-comment">// 自动拆箱</span></code></pre></div><h2 id="三、继承的设计技巧"><a href="#三、继承的设计技巧" class="headerlink" title="三、继承的设计技巧"></a>三、继承的设计技巧</h2><ol><li>将公共操作和字段放在超类中</li><li>使用继承实现<strong>is-a</strong>关系</li><li>除非所有继承的方法都有意义，否则不要使用继承</li><li>在覆盖方法时，不要改变预期的行为</li><li>使用多态，而不要使用类型信息</li></ol><p>参考：</p><ol><li><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/boxing-unboxing" target="_blank" rel="noopener">Java工程师成神之路</a></li><li>《Java核心技术 卷I》</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>面向对象</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 面向对象概述</title>
    <link href="/posts/e27767b2.html"/>
    <url>/posts/e27767b2.html</url>
    
    <content type="html"><![CDATA[<h1 id="对象与类概述"><a href="#对象与类概述" class="headerlink" title="对象与类概述"></a>对象与类概述</h1><h2 id="一、面向对象程序设计概述"><a href="#一、面向对象程序设计概述" class="headerlink" title="一、面向对象程序设计概述"></a>一、面向对象程序设计概述</h2><p>结构化程序：算法+数据结构 = 程序 </p><p>（即确定如何操作数据，再决定如何组织数据的结构）</p><p>面向对象程序设计(OOP)：将数据放在第一位，再考虑操作数据的算法</p><h3 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h3><ol><li><p><strong>类(class)</strong>是构造对象的模板或<strong>蓝图</strong>，就好像一个制作某件工艺品的模具，对象就是工艺品</p></li><li><p>由类构造(construct)对象的过程称为创建类的<strong>实例(instance)</strong></p></li><li><p><strong>封装(encapsulation)</strong>将<strong>数据</strong>和<strong>行为</strong>组合在一个包中，对对象的使用者隐藏具体的实现方式，也称为<strong>数据隐藏</strong></p></li><li><p>对象中的数据称为<strong>实例字段(instance field)</strong>，操作数据的过程称为<strong>方法(method)</strong></p></li><li><p>对象拥有的实例字段值的集合就是这个对象的当前<strong>状态(state)</strong></p></li><li>程序只能通过对象的方法和对象数据进行交互，对象被赋予了“黑盒”的特征，提高了重用性和可靠性</li><li>可以通过扩展一个类来构建新的类，这使得用户自定义类更加容易。在Java中，所有类都来自于一个<strong>超类</strong>，即<code>Object</code>。</li><li>通过扩展一个类来建立一个新的类的过程就是<strong>继承(inheritance)</strong>，新类具有被扩展的类的全部属性和方法，可以自定义新的属性和方法。</li></ol><h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><p>对象的3个特性：</p><ul><li><strong>行为(behavior)</strong>——可以对对象完成的操作（应用的方法）</li><li><strong>状态(state)</strong>——描述当前状况的信息，状态的改变必须通过调用方法实现</li><li><strong>标识(identity)</strong>——每个对象有唯一的标识来区分（如两个订单的编号肯定不相同）</li></ul><h3 id="3-识别类"><a href="#3-识别类" class="headerlink" title="3. 识别类"></a>3. 识别类</h3><p>编写程序从<strong>识别类</strong>开始，然后为各个类添加方法。</p><p>一个简单的方法是在分析问题的过程中寻找<strong>名词——类</strong>，寻找<strong>动词——方法</strong></p><p>例如我们有商品，订单，账户这样的名词作为类，即Item，Order，Account</p><p>那么在账户这个类中，就可以有增加账户，修改账户等方法。</p><h3 id="4-类之间的关系"><a href="#4-类之间的关系" class="headerlink" title="4. 类之间的关系"></a>4. 类之间的关系</h3><p>类之间最常见的关系有：</p><ul><li><strong>依赖</strong>（”<em>uses-a</em>“）</li><li><strong>聚合</strong> （”<em>has-a</em>“）</li><li><strong>继承</strong>（<em>“is-a”</em>)</li></ul><h4 id="4-1-依赖（dependence）"><a href="#4-1-依赖（dependence）" class="headerlink" title="4.1 依赖（dependence）"></a>4.1 依赖（dependence）</h4><p>如果一个类的方法使用或操纵另一个类的对象，我们就可以说一个类依赖于另一个类</p><p>比如Order对象访问Account对象查看信用状态，这就是一个使用(“uses-a”)的关系。</p><p>（尽可能减少相互依赖的类，做到低耦合）</p><h4 id="4-2-聚合（aggregation）"><a href="#4-2-聚合（aggregation）" class="headerlink" title="4.2 聚合（aggregation）"></a>4.2 聚合（aggregation）</h4><p>类A的对象包含（”has-a”）类B的对象</p><p>如一个Order对象就包含了一些Item对象</p><h4 id="4-3-继承（inheritance）"><a href="#4-3-继承（inheritance）" class="headerlink" title="4.3 继承（inheritance）"></a>4.3 继承（inheritance）</h4><p>一个更特殊的类与一个更一般的类之间的关系</p><p>也就是前面提到的扩展，比如现在我们定义一个加急订单RushOrder类，那么它是一个（”is-a”)Order类</p><p>也就是有Order类继承而来。</p><p>下图展示了上述的三种关系。<br><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200423LearnJava01.png" srcset="/img/loading.gif" alt=""></p><h2 id="二、使用预定义类"><a href="#二、使用预定义类" class="headerlink" title="二、使用预定义类"></a>二、使用预定义类</h2><p>我们通过可以Java中的预定于类来了解如何构造对象，以及如何使用类的方法。<br>如下的例子：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Date birthday = <span class="hljs-keyword">new</span> Date();        System.out.println(birthday.toString());    &#125;&#125;</code></pre></div><p>在Java中，要使用构造器(constructor)来构造新的实例，比如上面的代码中<code>new Date()</code>就构造了一个新的对象，这个对象被初始化为当前的日期和时间。</p><p><strong>Tip</strong><br>需要注意的是，单独的定义<code>Date birthday</code>中的<code>birthday</code>并不是对象，对它进行操作编译器会报错。一定要<strong>初始化</strong>变量<code>birthday</code>。<br>对象变量本身并不包含一个对象，而是<strong>引用</strong>一个对象，<code>new</code>操作符的返回值也是一个引用。</p><h2 id="三、自定义类"><a href="#三、自定义类" class="headerlink" title="三、自定义类"></a>三、自定义类</h2><h3 id="1-对象与对象变量"><a href="#1-对象与对象变量" class="headerlink" title="1. 对象与对象变量"></a>1. 对象与对象变量</h3><p>要想使用对象，就需要先构造对象，并指定其初始状态。在Java中，使用构造器（构造函数）来构造。</p><p>比如某公司有一个职员管理系统，其中有一个关于职员信息的类<em>Employee</em></p><p>那么我们可以通过下面这个表达式构造一个新对象</p><div class="hljs"><pre><code class="hljs java">Employee employee = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1</span>, <span class="hljs-string">"Allen"</span>, <span class="hljs-number">10000</span>);</code></pre></div><p>其中<code>employee</code>是一个<strong>对象变量</strong>，我们用<code>new Employee(int id, String name, int salary)</code>构造了一个新对象，初始化该对象变量，要注意的是对象变量并没有包含一个对象，而是<strong>引用</strong>一个对象。</p><p>在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> salary;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> salary)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.salary = salary;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> salary;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Employee[] staff = <span class="hljs-keyword">new</span> Employee[<span class="hljs-number">3</span>];        staff[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1</span>, <span class="hljs-string">"Allen"</span>, <span class="hljs-number">10000</span>);        staff[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">2</span>, <span class="hljs-string">"Ben"</span>, <span class="hljs-number">12000</span>);        staff[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">3</span>, <span class="hljs-string">"David"</span>, <span class="hljs-number">15000</span>);        <span class="hljs-keyword">for</span> (Employee e : staff) &#123;            System.out.println(<span class="hljs-string">"id="</span> + e.getId() + <span class="hljs-string">",name="</span> + e.getName() + <span class="hljs-string">",salary="</span> + e.getSalary());        &#125;    &#125;&#125;<span class="hljs-comment">/**Output:id=1,name=Allen,salary=10000id=2,name=Ben,salary=12000id=3,name=David,salary=15000*/</span></code></pre></div><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><p>构造函数，与类同名，将实例初始化为指定的初始状态</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> salary)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.salary = salary;    &#125;</code></pre></div><p><strong>Tip</strong></p><ul><li>构造函数根据参数的不同可以有多个，</li><li>构造函数没有返回值。</li></ul><h3 id="4-封装的优点"><a href="#4-封装的优点" class="headerlink" title="4. 封装的优点"></a>4. 封装的优点</h3><p>如下是一个访问器方法，又称为<strong>字段访问器</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;</code></pre></div><p><strong>Tip</strong><br>为什么不直接将这些变量设为public公共访问呢？<br>因为这样的话这些变量就可以轻易的被外界修改，受到破坏<br>比如这里的职员id应该是只读的，不能够设置为public被外界随意更改。</p><h3 id="4-final"><a href="#4-final" class="headerlink" title="4. final"></a>4. final</h3><p>定义为final的实例字段必须在构造对象时<strong>初始化</strong>，否则编辑器会报错，顾名思义，<code>final</code>表示最终的，在初始化之后不能够再修改这个值。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name = <span class="hljs-string">"John"</span>;</code></pre></div><p><strong>Tip</strong><br><code>final</code>修饰符对于基本类型和不可变类，如String类适用，但是对于可变的类，如<code>StringBuilder</code>就会出现问题，因为它仅仅保证了引用不会指向另外一个对象，但是这个对象是可以更改的。</p><h2 id="四、静态字段和静态方法"><a href="#四、静态字段和静态方法" class="headerlink" title="四、静态字段和静态方法"></a>四、静态字段和静态方法</h2><h3 id="1-静态字段"><a href="#1-静态字段" class="headerlink" title="1. 静态字段"></a>1. 静态字段</h3><p>回到我们之前的<code>Employee</code>类中，如果我们需要一个变量来记录公司有多少雇员，就可以使用<code>static</code>修饰符，定义一个静态变量</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;</code></pre></div><p>静态变量是属于类的变量，而不属于单个对象，对于<code>Employee</code>类的所有实例，共享一个<code>count</code>。<br>而对非静态的变量，每个对象都有一个自己的副本</p><h3 id="2-静态常量"><a href="#2-静态常量" class="headerlink" title="2. 静态常量"></a>2. 静态常量</h3><p><code>Math</code>类中定义了一个静态常量<code>PI</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">3.1415926535897932846</span>;&#125;</code></pre></div><p>我们可以通过<code>Math.PI</code>来直接访问它，如果没有<code>static</code>，那么就需要创建<code>Math</code>类的对象来访问它，效率比较低。</p><h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h3><p>如果我们想要知道公司的雇员人数，就可以使用静态方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 返回静态变量</span>    <span class="hljs-keyword">return</span> count; &#125;</code></pre></div><p>使用静态方法的两种情况：</p><ul><li>方法不需要访问对象状态</li><li>方法只需要访问类的静态字段（比如上面的例子）</li></ul><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>面向对象</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo部署到云服务器</title>
    <link href="/posts/e80e623c.html"/>
    <url>/posts/e80e623c.html</url>
    
    <content type="html"><![CDATA[<h3 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h3><p>博客的搭建和域名的绑定可以参考我以前的博客。<br><a href="https://zhouzhuyan.com/posts/ae6c038e.html">使用Github pages + Hexo搭建个人博客</a><br><a href="https://zhouzhuyan.com/posts/2cd2c226.html">Hexo个人博客绑定域名</a></p><p>由于博客是基于Github pages搭建的，所以在国内的访问速度比较慢，可以部署到云服务器上加快访问的速度，我使用的是<a href="https://cloud.tencent.com/act/campus" target="_blank" rel="noopener">腾讯云学生机</a>。注意在国内使用云服务器部署网站需要对网站进行备案，详细步骤可以参考腾讯的<a href="https://cloud.tencent.com/document/product/243" target="_blank" rel="noopener">官方文档</a>。在备案完成后，就可以进行网站的部署了。</p><h3 id="1-配置git"><a href="#1-配置git" class="headerlink" title="1.  配置git"></a>1.  配置git</h3><p><strong>Tip</strong><br>我的服务器型号是<code>CentOS 7.5</code></p><h4 id="1-1-安装git"><a href="#1-1-安装git" class="headerlink" title="1.1 安装git"></a>1.1 安装git</h4><div class="hljs"><pre><code class="hljs shell">yum install -y git</code></pre></div><p>看到complete字样说明安装完成了，可以通过如下命令验证</p><div class="hljs"><pre><code class="hljs shell">git --version</code></pre></div><p>出现版本则说明安装成功。</p><h4 id="1-2-创建git账户"><a href="#1-2-创建git账户" class="headerlink" title="1.2 创建git账户"></a>1.2 创建git账户</h4><div class="hljs"><pre><code class="hljs shell">adduser gitpasswd git</code></pre></div><p>注意一定要有第二步<code>passwd git</code>，这是给git账户设置密码，否则账户不会使用。</p><h4 id="1-3-设置免密登录git"><a href="#1-3-设置免密登录git" class="headerlink" title="1.3 设置免密登录git"></a>1.3 设置免密登录git</h4><p>使用<code>su</code>命令切换至git用户，并进入用户git的根目录</p><div class="hljs"><pre><code class="hljs shell">su gitcd</code></pre></div><p>创建<code>~/.ssh</code>文件夹和<code>~/.ssh/authorized_keys</code>文件</p><div class="hljs"><pre><code class="hljs shell">mkdir ~/.sshtouch ~/.ssh/authorized_keys</code></pre></div><p>将本地的<code>id_rsa.pub</code>文件中的公匙复制到<code>authorized_keys</code>文件中，在mac中，该文件的地址是<code>/Users/你的用户名/.ssh/id_rsa.pub</code>，可以在终端中使用如下命令打开<code>.ssh</code>文件夹，然后使用vs code打开该文件</p><div class="hljs"><pre><code class="hljs shell">open /Users/galahad/.ssh</code></pre></div><p>复制其中的内容，然后打开<code>authorized_keys</code>文件</p><div class="hljs"><pre><code class="hljs shell">vi ~/.ssh/authorized_keys</code></pre></div><p>按<code>i</code>进入插入模式，复制内容<br>按<code>esc</code>键进入命令模式，输入<code>:wq</code>保存并退出<br>最后对文件赋予对应的权限</p><div class="hljs"><pre><code class="hljs shell">chmod 600 /home/git/.ssh/authorized_keyschmod 700 /home/git/.ssh</code></pre></div><p>这样就可以使得本地终端可以免密登录git用户，可以在本地终端使用ssh远程连接测试</p><div class="hljs"><pre><code class="hljs shell">ssh git@你的IP</code></pre></div><p>如果仍需输入密码，那说明配置有问题，可以重新按照1.3的步骤再配置一遍，当然，1.3的部分不是必须的，这只是为了在本地提交文件到服务器的时候不用输入密码，省点儿力气。</p><h4 id="1-4-配置git仓库"><a href="#1-4-配置git仓库" class="headerlink" title="1.4 配置git仓库"></a>1.4 配置git仓库</h4><p>在git用户的根目录下创建hexo存储的目录</p><div class="hljs"><pre><code class="hljs shell">mkdir -p projects/blog</code></pre></div><p>再创建一个git仓库，并初始化一个仓库</p><div class="hljs"><pre><code class="hljs shell">mkdir reposcd reposgit init --bare blog.git</code></pre></div><p>之后，在<code>blog.git</code>文件夹下会产生一个<code>hooks</code>文件夹，在其中创建一个文件<code>post-receive</code>，在其中配置一个钩子</p><div class="hljs"><pre><code class="hljs shell">cd blog.git/hooksvi post-receive</code></pre></div><p>将如下内容复制到其中</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span>git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f</code></pre></div><p>保存退出之后，赋予文件可执行权限</p><div class="hljs"><pre><code class="hljs shell">chmod +x post-receive</code></pre></div><p>然后输入<code>exit</code>回到<code>root</code>用户下，输入如下命令</p><div class="hljs"><pre><code class="hljs shell">chown -R git:git /home/git/repos/blog.git</code></pre></div><p>配置完仓库后，可以在本地使用<code>git clone</code>命令测试是否能够成功克隆仓库</p><div class="hljs"><pre><code class="hljs shell">git clone git@server_ip:/home/git/repos/blog.git</code></pre></div><h3 id="2-配置Nginx"><a href="#2-配置Nginx" class="headerlink" title="2 配置Nginx"></a>2 配置Nginx</h3><h4 id="2-1-安装Nginx"><a href="#2-1-安装Nginx" class="headerlink" title="2.1 安装Nginx"></a>2.1 安装Nginx</h4><div class="hljs"><pre><code class="hljs shell">yum install -y nginx</code></pre></div><p>启动nginx</p><div class="hljs"><pre><code class="hljs shell">nginx</code></pre></div><h4 id="2-2-配置文件"><a href="#2-2-配置文件" class="headerlink" title="2.2 配置文件"></a>2.2 配置文件</h4><p>先暂停服务</p><div class="hljs"><pre><code class="hljs shell">nginx -s stop</code></pre></div><p>进入nginx目录，编辑配置文件</p><div class="hljs"><pre><code class="hljs shell">cd /etc/nginxvi nginx.conf</code></pre></div><p>注意要修改两个地方，一个是将<code>user nginx</code>改为<code>user root</code><br>第二个就是在server的位置，添加root解析路径<code>/home/git/projects/blog/</code>，如果你已经有了域名，那么在server_name后面添加上你的域名。其它保持不变。</p><div class="hljs"><pre><code class="hljs shell">server &#123;        listen       80 default_server;        listen       [::]:80 default_server;        server_name  zhouzhuyan.com www.zhouzhuyan.com;        root         /home/git/projects/blog/;        index index.html index.htm;    &#125;</code></pre></div><p>保存退出<br>重新启动nginx</p><div class="hljs"><pre><code class="hljs shell">systemctl restart nginx</code></pre></div><h4 id="2-3-检查"><a href="#2-3-检查" class="headerlink" title="2.3 检查"></a>2.3 检查</h4><p>检查nginx状态</p><div class="hljs"><pre><code class="hljs shell">systemctl status nginx</code></pre></div><p>如果看到绿色的<code>active</code>就表示配置成功了。我在这里遇到了一个问题，它的状态显示红色的<code>failed</code>,，错误是<code>98: Address already in use</code>，80端口已经被占用，这个时候可以用如下命令检查一下是谁占用了80端口</p><div class="hljs"><pre><code class="hljs shell">netstat -ntpl</code></pre></div><p>如果就是nginx的话，应该是由于之前的配置文件中，<code>listen       80 default_server;</code>监听ipv4的80端口，而<code>listen       [::]:80 default_server;</code>监听的是ipv6的80端口，于是就重复占用了。可以在配置文件中这样更改</p><div class="hljs"><pre><code class="hljs shell">listen       [::]:80 ipv6only=on  default_server;</code></pre></div><p>然后重启nginx应该就可以了。</p><h3 id="3-Hexo本地配置"><a href="#3-Hexo本地配置" class="headerlink" title="3. Hexo本地配置"></a>3. Hexo本地配置</h3><p>hexo的站点配置文件<code>_config.yml</code></p><div class="hljs"><pre><code class="hljs shell">deploy:  type: git  repo: git@你的IP:/home/git/repos/blog.git  branch: master</code></pre></div><p>然后进行部署</p><div class="hljs"><pre><code class="hljs shell">hexo cleanhexo g -d</code></pre></div><h3 id="4-启用https"><a href="#4-启用https" class="headerlink" title="4. 启用https"></a>4. 启用https</h3><p>由于nginx默认使用的是http，所以在网站访问的时候，会显示不安全，可以通过配置来开启https</p><h4 id="4-1-申请SSL证书"><a href="#4-1-申请SSL证书" class="headerlink" title="4.1 申请SSL证书"></a>4.1 申请SSL证书</h4><p>阿里云和腾讯云都提供免费的SSL证书下载，因为我的域名是在腾讯云云购买的，所以我就从腾讯云上下载了<a href="https://cloud.tencent.com/product/ssl" target="_blank" rel="noopener">SSL证书</a></p><h4 id="4-2-传输文件到服务器"><a href="#4-2-传输文件到服务器" class="headerlink" title="4.2 传输文件到服务器"></a>4.2 传输文件到服务器</h4><p>从腾讯云上下载证书到本地，会得到一个自己域名命名的文件夹，里面有<code>Apache</code>，<code>Nginx</code>，<code>Tomcat</code>，<code>IIS</code>的证书，由于我们使用的是nginx服务，所以只需要Nginx文件夹内的<code>xxx.crt</code>和<code>xxx.key</code>两个文件。<br>在服务端创建文件夹存储证书</p><div class="hljs"><pre><code class="hljs shell">mkdir /home/git/SSL</code></pre></div><p>我们可以使用scp命令将本地的文件传输到服务器</p><div class="hljs"><pre><code class="hljs shell">scp -r xxx/Nginx git@你的IP /home/git/SSL</code></pre></div><h4 id="4-3-配置nginx"><a href="#4-3-配置nginx" class="headerlink" title="4.3 配置nginx"></a>4.3 配置nginx</h4><p>然后再次编辑<code>nginx.conf</code>文件，这里可以参考官方文档<a href="https://cloud.tencent.com/document/product/400/35244" target="_blank" rel="noopener">Nginx 服务器证书安装</a>，文档写的很清晰，按照其中的步骤配置一下就可以完成了。<br>之后我们就可以通过https访问网页，在网址旁边会出现一把锁。</p><p>参考：<br>[1]HJX.将Hexo部署到阿里云轻量级服务器(保姆级教程)<br>[EB/OL].<a href="https://hjxlog.com/posts/20191130a1.html,2019-11-30." target="_blank" rel="noopener">https://hjxlog.com/posts/20191130a1.html,2019-11-30.</a><br>[2]Dreamy.TZK.将Hexo部署到云服务器<br>[EB/OL].<a href="https://cloud.tencent.com/developer/article/1632020,2020-05-25." target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1632020,2020-05-25.</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/posts/72e3b671.html"/>
    <url>/posts/72e3b671.html</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote><p>问题：<br>假设有一个模拟鸭子的游戏，游戏中拥有各种鸭子，我们设计了一个鸭子的超类，并且让各种鸭子，比如红头鸭，橡皮鸭等，继承它。<br>现在，我们需要更新这个游戏，使得鸭子可以飞起来，该怎么做？</p></blockquote><h2 id="使用继承？"><a href="#使用继承？" class="headerlink" title="使用继承？"></a>使用继承？</h2><p>如果依然使用继承，在超类中添加一个fly()方法，会出现不适合该行为的子类也具有该行为的问题，比如橡皮鸭就不会飞，但继承的做法使得它也可以飞起来。<br><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200902-01.png" srcset="/img/loading.gif" alt=""></p><p>如果选择覆盖<code>fly()</code>方法，那么在后续的更新中，我们需要不断地检查可能需要覆盖的<code>fly()</code>方法。<br>所以使用继承来提供行为，会造成代码在多个子类最终重复，复用性差，难以知道鸭子的全部行为，运行时的行为不容易改变等问题。</p><h2 id="使用接口？"><a href="#使用接口？" class="headerlink" title="使用接口？"></a>使用接口？</h2><p>如果抽象出一个<code>Flyable</code>接口，只有会飞的鸭子才实现这个接口呢？<br>设想一下，如果我们有上百种会飞的鸭子，那么就会造成大量的代码重复，每个子类中都要实现一次<code>fly()</code>方法，而且代码无法复用，如果我们需要修改这个方法，想象一下，这简直就是一场灾难。</p><h2 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h2><p>软件开发过程中总是伴随着变更。<br><strong>设计原则</strong></p><blockquote><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码放在一起。<br>也就是说我们把会变化的部分取出并封装起来，以便以后的改动和扩充。</p></blockquote><h3 id="分离变化与不变的部分"><a href="#分离变化与不变的部分" class="headerlink" title="分离变化与不变的部分"></a>分离变化与不变的部分</h3><p>在鸭子类中，我们可以发现<code>fly()</code>和<code>quack()</code>两个方法经常需要修改，那么我们就可以建立两组远离<code>Duck</code>类的类，一个与<code>fly</code>相关，一个与<code>quack</code>相关，每一组类实现各自的动作，比如让一个类实现“呱呱叫”，一个类实现“吱吱叫”，还有一个类实现“安静”</p><h3 id="设计行为"><a href="#设计行为" class="headerlink" title="设计行为"></a>设计行为</h3><p><strong>设计原则</strong></p><blockquote><p>针对接口编程，而不是针对实现编程<br>用接口代表每个行为，鸭子类不会实现<code>Flying</code>的接口，而是制造一组专门的类来实现<code>FlyBahavior</code></p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><h3 id="实现行为"><a href="#实现行为" class="headerlink" title="实现行为"></a>实现行为</h3><p>现在有一个<code>FlyBehavior</code>接口，还有对应的类，负责实现具体的行为。</p><p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200902-02.png" srcset="/img/loading.gif" alt=""></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyWithWings</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"I'm flying."</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyNoWay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"I can't fly"</span>);    &#125;&#125;</code></pre></div><h3 id="整合行为"><a href="#整合行为" class="headerlink" title="整合行为"></a>整合行为</h3><p>鸭子将飞行的动作<strong>委托</strong>给别人处理，而不是在鸭子类内部定义飞行方法。<br>在鸭子类中加入实例变量<code>flyBahavior</code>，声明为接口类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span>&#123;    FlyBehavior flyBehavior;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performFly</span><span class="hljs-params">()</span> </span>&#123;        flyBehavior.fly();    &#125;&#125;</code></pre></div><p>每个鸭子对象都会动态的设置这些变量以在运行时引用正确的类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MallardDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MallardDuck</span><span class="hljs-params">()</span> </span>&#123;        flyBehavior = <span class="hljs-keyword">new</span> FlyWithWings(); <span class="hljs-comment">// 使用FlyWithWings作为FlyBehavior类型</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"I'm a real Mallard duck."</span>);    &#125;&#125;</code></pre></div><p>测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiniDuckSimulator</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Duck mallard = <span class="hljs-keyword">new</span> MallardDuck();        mallard.performFly();    &#125;&#125;<span class="hljs-comment">// Output: I'm flying.</span></code></pre></div><h3 id="动态设定行为"><a href="#动态设定行为" class="headerlink" title="动态设定行为"></a>动态设定行为</h3><p>如果想要在运行时改变鸭子的行为，只需要调用鸭子的<code>setter</code>方法就可以了。<br>我们在鸭子类中增加设定方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlyBehavior</span><span class="hljs-params">(FlyBehavior fb)</span> </span>&#123;        flyBehavior = fb;&#125;</code></pre></div><p>创造一个新的类模型鸭</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ModelDuck</span><span class="hljs-params">()</span> </span>&#123;        flyBehavior = <span class="hljs-keyword">new</span> FlyNoWay();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"I'm a model duck."</span>);    &#125;&#125;</code></pre></div><p>建立一个新的<code>FlyBehavior</code>类型</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyRocketPowered</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"I'm flying with a rocket."</span>);    &#125;&#125;</code></pre></div><p>测试<br>调用<code>setter</code>方法，改变了模型鸭的飞行行为</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiniDuckSimulator</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Duck model = <span class="hljs-keyword">new</span> ModelDuck();        model.performFly();;        model.setFlyBehavior(<span class="hljs-keyword">new</span> FlyRocketPowered());        model.performFly();    &#125;&#125;<span class="hljs-comment">/* Output:I can't fly;I'm flying with a rocket.*/</span></code></pre></div><p>每一个鸭子都<strong>有一个(HAS-A)</strong><code>FlyBahavior</code>，将飞行委托给它处理。<br><strong>设计原则</strong></p><blockquote><p>多用组合，少用继承<br>使用组合建立系统具有很大的弹性，可以将算法族封装成类，还可以在运行时动态地改变行为。</p></blockquote><h2 id="策略模式小结"><a href="#策略模式小结" class="headerlink" title="策略模式小结"></a>策略模式小结</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一系列算法，把它们一个个<strong>封装</strong>起来，并且使它们可以相互替换。使得算法可以<strong>独立</strong>于它的客户变化。</p><h3 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h3><ol><li>许多相关的类仅仅只是行为有差别，比如鸭子类中的飞行</li><li>需要使用一个算法的不同变体</li><li>算法使用客户不应该知道的数据</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现（switch或if）</li></ol><h3 id="结构与参与者"><a href="#结构与参与者" class="headerlink" title="结构与参与者"></a>结构与参与者</h3><p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200902-04.png" srcset="/img/loading.gif" alt=""></p><p><strong>Strategy</strong> (策略)<br>定义所有支持的算法的公共接口，Context使用这个接口来调用ConcreteStrategy定义的算法，比如<code>FlyBehavior</code>就是一个策略<br><strong>ConcreteStrategy</strong>(具体策略)<br>以Strategy接口实现某具体的算法，比如<code>FlyWithWings</code>,<code>FlyNoWay</code>等<br><strong>Context</strong> (上下文)</p><ul><li>用一个ConcreteStrategy对象来配置</li><li>维护一个对Strategy对象的引用</li><li>可定义一个接口让Strategy来访问它的数据<br>比如<code>Duck</code>类</li></ul><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>相关算法系列</strong> Strategy类层次为Context定义了一系列可供复用的算法或行为</li><li><strong>替代继承的方法</strong> 使用继承可以直接生成一个Context的子类，给它不同的行为，但这样会使得Context难以理解，维护和扩展，不能动态改变算法。而将算法封装在独立的Strategy类中使得我们可以独立于Context改变它，易于理解，修改和扩展。</li><li><strong>消除可一些条件语句</strong> 含有许多条件语句的代码通常需要使用策略模式</li><li><strong>实现的选择</strong> 策略模式可以提供相同行为的不同实现供客户选择</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>客户必须了解不同的策略</strong> 需要向客户暴露具体问题，所以只有当不同行为的变体与客户有关时，才使用策略模式</li><li><strong>Strategy和Context之间的通信开销</strong></li><li>增加了对象的数目</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率论的基本概念</title>
    <link href="/posts/36736857.html"/>
    <url>/posts/36736857.html</url>
    
    <content type="html"><![CDATA[<p>本文介绍了概率论的基本概念，包括概率的定义，概率的计算，同时还有随机测试的简单介绍。</p><p><strong>重点</strong></p><ul><li>概率的定义</li><li>条件概率</li><li>乘法公式</li><li>全概率公式</li><li>贝叶斯公式</li></ul><a id="more"></a><h2 id="一、概率的定义"><a href="#一、概率的定义" class="headerlink" title="一、概率的定义"></a>一、概率的定义</h2><p>当我们还不能用数学符号描述一件事情，那么说明我们还没有想清楚这件事。</p><p>所以，我们需要建立元素到数据的<strong>映射</strong></p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><h4 id="1-1-随机实验"><a href="#1-1-随机实验" class="headerlink" title="1.1 随机实验"></a>1.1 随机实验</h4><ul><li>可以在相同的条件下重复进行</li><li>每次实验结果不止一个，并且事先明确实验的所有可能结果</li><li>进行一次实验前不能够确定那一个结果会出现</li></ul><p>例：抛一枚硬币，观察正面H与反面T出现的情况</p><h4 id="1-2-样本空间"><a href="#1-2-样本空间" class="headerlink" title="1.2 样本空间"></a>1.2 样本空间</h4><p>随机试验$E$的所有可能结果组成的集合称为$E$的<strong>样本空间</strong>，记为$\Omega$</p><p>样本空间中的每个元素，即$E$的每个结果，称为<strong>样本点</strong>，记为$e$</p><h4 id="1-3-随机事件"><a href="#1-3-随机事件" class="headerlink" title="1.3 随机事件"></a>1.3 随机事件</h4><p>样本空间$\Omega$的任意子集$A$称为<strong>随机事件</strong></p><p>观察到样本点$e$，若$e\in A$，则称这一事件发生。</p><ul><li>基本事件：由一个样本点组成的单点集</li><li>复合事件：由两个或两个以上样本点组成的集合</li><li>必然事件：全集$\Omega$</li><li>不可能事件：空集$\emptyset$</li></ul><h3 id="2-事件的集合运算"><a href="#2-事件的集合运算" class="headerlink" title="2. 事件的集合运算"></a>2. 事件的集合运算</h3><ul><li>包含：$A\subset B$，事件B包含事件A，则事件A发生必然导致事件B发生</li><li>相等：$A=B$，即$A\subset B$且$B\subset A$</li><li>和：$A\bigcup B$，即A和B至少有一个发生</li><li>差：$A-B$，即事件A发生且事件B不发生</li><li>积：$A\bigcup B$，记作$AB$，即事件A和事件B都发生</li><li>互不相容：$AB = \emptyset$，即A和B不能同时发生</li><li>互逆：$A\bigcup B=\Omega$ 且$AB = \emptyset$，A和B互逆，通常B记为$\overline{A}$</li></ul><h4 id="2-1-复杂事件的集合运算"><a href="#2-1-复杂事件的集合运算" class="headerlink" title="2.1 复杂事件的集合运算"></a>2.1 复杂事件的集合运算</h4><ul><li>A发生而B和C都不发生：$A\overline{B} \overline{C}=A-B-C=A-(B\bigcup C)$</li><li>A与B都发生而C不发生：$AB\overline{C}=AB-C=AB-ABC$</li><li>三个事件都发生：$ABC$</li><li>三个事件恰好有一个发生：$A\overline{B}\overline{C}+\overline{A}B\overline{C}+\overline{A}\overline{B}C$</li><li>三个事件至少发生一个：$A\bigcup B\bigcup C$</li></ul><h4 id="2-2-常用定律"><a href="#2-2-常用定律" class="headerlink" title="2.2 常用定律"></a>2.2 常用定律</h4><ul><li>交换律</li><li>结合律</li><li>分配率：$A\, \bigcup \,(B\bigcap C)=(A\bigcup B)\bigcap (A\bigcup C)$    $A\, \bigcap \,(B\bigcup C)=(A\bigcap B)\,\bigcup \,(A\bigcap C)$</li><li>德摩根定律：$\overline{A\bigcup B}=\overline{A}\bigcap\overline{B}$    $\overline{A\bigcap B}=\overline{A}\bigcup\overline{B}$</li></ul><h3 id="3-频率"><a href="#3-频率" class="headerlink" title="3. 频率"></a>3. 频率</h3><p>描述了事件发生的频繁程度</p><p><strong>定义</strong></p><ul><li>重复观察n次事件A发生的次数$n_A$称为A的<em>频数</em></li><li>比值$\frac{n_A}{n}$称为事件A发生的<strong>频率</strong>，并记为$f_n(A)$</li></ul><p><strong>性质</strong></p><ol><li><p>$0\,\leq\, f_n(A)\, \leq\, 1$ </p></li><li><p>$f_n(\Omega)=1$</p></li><li><p>若$A_1,\cdots,A_k$两两互不相容，则</p><script type="math/tex; mode=display">f_n(A_1\,\bigcup\,\cdots\bigcup\,A_k)=f_n(A_1)+\cdots+f_n(A_k)</script></li></ol><p><strong>收敛性</strong></p><ul><li>当n足够大，$f_n(A)$收敛于某个常数，这个常数就是<strong>概率</strong>（证明见后续）</li></ul><p><strong>我们应该都听说过德摩根抛硬币的故事，对一个事件进行大量的实验可以得到频率，但是我们不可能对所有事件都做类似的事情，所以就有了概率</strong></p><h3 id="4-概率"><a href="#4-概率" class="headerlink" title="4. 概率"></a>4. 概率</h3><p>表征事件发生的可能性大小</p><p><strong>定义</strong></p><p>$\Omega$为样本空间，对于每一事件A赋予一实数$P(A)$，若P(A)满足下列条件则被称为概率：</p><ul><li>非负性：$0\leq P(A)\leq 1$</li><li>规范性：$P(\Omega)=1$</li><li>可列可加性：$A_1,\cdots,A_n$互不相容，则$P(A_1\,\bigcup\,\cdots\bigcup\,A_k)=P(A_1)+\cdots+P(A_k)$</li></ul><p><strong>性质</strong></p><ol><li>$P(\emptyset)=0$</li><li>$P(\overline{A})=1-P(A)$</li><li>若$A\subset B$，则有$P(A)\leq P(B),\quad P(B-A)=P(B)-P(A)$</li><li>对于任意两个事件A和B，$P(A\bigcup B)=P(A)+P(B)-P(A+B)$</li></ol><h4 id="4-1-古典概型-等可能概型"><a href="#4-1-古典概型-等可能概型" class="headerlink" title="4.1 古典概型(等可能概型)"></a>4.1 古典概型(等可能概型)</h4><p><strong>定义</strong></p><p>若$\Omega$是**有限样本空间，其样本点为$e_1,\cdots e_n$，在有限样本空间中引进概率。</p><p><strong>1/n</strong>称为事件${e_i}$的概率，记为$P({e_i})$</p><script type="math/tex; mode=display">P(\{e_1\})+\cdots +P(\{e_n\})=P(\Omega)=1</script><p>从定义中不难发现古典概型的两个特点：</p><ul><li>样本空间包含<strong>有限</strong>个元素</li><li>试验中每个基本事件发生的可能性相同</li></ul><p>注：<strong>基本事件是两两不相容的</strong></p><p>若事件A包含k个基本事件，则有</p><script type="math/tex; mode=display">P(A)=\sum_{i=1}^kP(\{e_{i_k}\})=\frac{k}{n}</script><h4 id="4-2-几何概型"><a href="#4-2-几何概型" class="headerlink" title="4.2 几何概型"></a>4.2 几何概型</h4><p>数据从有限集合推广到无限集合</p><p>例：约会问题</p><p>两人约定7点到8点在某地会面，先到者等候另一人20分钟，过时就离去，试求这两人会面的概率。</p><p>解：以$x,y$分别表示两人到达的时刻，则会面的充要条件为$|x-y|\leq20$，这就是一个几何概率的问题，可能的结果全体是边长60的正方形里面的点，结果为</p><script type="math/tex; mode=display">P(A)=\frac{60^2-40^2}{60^2}</script><p>从上面的例子不难看出，样本空间从原来的有限的个数，变成了无限的点。</p><p>如果要在半径为1的圆内随机地取一条弦，问弦长超过$\sqrt{3}$的概率是多少？</p><p>3种思路有3种不同的答案</p><p><strong>在数据映射中，我们需要遵循物理世界到数据集合的某种结构保持</strong></p><hr><h2 id="二、概率的计算"><a href="#二、概率的计算" class="headerlink" title="二、概率的计算"></a>二、概率的计算</h2><h3 id="1-条件概率"><a href="#1-条件概率" class="headerlink" title="1. 条件概率"></a>1. 条件概率</h3><p>事件A发生的条件下事件B发生的概率</p><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>设A，B是两事件，且$P(A)&gt;0$，称</p><script type="math/tex; mode=display">P(B|A)=\frac{P(AB)}{P(A)}</script><p>为在事件A发生的条件下事件B发生的<strong>条件概率</strong></p><p>条件概率符合概率定义中的3个条件</p><p>非负性</p><p>规范性</p><p>可列可加性：$B_1,\cdots,B_n$两两互不相容</p><script type="math/tex; mode=display">P(\bigcup_{i=1}^\infty B_i\,\mid\,A)=\sum_{i=1}^\infty P(B_i\mid A)</script><p>同时也可以使用概率的性质</p><script type="math/tex; mode=display">P(B_1\bigcup B_2)=P(B_1\mid A)+P(B_2\mid A)-P(B_1B_2\mid A)</script><p>注意这里是对任意事件$B_1,B_2$，两者不一定互不相容，如果互不相容，那么$P(B_1B_2)=\emptyset$，与可列可加性不矛盾。</p><h4 id="1-2-乘法公式"><a href="#1-2-乘法公式" class="headerlink" title="1.2 乘法公式"></a>1.2 乘法公式</h4><script type="math/tex; mode=display">P(AB)=P(A)P(B|A)</script><p>推广：一般地，我们有：</p><script type="math/tex; mode=display">P(A_1A_2\cdots A_n)=P(A_1)P(A_2\mid A_1)\cdots P(A_n\mid A_1A_2\cdots A_{n-1})</script><p>大多数应用中，我们会直接获取条件概率，通过它进行计算</p><h4 id="1-3-完备事件组"><a href="#1-3-完备事件组" class="headerlink" title="1.3  完备事件组"></a>1.3  完备事件组</h4><p>设$B_1,\cdots,B_n$是样本空间$\Omega$的一个事件组，若满足</p><ul><li>$B_i\bigcap B_j=\emptyset$ ，对于任意$i\neq j$</li><li>$\bigcup_iB_i=\Omega$</li></ul><p>则$B_1,\cdots,B_n$称为一个完备事件组</p><h4 id="1-4-全概率公式"><a href="#1-4-全概率公式" class="headerlink" title="1.4 全概率公式"></a>1.4 全概率公式</h4><p>设$B_1,\cdots,B_n$是样本空间$\Omega$的一个完备事件组，且$P(B_i)&gt;0(i=1,2,\cdots,n)$，则对于任一随机事件A，有</p><script type="math/tex; mode=display">P(A)=\sum_{i=1}^nP(B_i)P(A\mid B_i)</script><p>当$P(A)$不易求得时，利用此公式</p><h4 id="1-5-贝叶斯公式"><a href="#1-5-贝叶斯公式" class="headerlink" title="1.5 贝叶斯公式"></a>1.5 贝叶斯公式</h4><p>设实验E的样本空间为$\Omega$，$A$为$\Omega$的事件，$B_1,\cdots,B_n$为$S$的一个划分，且$P(A)&gt;0,P(B_i)&gt;0$，则</p><script type="math/tex; mode=display">P(B_i\mid A)=\frac{P(A\mid B_i)P(B_i)}{\sum_{j=1}^nP(A\mid B_j)P(B_j)},i=1,2,\cdots,n</script><p>如：设$A,B$为两事件，$P(B)&gt;0$，则</p><script type="math/tex; mode=display">P(A\mid B)=\frac{P(B\mid A)\times P(A)}{P(B)}</script><p>贝叶斯定理往往与全概率公式同时使用。全概率公式用于”由因求果“的问题，而贝叶斯定理用于”执果寻因“问题。</p><p><strong>常用</strong>：令$n=2$，那么全概率公式和贝叶斯公式分别为：</p><script type="math/tex; mode=display">P(A)=P(A\mid B)P(B)+P(A\mid \overline{B})P(\overline{B})</script><script type="math/tex; mode=display">P(B\mid A)=\frac{P(AB)}{P(A)}=\frac{P(A\mid B)P(B)}{P(A\mid B)P(B)+P(A\mid \overline{B})P(\overline{B})}</script><h4 id="1-6-独立性"><a href="#1-6-独立性" class="headerlink" title="1.6 独立性"></a>1.6 独立性</h4><p><strong>定义</strong>：设$A,B$是两事件，如果满足等式</p><script type="math/tex; mode=display">P(AB)=P(A)P(B)</script><p>则称事件$A$和事件$B$相互独立</p><p><strong>定理</strong>：设$A,B$是两事件，且$P(A)&gt;0$，若$A,B$相互独立，则$P(B\mid A)=P(B)$，反之亦然</p><p><strong>定理</strong>：若事件$A,B$相互独立，则下列各对事件也相互独立，$A\&amp;\overline{B},B\&amp;\overline{A},\overline{A}\&amp;\overline{B}$</p><p><strong>定义</strong>：设$A,B,C$是三个事件，如果满足等式</p><script type="math/tex; mode=display">P(AB)=P(A)P(B),\\ P(BC)=P(B)P(C)\\P(AC)=P(A)P(C)\\P(ABC)=P(A)P(B)P(C)</script><p>则称事件$A,B,C$相互独立</p><hr><h2 id="三、随机测试示例"><a href="#三、随机测试示例" class="headerlink" title="三、随机测试示例"></a>三、随机测试示例</h2><p>实际应用中使用概率论</p><h3 id="1-随机测试初步"><a href="#1-随机测试初步" class="headerlink" title="1.  随机测试初步"></a>1.  随机测试初步</h3><p>假设有一个计算多项式乘法的程序。</p><p>程序可能采用左右两边的某一方式实现：</p><script type="math/tex; mode=display">(x+1)(x-2)(x+3)(x-4)(x+5)(x-6)=x^6-7x^3+25</script><p>思考：</p><ul><li>如何验证左右两边的多项式相等</li><li>假设有一个超大规模的多项式呢？</li></ul><script type="math/tex; mode=display">F(X)?\equiv G(x)</script><h4 id="1-1-规范化"><a href="#1-1-规范化" class="headerlink" title="1.1 规范化"></a>1.1 规范化</h4><p>两个多项式相等当且仅当他们的规范式中所有的对应系数相等，</p><p>那么把$F(x)$变换为规范式，有$O(d^2)$的复杂度</p><h4 id="1-2-随机测试-初步"><a href="#1-2-随机测试-初步" class="headerlink" title="1.2 随机测试-初步"></a>1.2 随机测试-初步</h4><p>设$F(X),G(x)$的最高阶为的$d$，随机算法首先是从${1,\cdots,100d}$中均匀随机（等可能）地选择一个整数$r$，然后计算两个式子的值，进行判断。有$O(d)$的复杂度，大大提高了速度。</p><p>当然，这种算法可能会给出<strong>错误</strong>的答案。</p><p>$F(x)\neq G(x), F(r)=G(r)$，算法检测结果错误</p><p>错误的概率是多少？可以接受吗？</p><p>当$r$是方程$F(x)-G(x)=0$的根时，必然会出现错误结果。</p><p>$F(x)-G(x)$的次数不高于$d$，由代数的基本定理可知，$F(x)-G(x)=0$不可能多于$d$个根。</p><p>那么在${1,\cdots,100d}$中，给出错误答案的概率不会高于$\frac{1}{100}$</p><h3 id="2-随机测试改进"><a href="#2-随机测试改进" class="headerlink" title="2. 随机测试改进"></a>2. 随机测试改进</h3><p>如何改进算法正确率？</p><p>很容易想到两个方向，扩大检测范围，重复多次检测</p><h4 id="2-1-扩大范围"><a href="#2-1-扩大范围" class="headerlink" title="2.1 扩大范围"></a>2.1 扩大范围</h4><p>在更大的范围进行取值，比如在${1,\cdots,1000d}$中进行检测，那么错误答案概率不会超过$\frac{1}{1000}$</p><h4 id="2-2-重复检测"><a href="#2-2-重复检测" class="headerlink" title="2.2 重复检测"></a>2.2 重复检测</h4><p>重复多次进行随机检测</p><ul><li><p>有放回抽样</p><p>$k$次有放回抽样错误率为</p><script type="math/tex; mode=display">P(E_1\,\bigcap\cdots\bigcap\,E_k)=\prod_{i=1}^kP(E_i)\leq(\frac{1}{100})^k</script><p>可以看到，错误率指数级降低</p></li><li><p>无放回抽样</p></li></ul><p>总结：</p><p>无放回比有放回准确率高</p><p>有放回实现比无放回简单</p><p>当$d+1$次无放回抽样后，能够确保准确性，但是算法复杂度提升到$O(d^2)$</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="1-概率的定义"><a href="#1-概率的定义" class="headerlink" title="1. 概率的定义"></a>1. 概率的定义</h3><p>$\Omega$为样本空间，对于每一事件A赋予一实数$P(A)$，若P(A)满足下列条件则被称为概率：</p><ul><li>非负性：$0\leq P(A)\leq 1$</li><li>规范性：$P(\Omega)=1$</li><li>可列可加性：$A_1,\cdots,A_n$互不相容，则$P(A_1\,\bigcup\,\cdots\bigcup\,A_k)=P(A_1)+\cdots+P(A_k)$</li></ul><h3 id="2-条件概率"><a href="#2-条件概率" class="headerlink" title="2. 条件概率"></a>2. 条件概率</h3><script type="math/tex; mode=display">P(B|A)=\frac{P(AB)}{P(A)}</script><h3 id="3-乘法公式"><a href="#3-乘法公式" class="headerlink" title="3. 乘法公式"></a>3. 乘法公式</h3><script type="math/tex; mode=display">P(A_1A_2\cdots A_n)=P(A_1)P(A_2\mid A_1)\cdots P(A_n\mid A_1A_2\cdots A_{n-1})</script><h3 id="4-全概率公式"><a href="#4-全概率公式" class="headerlink" title="4. 全概率公式"></a>4. 全概率公式</h3><script type="math/tex; mode=display">P(A)=P(A\mid B_1)P(B_1)+\cdots+P(A\mid B_n)P(B_n)</script><h3 id="5-贝叶斯公式"><a href="#5-贝叶斯公式" class="headerlink" title="5. 贝叶斯公式"></a>5. 贝叶斯公式</h3><script type="math/tex; mode=display">P(A\mid B)=\frac{P(B\mid A)P(A)}{P(B)}</script><p>参考：</p><ol><li><a href="https://www.icourse163.org/learn/NJU-1450307351?tid=1450738603#/learn/announce" target="_blank" rel="noopener">中国大学MOOC-南京大学-数据科学基础</a></li><li>《概率论与数理统计》浙江大学第四版</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据科学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo个人博客绑定域名和配置SSL证书</title>
    <link href="/posts/2cd2c226.html"/>
    <url>/posts/2cd2c226.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-个人博客绑定域名和配置SSL证书"><a href="#Hexo-个人博客绑定域名和配置SSL证书" class="headerlink" title="Hexo 个人博客绑定域名和配置SSL证书"></a>Hexo 个人博客绑定域名和配置SSL证书</h1><p>在完成个人博客的搭建以后，我们可以通过一个<code>https://xxx.github.io</code>形式的链接在访问我们的个人博客网站，那么如果想拥有一个个性的域名，该如何操作呢？</p><a id="more"></a><h2 id="一、-绑定域名"><a href="#一、-绑定域名" class="headerlink" title="一、 绑定域名"></a>一、 绑定域名</h2><h3 id="1-购买"><a href="#1-购买" class="headerlink" title="1. 购买"></a>1. 购买</h3><p>域名可以在阿里云或者腾讯云上购买，不同形式的有不同的价格，根据自己的情况购买即可。我在腾讯云上购买了我现在的域名<code>zhouzhuyan.com</code></p><p><strong>注意</strong>：如果不使用国内的服务器的话不用备案，只要完成实名认证就可以了。</p><p>现在实名认证，审核都很快，虽然说一个工作日审批，但是我的话几分钟成功了。在域名的状态显示正常以后，就可以使用了。</p><p><img src="https://blogofzzy-1301797566.cos.ap-shanghai.myqcloud.com/domainname1.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title="2. 域名解析"></a>2. 域名解析</h3><p>这个时候，网站时访问不了的，因为还需要去解析你的域名，将你的域名指向你的个人网站。</p><p>到腾讯云控制台的域名管理界面，找到你的域名，点击解析，选择添加记录</p><div class="table-container"><table><thead><tr><th>主机记录</th><th>记录类型</th><th>线路类型</th><th>记录值</th></tr></thead><tbody><tr><td>www</td><td>CNAME</td><td>默认</td><td>你的Github项目仓库名</td></tr><tr><td>@</td><td>CNAME</td><td>默认</td><td>你的Github项目仓库名</td></tr></tbody></table></div><p>两个主机记录是为了让你的网站在有<code>www</code>和没有的情况下都可以访问，仓库名可以在Github仓库的<code>Settings</code>里面找到。解析需要10分钟，耐心等待。</p><h3 id="3-在项目中更换"><a href="#3-在项目中更换" class="headerlink" title="3. 在项目中更换"></a>3. 在项目中更换</h3><p>到Github中找到自己的网站所在的仓库，进入<code>Settings</code>界面</p><p><img src="https://blogofzzy-1301797566.cos.ap-shanghai.myqcloud.com/2020-04-09domainname2.png" srcset="/img/loading.gif" alt=""></p><p>在<code>Custom domain</code>里面填写自己的域名，选择<code>save</code>，这样就会出现上图的形式，显示<code>Your site is published at https://你的域名</code>，勾选<code>Enforce HTTPS</code></p><h3 id="4-创建CNAME文件"><a href="#4-创建CNAME文件" class="headerlink" title="4. 创建CNAME文件"></a>4. 创建CNAME文件</h3><p>进入你的Hexo本地文件所在的根目录，找到<code>\source</code>目录，在里面创建一个文件<code>CNAME</code>，注意它是没有类型的，不是<code>.txt</code>。</p><p>在里面加入你的域名，注意不要在前面加入<code>https</code> <code>www</code>这样的前缀，就是你的域名。</p><p>然后<code>hexo d -g</code>部署你的网站，等待一段时间后，就可以通过你的个性域名访问网站了。</p><hr><h2 id="二、-SSL安全证书"><a href="#二、-SSL安全证书" class="headerlink" title="二、 SSL安全证书"></a>二、 SSL安全证书</h2><p>注册好域名后，用google访问时，可能会出现<strong>您访问的不是安全链接</strong>的提示，或者能够正常访问，但是域名旁边显示的是一个感叹号，表示不安全，这是因为我们还没有申请安全证书，在申请了证书之后，域名旁边显示的就是一把锁，表示安全。</p><p>腾讯云和阿里云都提供免费的SSL证书下载，具体安装也有相关的文档，按照步骤操作就行。</p><p><a href="https://cloud.tencent.com/document/product/400/35244" target="_blank" rel="noopener">腾讯云Nginx服务器证书安装</a></p><p><a href="https://www.jianshu.com/p/026d67cc6cb1" target="_blank" rel="noopener">Mac下nginx的使用</a></p><p>在证书安装好了以后，可以看到域名解析里面多出了一条TXT类型的解析。</p><p>在Chrome浏览器中，打开网站后如果仍然显示不安全，即没有出现锁的图标，右击选择检查元素，进入开发者模式，看<code>Security</code>里面有什么问题。</p><p><strong>踩坑</strong>：我发现我用阿里云图床的图片引用的是http头，把它改为<code>https</code>，锁就出现了。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++字符串,向量和数组</title>
    <link href="/posts/869e4b19.html"/>
    <url>/posts/869e4b19.html</url>
    
    <content type="html"><![CDATA[<h3 id="二、字符串，向量和数组"><a href="#二、字符串，向量和数组" class="headerlink" title="二、字符串，向量和数组"></a>二、字符串，向量和数组</h3><p>作用域操作符<code>::</code></p><p>含义：编译器应从操作符左侧的作用域中寻找右边那个名字</p><p>比如<code>std::cin</code>是要使用命名空间<code>std</code>中的<code>cin</code></p><p>这样做是为了避免某些名字被重复使用</p><p>使用<code>using</code>声明可以更加简便的使用命名空间中的成员。</p><a id="more"></a><h4 id="1-String类型"><a href="#1-String类型" class="headerlink" title="1. String类型"></a>1. String类型</h4><p>表示可变长的字符串</p><h5 id="1-1-定义和初始化"><a href="#1-1-定义和初始化" class="headerlink" title="1.1 定义和初始化"></a>1.1 定义和初始化</h5><ol><li><p>使用需要头文件和命名空间</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>;</code></pre></div></li><li><p>初始化</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1; <span class="hljs-comment">// 空字符串</span><span class="hljs-built_in">string</span> s2 = s1; <span class="hljs-comment">// s2是s1的副本</span><span class="hljs-built_in">string</span> s3 = <span class="hljs-string">"abc"</span>;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>)</span></span>; <span class="hljs-comment">// 十个c</span></code></pre></div></li></ol><h5 id="1-2-string对象上的操作"><a href="#1-2-string对象上的操作" class="headerlink" title="1.2 string对象上的操作"></a>1.2 string对象上的操作</h5><ol><li><p>使用<code>getline</code>读取一整行</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> line;getline(<span class="hljs-built_in">cin</span>, line);</code></pre></div><p>当读取到换行符时结束，并将读到的内容存入<code>string</code>中，但是<strong>不存换行符</strong></p></li><li><p><code>empty</code>和<code>size</code>操作</p><p><code>str.empty()</code>根据字符串是否为空返回一个布尔值</p><p><code>str.size()</code>返回字符串长度</p><p>使用visual studio编程的时候，碰到过一个<strong>warning</strong>，将无符号数赋值给了有符号数。</p><p>这是由于<code>size</code>函数的返回值类型引起的，它是一个<code>string::size_type</code>类型的值，是无符号类型的，</p><p>可以用<code>auto</code>来推断变量的值</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> len = str.size();</code></pre></div></li><li><p>比较，赋值，相加</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"abc"</span>;<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"xcvd"</span>;<span class="hljs-comment">// s1 &lt; s2 比较第一个不同的字符</span><span class="hljs-built_in">string</span> s3 = s1; <span class="hljs-comment">// 赋值</span><span class="hljs-built_in">string</span> s4 = s1 + s2; <span class="hljs-comment">// abcxcvd</span></code></pre></div></li><li><p>处理<code>string</code>中的字符</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cctype&gt;</span></span><span class="hljs-built_in">isalnum</span>(c);<span class="hljs-built_in">isalpha</span>(c);<span class="hljs-built_in">islower</span>(c);<span class="hljs-built_in">isupper</span>(c);<span class="hljs-built_in">ispunct</span>(c); <span class="hljs-comment">// 是标点符号为真</span></code></pre></div></li></ol><h4 id="2-Vector类型"><a href="#2-Vector类型" class="headerlink" title="2. Vector类型"></a>2. Vector类型</h4><p>可变长数组，类似于Java中的<code>ArrayList</code></p><h5 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;T&gt; v;<span class="hljs-built_in">vector</span>&lt;T&gt; v1 = &#123;a, b, c&#125;; <span class="hljs-comment">// 注意是花括号</span><span class="hljs-built_in">vector</span>&lt;T&gt; v2&#123;a, b&#125;;     <span class="hljs-comment">// 花括号，两个元素</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 圆括号 10个元素，每个初始化为1</span></code></pre></div><h5 id="2-2-操作"><a href="#2-2-操作" class="headerlink" title="2.2 操作"></a>2.2 操作</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;v.push_back(<span class="hljs-number">1</span>); <span class="hljs-comment">// 添加1</span>v.pop_back(); <span class="hljs-comment">// 去掉最后一个数据</span>v.empty();v.size();v[n]; <span class="hljs-comment">// 注意下标只能访问，但是不能够添加元素</span></code></pre></div><h4 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h4><p>访问元素的作用</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s = <span class="hljs-string">"abcde"</span>;<span class="hljs-keyword">if</span> (s.begin() != s.end()) &#123; <span class="hljs-comment">// 确保s非空</span>  &#125;</code></pre></div><h4 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h4><h5 id="4-1-指针和数组"><a href="#4-1-指针和数组" class="headerlink" title="4.1 指针和数组"></a>4.1 指针和数组</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">p</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">// 整型指针，指向ia的第一个元素</span>p++; <span class="hljs-comment">// 指向第一个元素</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-Permalink简化</title>
    <link href="/posts/838443af.html"/>
    <url>/posts/838443af.html</url>
    
    <content type="html"><![CDATA[<h1 id="Permalink简化"><a href="#Permalink简化" class="headerlink" title="Permalink简化"></a>Permalink简化</h1><p>在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章</p><p><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">阮一峰 关于url编码</a></p><p>有两种方法优化。</p><a id="more"></a><h2 id="方法一：自定义"><a href="#方法一：自定义" class="headerlink" title="方法一：自定义"></a>方法一：自定义</h2><p>首先，在<code>scaffolds</code>的<code>post.md</code>中，加入<code>urlname</code>元素。</p><div class="hljs"><pre><code class="hljs subunit">title: &#123;&#123; title &#125;&#125;urlname:date: &#123;&#123; date &#125;&#125;<span class="hljs-keyword">tags:</span>categories:</code></pre></div><p>然后，在配置文件<code>_config.yml</code>中，将永久链接<code>permalink</code>的形式改为</p><div class="hljs"><pre><code class="hljs elixir"><span class="hljs-symbol">permalink:</span> <span class="hljs-symbol">:category/</span><span class="hljs-symbol">:urlname/</span></code></pre></div><p>也就是类别加上自定义的url链接。</p><p>每次写文章时，可以自己设计该页的<code>url</code>，使得它变得简单，同时也利于区分。</p><p>但是，这种修改方法的链接会随着文件目录的改变而改变，</p><p>比如一篇文章<code>HelloWorld.md</code>本来放在<code>_posts</code>目录下，链接为<code>https://xxx/_posts/HelloWorld.md</code></p><p>之后归类到<code>_posts/A</code>目录下，那么链接变为<code>https://xxx/_posts/A/HelloWorld.md</code></p><p>这样不太利于分享，所以推荐使用第二种方法。</p><h2 id="方法二：插件"><a href="#方法二：插件" class="headerlink" title="方法二：插件"></a>方法二：插件</h2><p>使用<code>hexo-abbrlink</code>这个插件</p><ol><li><p>安装</p><div class="hljs"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-abbrlink <span class="hljs-comment">--save</span></code></pre></div></li><li><p>设置</p><p>在<code>_config.yml</code>文件中修改永久链接格式</p><div class="hljs"><pre><code class="hljs dts"><span class="hljs-symbol">permalink:</span> posts/:abbrlink.html<span class="hljs-symbol">abbrlink:</span><span class="hljs-symbol">  alg:</span> crc32  <span class="hljs-meta"># 算法：crc16(default) and crc32</span><span class="hljs-symbol">  rep:</span> hex    <span class="hljs-meta"># 进制：dec(default) and hex</span></code></pre></div><p><code>posts</code>部分是可以更改的，也可以仿照方法一添加一个关键词便于识别</p><div class="hljs"><pre><code class="hljs elixir"><span class="hljs-symbol">permalink:</span> <span class="hljs-symbol">:keywords/</span><span class="hljs-symbol">:abbrlink</span>.html</code></pre></div></li><li><p>生成</p><p>在根目录创建<code>Gruntfile.js</code>文件，让插件到<code>source/_posts/</code>下读取所有的.md文件，把文件中的@@abbrlink替换成文件内容的hash值。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">grunt</span>) </span>&#123;   grunt.initConfig(&#123;    <span class="hljs-attr">rewrite</span>: &#123;      <span class="hljs-attr">abbrlink</span>: &#123;        <span class="hljs-attr">src</span>: <span class="hljs-string">'source/_posts/**/*.md'</span>,        <span class="hljs-attr">editor</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">contents, filepath</span>)</span>&#123;          <span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);          <span class="hljs-keyword">const</span> hash = crypto.createHash(<span class="hljs-string">'sha256'</span>);          hash.update(contents);          <span class="hljs-keyword">var</span> hashValue = hash.digest(<span class="hljs-string">'hex'</span>);          <span class="hljs-keyword">return</span> contents.replace(<span class="hljs-regexp">/@@abbrlink/g</span>, hashValue.substring(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>));        &#125;      &#125;,    &#125;,  &#125;);   grunt.loadNpmTasks(<span class="hljs-string">'grunt-rewrite'</span>);&#125;;</code></pre></div></li></ol><p>这种方法生成的链接是不带目录的，直接就是第二步设置中<code>permalink</code>的样式，所以也没有了被改变的风险。</p><p>参考</p><ol><li><a href="http://blog.jvaeyhcd.wang/posts/05c9df7e0c47bd64.html" target="_blank" rel="noopener">http://blog.jvaeyhcd.wang/posts/05c9df7e0c47bd64.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++变量和基本类型</title>
    <link href="/posts/96db5496.html"/>
    <url>/posts/96db5496.html</url>
    
    <content type="html"><![CDATA[<h3 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h3><h4 id="1-复合类型-Compound-type"><a href="#1-复合类型-Compound-type" class="headerlink" title="1. 复合类型(Compound type)"></a>1. 复合类型(Compound type)</h4><p>基于其它类型定义的类型</p><h5 id="1-1-引用-Reference"><a href="#1-1-引用-Reference" class="headerlink" title="1.1 引用(Reference)"></a>1.1 引用(Reference)</h5><p><strong>引用</strong>为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。</p><a id="more"></a><p>(在这里，引用指的是左值引用)</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>;<span class="hljs-keyword">int</span> &amp;refval = ival; <span class="hljs-comment">// refval指向ival，是ival的另外一个名字</span><span class="hljs-keyword">int</span> &amp;refVal2; <span class="hljs-comment">// 报错；引用必须被初始化</span></code></pre></div><p>定义引用时，程序把引用和它的初始值<strong>绑定</strong>在一起，而不是将初始值拷贝给引用。（与初始化变量时不同的）</p><p>无法令引用重新绑定到另一个对象，所以引用必须被<font color=red><strong>初始化</strong> </font></p><ul><li>引用即别名，它不是对象，而是为了一个已经存在的对象起了另外一个名字</li></ul><p>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的</p><div class="hljs"><pre><code class="hljs cpp">refVal = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 把2赋值给与refVal绑定的对象上，这里就是绑定到iVal上</span><span class="hljs-keyword">int</span> ii = refVal;</code></pre></div><p> 除了两种特殊情况，其它所有引用的类型都要与之绑定的对象严格匹配。不能够与字面值或表达式的计算结果绑定。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> &amp;refVal4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误：引用对象初始值必须是一个对象</span><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<span class="hljs-keyword">int</span> &amp;refVal5 = dval; <span class="hljs-comment">// 错误：此处引用类型的初始值必须是int型对象</span></code></pre></div><h5 id="1-2-指针"><a href="#1-2-指针" class="headerlink" title="1.2 指针"></a>1.2 指针</h5><p><strong>指针</strong>是指向另外一种类型的符合类型，与引用类似，指针实现了对其它对象的间接访问。</p><p>不同：</p><ul><li>指针本身是一个对象</li><li>指针无需在定义时赋初值</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ip1; <span class="hljs-comment">// ip1是指向int对象的指针</span></code></pre></div><h6 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h6><p>指针存放某个对象的地址。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> *p = &amp;ival; <span class="hljs-comment">// p是存放变量ival的地址，或者说p是指向引用的指针。</span></code></pre></div><h6 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h6><p>指针的值（即地址）应该属于下列4中状态之一：</p><ul><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针</li><li>无效指针</li></ul><h6 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h6><p>如果指针指向了一个对象，可以使用<strong>解引用符</strong>（操作符*）来访问对象</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> *p = &amp;ival;<span class="hljs-built_in">cout</span> &lt;&lt; *p <span class="hljs-comment">// 输出42</span>*p = <span class="hljs-number">0</span>;<span class="hljs-built_in">cout</span> &lt;&lt; *p <span class="hljs-comment">// 输出0，为*p赋值实际上是为p所指的对象赋值</span></code></pre></div><h6 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h6><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p1 = <span class="hljs-literal">nullptr</span>;<span class="hljs-keyword">int</span> *p2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> *p3 = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 需要头文件cstdlib</span></code></pre></div><h6 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a>void*指针</h6><p>用于存放任意对象的地址，不能直接操作void*指针所指的对象</p><h6 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h6><h6 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h6><p>指针是对象，所以存在对指针的引用</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> *p;<span class="hljs-keyword">int</span> *&amp;r = p;  <span class="hljs-comment">// r是一个对p的引用</span>r = &amp;i;  <span class="hljs-comment">// r引用了一个指针，因此给r赋值&amp;就是令p指向i</span>*r = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 将i的值改为0</span></code></pre></div><h4 id="2-const限定符"><a href="#2-const限定符" class="headerlink" title="2. const限定符"></a>2. const限定符</h4><p>值不能被改变，所以const对象必须被初始化</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = <span class="hljs-number">512</span>; <span class="hljs-comment">// 输入缓冲区大小</span></code></pre></div><p>如果要在多个文件之间共享const，必须在变量定义前加extern关键字</p><h5 id="2-1-对const的引用"><a href="#2-1-对const的引用" class="headerlink" title="2.1 对const的引用"></a>2.1 对const的引用</h5><p>对常量的引用，不能够修改其绑定的对象</p><p>对const的引用可以使一个并非const的对象，但是不能通过其改变值</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">1024</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = ci; <span class="hljs-comment">// 正确</span>r1 = <span class="hljs-number">42</span>; <span class="hljs-comment">// 错误：r1是对常量的引用</span><span class="hljs-keyword">int</span> &amp;r2 = ci; <span class="hljs-comment">// 错误：非常量引用指向一个常量对象</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>；<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i; <span class="hljs-comment">// 允许将const int&amp;绑定到一个普通的int上</span>r1 = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误</span></code></pre></div><h4 id="3-处理类型"><a href="#3-处理类型" class="headerlink" title="3. 处理类型"></a>3. 处理类型</h4><h5 id="3-1-类型别名"><a href="#3-1-类型别名" class="headerlink" title="3.1 类型别名"></a>3.1 类型别名</h5><p>某种类型的同义词，使得复杂的类型名字变得简单，易于理解和使用。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> wages; <span class="hljs-comment">// wages是double的同义词</span><span class="hljs-keyword">using</span> SI = Sales_item; <span class="hljs-comment">// SI是Sales_item的同义词</span></code></pre></div><h5 id="3-2-auto类型说明符"><a href="#3-2-auto类型说明符" class="headerlink" title="3.2 auto类型说明符"></a>3.2 auto类型说明符</h5><p>让编译器分析表达式所属的类型，必须有初始值</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> item = val1 + val2; <span class="hljs-comment">// 由val1和val2相加的结果推断item的类型</span><span class="hljs-comment">// auto一条声明语句只能有一个基础数据类型</span><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i;  <span class="hljs-comment">// 正确</span><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 错误，sz和pi的类型不一致</span></code></pre></div><h4 id="4-自定义数据结构"><a href="#4-自定义数据结构" class="headerlink" title="4. 自定义数据结构"></a>4. 自定义数据结构</h4><p>将一组相关的数据元素组织起来然后使用他们的策略和方法</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span> &#123;</span>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;  <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;  <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0</span>;&#125;Sales_data accum;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Github pages+Hexo 搭建个人博客</title>
    <link href="/posts/ae6c038e.html"/>
    <url>/posts/ae6c038e.html</url>
    
    <content type="html"><![CDATA[<h1 id="Github-pages-Hexo-搭建个人博客"><a href="#Github-pages-Hexo-搭建个人博客" class="headerlink" title="Github pages + Hexo 搭建个人博客"></a>Github pages + Hexo 搭建个人博客</h1><p>2019年11月19日，我决定开始写<strong>博客</strong>，首先要用<em>github pages+hexo</em>搭建一个个人博客，其中的过程我就记录在这里面。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>注册一个 GitHub 账户</li><li>安装 Node.js<br>下载链接<br> <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a><br> 下面这个是中文网，对于国内用户来说下载速度非常快。<br> <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a><br> 推荐菜鸟教程关于node的安装教程以及简易的语法介绍<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-install-setup.html</a><ol><li>安装git</li><li>markdown语法学习<br><a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed</a></li><li>git语法学习<br>推荐廖雪峰的git教程<br><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></li></ol></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在终端检查node和npm的版本情况</p><div class="hljs"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span>npm -v</code></pre></div><p>然后输入命令安装hexo</p><div class="hljs"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span></code></pre></div><p>我使用的是Mac电脑，在这一步出现了问题，终端显示如下</p><div class="hljs"><pre><code class="hljs coffeescript">rollbackFailedOptional verb <span class="hljs-built_in">npm</span>-session</code></pre></div><p>然后我又等了一会儿，终端又报错了。</p><div class="hljs"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> WARN checkPermissions Missing write access to /usr/local/lib/node_modules<span class="hljs-built_in">npm</span> ERR! code EACCES<span class="hljs-built_in">npm</span> ERR! syscall access<span class="hljs-built_in">npm</span> ERR! path /usr/local/lib/node_modules<span class="hljs-built_in">npm</span> ERR! errno <span class="hljs-number">-13</span><span class="hljs-built_in">npm</span> ERR! Error: EACCES: permission denied, access <span class="hljs-string">'/usr/local/lib/node_modules'</span><span class="hljs-built_in">npm</span> ERR!  [Error: EACCES: permission denied, access <span class="hljs-string">'/usr/local/lib/node_modules'</span>] &#123;<span class="hljs-built_in">npm</span> ERR!   stack: <span class="hljs-string">"Error: EACCES: permission denied, access '/usr/local/lib/node_modules'"</span>,<span class="hljs-built_in">npm</span> ERR!   errno: <span class="hljs-number">-13</span>,<span class="hljs-built_in">npm</span> ERR!   code: <span class="hljs-string">'EACCES'</span>,<span class="hljs-built_in">npm</span> ERR!   syscall: <span class="hljs-string">'access'</span>,<span class="hljs-built_in">npm</span> ERR!   path: <span class="hljs-string">'/usr/local/lib/node_modules'</span><span class="hljs-built_in">npm</span> ERR! &#125;<span class="hljs-built_in">npm</span> ERR! <span class="hljs-built_in">npm</span> ERR! The operation was rejected <span class="hljs-keyword">by</span> your operating system.<span class="hljs-built_in">npm</span> ERR! It <span class="hljs-keyword">is</span> likely you <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> have the permissions to access <span class="hljs-keyword">this</span> file <span class="hljs-keyword">as</span> the current user<span class="hljs-built_in">npm</span> ERR! <span class="hljs-built_in">npm</span> ERR! If you believe <span class="hljs-keyword">this</span> might be a permissions issue, please double-check the<span class="hljs-built_in">npm</span> ERR! permissions <span class="hljs-keyword">of</span> the file <span class="hljs-keyword">and</span> its containing directories, <span class="hljs-keyword">or</span> <span class="hljs-keyword">try</span> running<span class="hljs-built_in">npm</span> ERR! the command again <span class="hljs-keyword">as</span> root/Administrator.</code></pre></div><p>根据官方文档，如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code>权限错误，要遵循由<a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally#reinstall-npm-with-a-node-version-manager" target="_blank" rel="noopener">npmjs</a>发布的指导修复该问题。强烈建议不要使用 root、sudo 等方法覆盖权限。<br>根据要求，下载了<strong>nvm</strong>，并且在终端利用nvm下载了最新版本的node和更新了npm后，hexo下载成功了。（以下是下载和使用nvm的教程链接）<br><a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a>.        </p><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>输入以下命令hexo就会出现在指定的文件夹中</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">init &lt;folder&gt;</span><span class="hljs-attr">cd</span> <span class="hljs-string">&lt;folder&gt;</span><span class="hljs-attr">npm</span> <span class="hljs-string">install</span></code></pre></div><p>如果出现错误</p><div class="hljs"><pre><code class="hljs java">-bash: syntax error near unexpected token `newline<span class="hljs-string">'</span></code></pre></div><p>这是占位符的问题，将第一行命令的&lt;&gt;去除，再重新输入即可。</p><p>到此，建站的基本操作就完成了。</p><p>界面的设计等就可以由自己来操作了。放一个hexo的官方网站供大家参考。<br><a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration</a></p><h2 id="创建Github远程仓库"><a href="#创建Github远程仓库" class="headerlink" title="创建Github远程仓库"></a>创建Github远程仓库</h2><p>注意仓库名为github的用户名.github.io，勾选readme<br><img src="https://img-blog.csdnimg.cn/20191123194438458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dhbGFoYWR6aG91,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""></p><p>创建之后，进入仓库，点击<strong>Settings</strong>按钮，然后翻到GitHub Pages的部分，点击网页链接，就能够看到一个简易的网页了。</p><p><img src="https://img-blog.csdnimg.cn/20191123194913735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dhbGFoYWR6aG91,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""></p><h2 id="部署hexo"><a href="#部署hexo" class="headerlink" title="部署hexo"></a>部署hexo</h2><p>进入本地的hexo文件，找到 <strong>_config.yml</strong>，打开后翻到最后，修改成</p><div class="hljs"><pre><code class="hljs java">deploy:  type: git  repo:     gitHub: git<span class="hljs-meta">@github</span>.com:你的GitHub用户名/你的GitHub用户名.github.io.git  branch: master</code></pre></div><p>repo后面的内容要修改成自己github仓库的SSH密匙。</p><p>然后在终端中输入</p><div class="hljs"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span></code></pre></div><p>开始安装hexo-deploy-git，安装完成后，开始部署，在终端中输入</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo deploy</span></code></pre></div><p>部署完成。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这个时候，再次进入刚刚进入过的网页链接，就会看到一个船新版本的界面，也就是本地的hexo库已经部署到github上了。</p><p><img src="https://img-blog.csdnimg.cn/20191123195408260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dhbGFoYWR6aG91,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo写作</title>
    <link href="/posts/c4064b2b.html"/>
    <url>/posts/c4064b2b.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo写作"><a href="#Hexo写作" class="headerlink" title="Hexo写作"></a>Hexo写作</h1><p>本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。</p><a id="more"></a><h3 id="1-Hexo基本命令"><a href="#1-Hexo基本命令" class="headerlink" title="1. Hexo基本命令"></a>1. Hexo基本命令</h3><div class="hljs"><pre><code class="hljs shell">hexo g = hexo generate  #生成hexo s = hexo server  #启动本地预览hexo d = hexo deploy  #远程部署hexo n "文章标题" = hexo new "文章标题"  #新建一篇博文</code></pre></div><h3 id="2-整体配置"><a href="#2-整体配置" class="headerlink" title="2. 整体配置"></a>2. 整体配置</h3><p><code>\hexo\_config.yml</code></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Site</span>title:  # 网站名，标签页显示subtitle:  # 副标题，网站名下显示description:  # 网站描述，便于搜索keywords:author: # 作者language: zh-CN # 中文timezone: Asia/Shanghai # 时区</code></pre></div><h3 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3. 更换主题"></a>3. 更换主题</h3><p>推荐使用<code>melody</code></p><p><a href="[https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html#%E5%AE%89%E8%A3%85](https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html#安装">hexo-theme-melody快速开始</a>)</p><p>这个主题就是我现在网站使用的主题，它有完整的中文教程，功能齐全。按照教程配置就可以了。</p><h3 id="4-写作步骤"><a href="#4-写作步骤" class="headerlink" title="4. 写作步骤"></a>4. 写作步骤</h3><ol><li><p>新建文章</p><div class="hljs"><pre><code class="hljs shell">hexo new "title"</code></pre></div></li><li><p>写作</p><p><code>\hexo\source\_post</code>中找到<code>title.md</code>，使用<code>typora</code>打开</p><p>注意文章的<code>tags</code>格式是<code>[]</code></p><p>在信息栏填写<code>top_img</code>信息可以自定义该页图片情况，如<code>false</code>表示不显示</p><p><code>文章中&lt;!-- more --&gt;</code>之前的部分会显示在主页上，并出现<code>Read more</code>按钮，点击阅读更多内容</p></li></ol><ol><li><p>预览</p><div class="hljs"><pre><code class="hljs shell">hexo shexo s --debug // 在命令行生成debug信息</code></pre></div></li><li><p>同步到远程</p><div class="hljs"><pre><code class="hljs shell">hexo d -g</code></pre></div></li></ol><h3 id="5-问题"><a href="#5-问题" class="headerlink" title="5.  问题"></a>5.  问题</h3><ol><li><p>Template render error: (unknown path)</p><p>在命令行输入<code>hexo -g</code>后报错，原因在于文章内容中有<strong>{}</strong>时，如果它没有被代码块包括，解析会出现错误，所以需要写成</p><div class="hljs"><pre><code class="hljs routeros">&#123;%<span class="hljs-built_in"> raw </span>%&#125;</code></pre></div></li><li><p>本地预览与远程显示不一致</p><p>删除缓存</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span></code></pre></div><p>在网页上刷新</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基本语法</title>
    <link href="/posts/6b599344.html"/>
    <url>/posts/6b599344.html</url>
    
    <content type="html"><![CDATA[<h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><p>本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。</p><a id="more"></a><h1 id="一、-变量"><a href="#一、-变量" class="headerlink" title="一、 变量"></a>一、 变量</h1><h2 id="1-用sizeof运算符求某一类型或变量占据的字节数"><a href="#1-用sizeof运算符求某一类型或变量占据的字节数" class="headerlink" title="1. 用sizeof运算符求某一类型或变量占据的字节数"></a>1. 用sizeof运算符求某一类型或变量占据的字节数</h2><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// sizeof运算符可以求变量占据的字节数</span>    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 未初始化的变量，其值是不确定的</span>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre></div><h2 id="2-数据类型的自动转换"><a href="#2-数据类型的自动转换" class="headerlink" title="2. 数据类型的自动转换"></a>2. 数据类型的自动转换</h2><h3 id="1-数"><a href="#1-数" class="headerlink" title="1. 数"></a>1. 数</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">11.34</span>; <span class="hljs-comment">// 11.34被自动转化为11后赋值给a</span><span class="hljs-keyword">int</span> b = <span class="hljs-number">30</span>;<span class="hljs-keyword">double</span> d = b; <span class="hljs-comment">// d的值是30.0</span></code></pre></div><h3 id="2-字符类型与整型"><a href="#2-字符类型与整型" class="headerlink" title="2. 字符类型与整型"></a>2. 字符类型与整型</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> k = <span class="hljs-string">'a'</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, k); <span class="hljs-comment">// 输出97，即a的ASCII码</span><span class="hljs-keyword">int</span> n = <span class="hljs-number">98</span>;<span class="hljs-keyword">char</span> k = n;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, k); <span class="hljs-comment">// 输出b</span></code></pre></div><h2 id="3-输入和输出"><a href="#3-输入和输出" class="headerlink" title="3. 输入和输出"></a>3. 输入和输出</h2><h4 id="1-scanf和printf"><a href="#1-scanf和printf" class="headerlink" title="1. scanf和printf"></a>1. scanf和printf</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt; //使用scanf和printf时需要使用该库</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">float</span> m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%c%f"</span>, &amp;n, &amp;c, &amp;m);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %c %f\n"</span>, n, c, m);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>用scanf可以一次读入多个不同类型的变量，输入各项用空格隔开<br>        注意在输入<strong>字符</strong>时，不会跳过空格（空格也会被当做字符读入）<br>        输入其它数据时，会跳过空格</p><h4 id="2-cin和cout"><a href="#2-cin和cout" class="headerlink" title="2. cin和cout"></a>2. cin和cout</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> c;    <span class="hljs-keyword">while</span> ((c=<span class="hljs-built_in">cin</span>.get()) != EOF) &#123;         <span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">char</span>) c;     &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>使用cin读入所有字符，包括空格和回车，EOF<br>        Mac（ctrl+D停止输入，ctrl+C停止程序)<br>        windows ctrl+Z停止</p><h4 id="3-cin-amp-cout-scanf-amp-printf-比较"><a href="#3-cin-amp-cout-scanf-amp-printf-比较" class="headerlink" title="3. cin&amp;cout / scanf&amp;printf 比较"></a>3. cin&amp;cout / scanf&amp;printf 比较</h4><ul><li>cin，cout速度慢，输入输出数据量大时用scanf/printf</li><li>一个程序不要同时出现cin和scanf，cout和prinf</li></ul><h2 id="4-运算"><a href="#4-运算" class="headerlink" title="4. 运算"></a>4. 运算</h2><ol><li>加、减、乘运算的溢出</li></ol><hr><h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><h3 id="1-数组作为函数的参数传递"><a href="#1-数组作为函数的参数传递" class="headerlink" title="1. 数组作为函数的参数传递"></a>1. 数组作为函数的参数传递</h3><p>数组作为函数的参数时，是传引用的，即<strong>形参数组改变了，实参数组也会改变</strong></p><p>二维数组作为函数的形参时，<strong>必须写明函数有多少列</strong>，不要写明有多少行</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[][<span class="hljs-number">5</span>])</span> </span>&#123;  <span class="hljs-built_in">cout</span> &lt;&lt; a[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>];&#125;</code></pre></div><p>必须要写明列数，编译器才能够根据下标算出元素的地址</p><div class="hljs"><pre><code class="hljs markdown">$\color&#123;#F00&#125;&#123;a[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]的地址 = 数组首地址 + i \times N \times sizeof(a[<span class="hljs-string">0</span>][<span class="hljs-symbol">0</span>]) + j \times sizeof(a[<span class="hljs-string">0</span>][<span class="hljs-symbol">0</span>])&#125;$ (N是数组列数)</code></pre></div><p>形参数组的首地址就是实参数组的首地址      </p><h1 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h1><h2 id="1-字符串的形式"><a href="#1-字符串的形式" class="headerlink" title="1. 字符串的形式"></a>1. 字符串的形式</h2><h3 id="（1）字符串常量"><a href="#（1）字符串常量" class="headerlink" title="（1）字符串常量"></a>（1）字符串常量</h3><p>用双引号括起来的，如”China”, “C++ program”.</p><p>字符串常量占据<strong>内存</strong>的字节数等于字符中字符数目加1，结尾多出字符’\0’.</p><font color=#F00>但是字符串的长度不包含'\0'</font><p>“”也是合法的·1字符串常量，称为空串，仍然占据一个字节的内存空间，存放’\0’</p><h3 id="（2）存放于字符数组中，以’-0’结尾"><a href="#（2）存放于字符数组中，以’-0’结尾" class="headerlink" title="（2）存放于字符数组中，以’\0’结尾"></a>（2）存放于字符数组中，以’\0’结尾</h3><p>用一维char数组存放字符串，结尾是’\0’，数组元素个数至少为<font color=#F00>字符串长度+1</font>。</p><p>用cin、scanf将字符串读入字符数组时，会自动在字符数组中字符串的末尾加上’\0’。</p><h3 id="（3）string对象。"><a href="#（3）string对象。" class="headerlink" title="（3）string对象。"></a>（3）string对象。</h3><p>string是C++标准模板库里的一个类，专门用于处理字符串</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
