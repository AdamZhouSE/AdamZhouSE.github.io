<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++字符串,向量和数组</title>
    <url>/posts/869e4b19.html</url>
    <content><![CDATA[<h3 id="二、字符串，向量和数组"><a href="#二、字符串，向量和数组" class="headerlink" title="二、字符串，向量和数组"></a>二、字符串，向量和数组</h3><p>作用域操作符<code>::</code></p>
<p>含义：编译器应从操作符左侧的作用域中寻找右边那个名字</p>
<p>比如<code>std::cin</code>是要使用命名空间<code>std</code>中的<code>cin</code></p>
<p>这样做是为了避免某些名字被重复使用</p>
<p>使用<code>using</code>声明可以更加简便的使用命名空间中的成员。</p>
<a id="more"></a>
<h4 id="1-String类型"><a href="#1-String类型" class="headerlink" title="1. String类型"></a>1. String类型</h4><p>表示可变长的字符串</p>
<h5 id="1-1-定义和初始化"><a href="#1-1-定义和初始化" class="headerlink" title="1.1 定义和初始化"></a>1.1 定义和初始化</h5><ol>
<li><p>使用需要头文件和命名空间</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>;</code></pre>
</li>
<li><p>初始化</p>
<pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1; <span class="hljs-comment">// 空字符串</span>
<span class="hljs-built_in">string</span> s2 = s1; <span class="hljs-comment">// s2是s1的副本</span>
<span class="hljs-built_in">string</span> s3 = <span class="hljs-string">&quot;abc&quot;</span>;
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>; <span class="hljs-comment">// 十个c</span></code></pre>
</li>
</ol>
<h5 id="1-2-string对象上的操作"><a href="#1-2-string对象上的操作" class="headerlink" title="1.2 string对象上的操作"></a>1.2 string对象上的操作</h5><ol>
<li><p>使用<code>getline</code>读取一整行</p>
<pre><code class="hljs cpp"><span class="hljs-built_in">string</span> line;
getline(<span class="hljs-built_in">cin</span>, line);</code></pre>
<p>当读取到换行符时结束，并将读到的内容存入<code>string</code>中，但是<strong>不存换行符</strong></p>
</li>
<li><p><code>empty</code>和<code>size</code>操作</p>
<p><code>str.empty()</code>根据字符串是否为空返回一个布尔值</p>
<p><code>str.size()</code>返回字符串长度</p>
<p>使用visual studio编程的时候，碰到过一个<strong>warning</strong>，将无符号数赋值给了有符号数。</p>
<p>这是由于<code>size</code>函数的返回值类型引起的，它是一个<code>string::size_type</code>类型的值，是无符号类型的，</p>
<p>可以用<code>auto</code>来推断变量的值</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> len = str.size();</code></pre>
</li>
<li><p>比较，赋值，相加</p>
<pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">&quot;abc&quot;</span>;
<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">&quot;xcvd&quot;</span>;
<span class="hljs-comment">// s1 &lt; s2 比较第一个不同的字符</span>
<span class="hljs-built_in">string</span> s3 = s1; <span class="hljs-comment">// 赋值</span>
<span class="hljs-built_in">string</span> s4 = s1 + s2; <span class="hljs-comment">// abcxcvd</span></code></pre>
</li>
<li><p>处理<code>string</code>中的字符</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cctype&gt;</span></span>
<span class="hljs-built_in">isalnum</span>(c);
<span class="hljs-built_in">isalpha</span>(c);
<span class="hljs-built_in">islower</span>(c);
<span class="hljs-built_in">isupper</span>(c);
<span class="hljs-built_in">ispunct</span>(c); <span class="hljs-comment">// 是标点符号为真</span></code></pre>
</li>
</ol>
<h4 id="2-Vector类型"><a href="#2-Vector类型" class="headerlink" title="2. Vector类型"></a>2. Vector类型</h4><p>可变长数组，类似于Java中的<code>ArrayList</code></p>
<h5 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h5><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;T&gt; v;
<span class="hljs-built_in">vector</span>&lt;T&gt; v1 = &#123;a, b, c&#125;; <span class="hljs-comment">// 注意是花括号</span>
<span class="hljs-built_in">vector</span>&lt;T&gt; v2&#123;a, b&#125;;     <span class="hljs-comment">// 花括号，两个元素</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 圆括号 10个元素，每个初始化为1</span></code></pre>
<h5 id="2-2-操作"><a href="#2-2-操作" class="headerlink" title="2.2 操作"></a>2.2 操作</h5><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
v.push_back(<span class="hljs-number">1</span>); <span class="hljs-comment">// 添加1</span>
v.pop_back(); <span class="hljs-comment">// 去掉最后一个数据</span>
v.empty();
v.size();
v[n]; <span class="hljs-comment">// 注意下标只能访问，但是不能够添加元素</span></code></pre>
<h4 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h4><p>访问元素的作用</p>
<pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;abcde&quot;</span>;
<span class="hljs-keyword">if</span> (s.begin() != s.end()) &#123; <span class="hljs-comment">// 确保s非空</span>
  
&#125;</code></pre>
<h4 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h4><h5 id="4-1-指针和数组"><a href="#4-1-指针和数组" class="headerlink" title="4.1 指针和数组"></a>4.1 指针和数组</h5><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">p</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">// 整型指针，指向ia的第一个元素</span>
p++; <span class="hljs-comment">// 指向第一个元素</span></code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基本语法</title>
    <url>/posts/6b599344.html</url>
    <content><![CDATA[<h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><p>本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。</p>
<a id="more"></a>
<h1 id="一、-变量"><a href="#一、-变量" class="headerlink" title="一、 变量"></a>一、 变量</h1><h2 id="1-用sizeof运算符求某一类型或变量占据的字节数"><a href="#1-用sizeof运算符求某一类型或变量占据的字节数" class="headerlink" title="1. 用sizeof运算符求某一类型或变量占据的字节数"></a>1. 用sizeof运算符求某一类型或变量占据的字节数</h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> a;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// sizeof运算符可以求变量占据的字节数</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 未初始化的变量，其值是不确定的</span>
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;
&#125;</code></pre>
<h2 id="2-数据类型的自动转换"><a href="#2-数据类型的自动转换" class="headerlink" title="2. 数据类型的自动转换"></a>2. 数据类型的自动转换</h2><h3 id="1-数"><a href="#1-数" class="headerlink" title="1. 数"></a>1. 数</h3><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">11.34</span>; <span class="hljs-comment">// 11.34被自动转化为11后赋值给a</span>
<span class="hljs-keyword">int</span> b = <span class="hljs-number">30</span>;
<span class="hljs-keyword">double</span> d = b; <span class="hljs-comment">// d的值是30.0</span></code></pre>
<h3 id="2-字符类型与整型"><a href="#2-字符类型与整型" class="headerlink" title="2. 字符类型与整型"></a>2. 字符类型与整型</h3><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> k = <span class="hljs-string">&#x27;a&#x27;</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, k); <span class="hljs-comment">// 输出97，即a的ASCII码</span>
<span class="hljs-keyword">int</span> n = <span class="hljs-number">98</span>;
<span class="hljs-keyword">char</span> k = n;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, k); <span class="hljs-comment">// 输出b</span></code></pre>
<h2 id="3-输入和输出"><a href="#3-输入和输出" class="headerlink" title="3. 输入和输出"></a>3. 输入和输出</h2><h4 id="1-scanf和printf"><a href="#1-scanf和printf" class="headerlink" title="1. scanf和printf"></a>1. scanf和printf</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt; //使用scanf和printf时需要使用该库</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">char</span> c;
    <span class="hljs-keyword">float</span> m;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%c%f&quot;</span>, &amp;n, &amp;c, &amp;m);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %c %f\n&quot;</span>, n, c, m);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>用scanf可以一次读入多个不同类型的变量，输入各项用空格隔开<br>        注意在输入<strong>字符</strong>时，不会跳过空格（空格也会被当做字符读入）<br>        输入其它数据时，会跳过空格</p>
<h4 id="2-cin和cout"><a href="#2-cin和cout" class="headerlink" title="2. cin和cout"></a>2. cin和cout</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> c;
    <span class="hljs-keyword">while</span> ((c=<span class="hljs-built_in">cin</span>.get()) != EOF) &#123; 
        <span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">char</span>) c; 
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>使用cin读入所有字符，包括空格和回车，EOF<br>        Mac（ctrl+D停止输入，ctrl+C停止程序)<br>        windows ctrl+Z停止</p>
<h4 id="3-cin-amp-cout-scanf-amp-printf-比较"><a href="#3-cin-amp-cout-scanf-amp-printf-比较" class="headerlink" title="3. cin&amp;cout / scanf&amp;printf 比较"></a>3. cin&amp;cout / scanf&amp;printf 比较</h4><ul>
<li>cin，cout速度慢，输入输出数据量大时用scanf/printf</li>
<li>一个程序不要同时出现cin和scanf，cout和prinf</li>
</ul>
<h2 id="4-运算"><a href="#4-运算" class="headerlink" title="4. 运算"></a>4. 运算</h2><ol>
<li>加、减、乘运算的溢出</li>
</ol>
<hr>
<h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><h3 id="1-数组作为函数的参数传递"><a href="#1-数组作为函数的参数传递" class="headerlink" title="1. 数组作为函数的参数传递"></a>1. 数组作为函数的参数传递</h3><p>数组作为函数的参数时，是传引用的，即<strong>形参数组改变了，实参数组也会改变</strong></p>
<p>二维数组作为函数的形参时，<strong>必须写明函数有多少列</strong>，不要写明有多少行</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[][<span class="hljs-number">5</span>])</span> </span>&#123;
  <span class="hljs-built_in">cout</span> &lt;&lt; a[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>];
&#125;</code></pre>
<p>必须要写明列数，编译器才能够根据下标算出元素的地址</p>
<pre><code class="hljs markdown">$\color&#123;#F00&#125;&#123;a[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]的地址 = 数组首地址 + i \times N \times sizeof(a[<span class="hljs-string">0</span>][<span class="hljs-symbol">0</span>]) + j \times sizeof(a[<span class="hljs-string">0</span>][<span class="hljs-symbol">0</span>])&#125;$ (N是数组列数)</code></pre>
<p>形参数组的首地址就是实参数组的首地址      </p>
<h1 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h1><h2 id="1-字符串的形式"><a href="#1-字符串的形式" class="headerlink" title="1. 字符串的形式"></a>1. 字符串的形式</h2><h3 id="（1）字符串常量"><a href="#（1）字符串常量" class="headerlink" title="（1）字符串常量"></a>（1）字符串常量</h3><p>用双引号括起来的，如”China”, “C++ program”.</p>
<p>字符串常量占据<strong>内存</strong>的字节数等于字符中字符数目加1，结尾多出字符’\0’.</p>
<font color=#F00>但是字符串的长度不包含'\0'</font>

<p>“”也是合法的·1字符串常量，称为空串，仍然占据一个字节的内存空间，存放’\0’</p>
<h3 id="（2）存放于字符数组中，以’-0’结尾"><a href="#（2）存放于字符数组中，以’-0’结尾" class="headerlink" title="（2）存放于字符数组中，以’\0’结尾"></a>（2）存放于字符数组中，以’\0’结尾</h3><p>用一维char数组存放字符串，结尾是’\0’，数组元素个数至少为<font color=#F00>字符串长度+1</font>。</p>
<p>用cin、scanf将字符串读入字符数组时，会自动在字符数组中字符串的末尾加上’\0’。</p>
<h3 id="（3）string对象。"><a href="#（3）string对象。" class="headerlink" title="（3）string对象。"></a>（3）string对象。</h3><p>string是C++标准模板库里的一个类，专门用于处理字符串</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++变量和基本类型</title>
    <url>/posts/96db5496.html</url>
    <content><![CDATA[<h3 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h3><h4 id="1-复合类型-Compound-type"><a href="#1-复合类型-Compound-type" class="headerlink" title="1. 复合类型(Compound type)"></a>1. 复合类型(Compound type)</h4><p>基于其它类型定义的类型</p>
<h5 id="1-1-引用-Reference"><a href="#1-1-引用-Reference" class="headerlink" title="1.1 引用(Reference)"></a>1.1 引用(Reference)</h5><p><strong>引用</strong>为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。</p>
<a id="more"></a>
<p>(在这里，引用指的是左值引用)</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">int</span> &amp;refval = ival; <span class="hljs-comment">// refval指向ival，是ival的另外一个名字</span>
<span class="hljs-keyword">int</span> &amp;refVal2; <span class="hljs-comment">// 报错；引用必须被初始化</span></code></pre>
<p>定义引用时，程序把引用和它的初始值<strong>绑定</strong>在一起，而不是将初始值拷贝给引用。（与初始化变量时不同的）</p>
<p>无法令引用重新绑定到另一个对象，所以引用必须被<font color=red><strong>初始化</strong> </font></p>
<ul>
<li>引用即别名，它不是对象，而是为了一个已经存在的对象起了另外一个名字</li>
</ul>
<p>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的</p>
<pre><code class="hljs cpp">refVal = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 把2赋值给与refVal绑定的对象上，这里就是绑定到iVal上</span>
<span class="hljs-keyword">int</span> ii = refVal;</code></pre>
<p> 除了两种特殊情况，其它所有引用的类型都要与之绑定的对象严格匹配。不能够与字面值或表达式的计算结果绑定。</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> &amp;refVal4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误：引用对象初始值必须是一个对象</span>
<span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;
<span class="hljs-keyword">int</span> &amp;refVal5 = dval; <span class="hljs-comment">// 错误：此处引用类型的初始值必须是int型对象</span></code></pre>
<h5 id="1-2-指针"><a href="#1-2-指针" class="headerlink" title="1.2 指针"></a>1.2 指针</h5><p><strong>指针</strong>是指向另外一种类型的符合类型，与引用类似，指针实现了对其它对象的间接访问。</p>
<p>不同：</p>
<ul>
<li>指针本身是一个对象</li>
<li>指针无需在定义时赋初值</li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ip1; <span class="hljs-comment">// ip1是指向int对象的指针</span></code></pre>
<h6 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h6><p>指针存放某个对象的地址。</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">42</span>;
<span class="hljs-keyword">int</span> *p = &amp;ival; <span class="hljs-comment">// p是存放变量ival的地址，或者说p是指向引用的指针。</span></code></pre>
<h6 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h6><p>指针的值（即地址）应该属于下列4中状态之一：</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针</li>
<li>无效指针</li>
</ul>
<h6 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h6><p>如果指针指向了一个对象，可以使用<strong>解引用符</strong>（操作符*）来访问对象</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">42</span>;
<span class="hljs-keyword">int</span> *p = &amp;ival;
<span class="hljs-built_in">cout</span> &lt;&lt; *p <span class="hljs-comment">// 输出42</span>
*p = <span class="hljs-number">0</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; *p <span class="hljs-comment">// 输出0，为*p赋值实际上是为p所指的对象赋值</span></code></pre>
<h6 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h6><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p1 = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">int</span> *p2 = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> *p3 = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 需要头文件cstdlib</span></code></pre>
<h6 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a>void*指针</h6><p>用于存放任意对象的地址，不能直接操作void*指针所指的对象</p>
<h6 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h6><h6 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h6><p>指针是对象，所以存在对指针的引用</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;
<span class="hljs-keyword">int</span> *p;
<span class="hljs-keyword">int</span> *&amp;r = p;  <span class="hljs-comment">// r是一个对p的引用</span>
r = &amp;i;  <span class="hljs-comment">// r引用了一个指针，因此给r赋值&amp;就是令p指向i</span>
*r = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 将i的值改为0</span></code></pre>
<h4 id="2-const限定符"><a href="#2-const限定符" class="headerlink" title="2. const限定符"></a>2. const限定符</h4><p>值不能被改变，所以const对象必须被初始化</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = <span class="hljs-number">512</span>; <span class="hljs-comment">// 输入缓冲区大小</span></code></pre>
<p>如果要在多个文件之间共享const，必须在变量定义前加extern关键字</p>
<h5 id="2-1-对const的引用"><a href="#2-1-对const的引用" class="headerlink" title="2.1 对const的引用"></a>2.1 对const的引用</h5><p>对常量的引用，不能够修改其绑定的对象</p>
<p>对const的引用可以使一个并非const的对象，但是不能通过其改变值</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = ci; <span class="hljs-comment">// 正确</span>

r1 = <span class="hljs-number">42</span>; <span class="hljs-comment">// 错误：r1是对常量的引用</span>
<span class="hljs-keyword">int</span> &amp;r2 = ci; <span class="hljs-comment">// 错误：非常量引用指向一个常量对象</span>

<span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>；
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i; <span class="hljs-comment">// 允许将const int&amp;绑定到一个普通的int上</span>
r1 = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误</span></code></pre>
<h4 id="3-处理类型"><a href="#3-处理类型" class="headerlink" title="3. 处理类型"></a>3. 处理类型</h4><h5 id="3-1-类型别名"><a href="#3-1-类型别名" class="headerlink" title="3.1 类型别名"></a>3.1 类型别名</h5><p>某种类型的同义词，使得复杂的类型名字变得简单，易于理解和使用。</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> wages; <span class="hljs-comment">// wages是double的同义词</span>
<span class="hljs-keyword">using</span> SI = Sales_item; <span class="hljs-comment">// SI是Sales_item的同义词</span></code></pre>
<h5 id="3-2-auto类型说明符"><a href="#3-2-auto类型说明符" class="headerlink" title="3.2 auto类型说明符"></a>3.2 auto类型说明符</h5><p>让编译器分析表达式所属的类型，必须有初始值</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> item = val1 + val2; <span class="hljs-comment">// 由val1和val2相加的结果推断item的类型</span>
<span class="hljs-comment">// auto一条声明语句只能有一个基础数据类型</span>
<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i;  <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 错误，sz和pi的类型不一致</span></code></pre>
<h4 id="4-自定义数据结构"><a href="#4-自定义数据结构" class="headerlink" title="4. 自定义数据结构"></a>4. 自定义数据结构</h4><p>将一组相关的数据元素组织起来然后使用他们的策略和方法</p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span> &#123;</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;
  <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0</span>;
&#125;

Sales_data accum;</code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo个人博客绑定域名和配置SSL证书</title>
    <url>/posts/2cd2c226.html</url>
    <content><![CDATA[<h1 id="Hexo-个人博客绑定域名和配置SSL证书"><a href="#Hexo-个人博客绑定域名和配置SSL证书" class="headerlink" title="Hexo 个人博客绑定域名和配置SSL证书"></a>Hexo 个人博客绑定域名和配置SSL证书</h1><p>在完成个人博客的搭建以后，我们可以通过一个<code>https://xxx.github.io</code>形式的链接在访问我们的个人博客网站，那么如果想拥有一个个性的域名，该如何操作呢？</p>
<a id="more"></a>
<h2 id="一、-绑定域名"><a href="#一、-绑定域名" class="headerlink" title="一、 绑定域名"></a>一、 绑定域名</h2><h3 id="1-购买"><a href="#1-购买" class="headerlink" title="1. 购买"></a>1. 购买</h3><p>域名可以在阿里云或者腾讯云上购买，不同形式的有不同的价格，根据自己的情况购买即可。我在腾讯云上购买了我现在的域名<code>zhouzhuyan.com</code></p>
<p><strong>注意</strong>：如果不使用国内的服务器的话不用备案，只要完成实名认证就可以了。</p>
<p>现在实名认证，审核都很快，虽然说一个工作日审批，但是我的话几分钟成功了。在域名的状态显示正常以后，就可以使用了。</p>
<p><img src="https://blogofzzy-1301797566.cos.ap-shanghai.myqcloud.com/domainname1.png" alt=""></p>
<h3 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title="2. 域名解析"></a>2. 域名解析</h3><p>这个时候，网站时访问不了的，因为还需要去解析你的域名，将你的域名指向你的个人网站。</p>
<p>到腾讯云控制台的域名管理界面，找到你的域名，点击解析，选择添加记录</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>主机记录</th>
<th>记录类型</th>
<th>线路类型</th>
<th>记录值</th>
</tr>
</thead>
<tbody>
<tr>
<td>www</td>
<td>CNAME</td>
<td>默认</td>
<td>你的Github项目仓库名</td>
</tr>
<tr>
<td>@</td>
<td>CNAME</td>
<td>默认</td>
<td>你的Github项目仓库名</td>
</tr>
</tbody>
</table>
</div>
<p>两个主机记录是为了让你的网站在有<code>www</code>和没有的情况下都可以访问，仓库名可以在Github仓库的<code>Settings</code>里面找到。解析需要10分钟，耐心等待。</p>
<h3 id="3-在项目中更换"><a href="#3-在项目中更换" class="headerlink" title="3. 在项目中更换"></a>3. 在项目中更换</h3><p>到Github中找到自己的网站所在的仓库，进入<code>Settings</code>界面</p>
<p><img src="https://blogofzzy-1301797566.cos.ap-shanghai.myqcloud.com/2020-04-09domainname2.png" alt=""></p>
<p>在<code>Custom domain</code>里面填写自己的域名，选择<code>save</code>，这样就会出现上图的形式，显示<code>Your site is published at https://你的域名</code>，勾选<code>Enforce HTTPS</code></p>
<h3 id="4-创建CNAME文件"><a href="#4-创建CNAME文件" class="headerlink" title="4. 创建CNAME文件"></a>4. 创建CNAME文件</h3><p>进入你的Hexo本地文件所在的根目录，找到<code>\source</code>目录，在里面创建一个文件<code>CNAME</code>，注意它是没有类型的，不是<code>.txt</code>。</p>
<p>在里面加入你的域名，注意不要在前面加入<code>https</code> <code>www</code>这样的前缀，就是你的域名。</p>
<p>然后<code>hexo d -g</code>部署你的网站，等待一段时间后，就可以通过你的个性域名访问网站了。</p>
<hr>
<h2 id="二、-SSL安全证书"><a href="#二、-SSL安全证书" class="headerlink" title="二、 SSL安全证书"></a>二、 SSL安全证书</h2><p>注册好域名后，用google访问时，可能会出现<strong>您访问的不是安全链接</strong>的提示，或者能够正常访问，但是域名旁边显示的是一个感叹号，表示不安全，这是因为我们还没有申请安全证书，在申请了证书之后，域名旁边显示的就是一把锁，表示安全。</p>
<p>腾讯云和阿里云都提供免费的SSL证书下载，具体安装也有相关的文档，按照步骤操作就行。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/400/35244">腾讯云Nginx服务器证书安装</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/026d67cc6cb1">Mac下nginx的使用</a></p>
<p>在证书安装好了以后，可以看到域名解析里面多出了一条TXT类型的解析。</p>
<p>在Chrome浏览器中，打开网站后如果仍然显示不安全，即没有出现锁的图标，右击选择检查元素，进入开发者模式，看<code>Security</code>里面有什么问题。</p>
<p><strong>踩坑</strong>：我发现我用阿里云图床的图片引用的是http头，把它改为<code>https</code>，锁就出现了。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Permalink简化</title>
    <url>/posts/838443af.html</url>
    <content><![CDATA[<h1 id="Permalink简化"><a href="#Permalink简化" class="headerlink" title="Permalink简化"></a>Permalink简化</h1><p>在文档名有中文的时候，因为汉字会被转义，默认的永久链接会非常复杂，具体原因可以看这一篇文章</p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html">阮一峰 关于url编码</a></p>
<p>有两种方法优化。</p>
<a id="more"></a>
<h2 id="方法一：自定义"><a href="#方法一：自定义" class="headerlink" title="方法一：自定义"></a>方法一：自定义</h2><p>首先，在<code>scaffolds</code>的<code>post.md</code>中，加入<code>urlname</code>元素。</p>
<pre><code class="hljs subunit">title: &#123;&#123; title &#125;&#125;
urlname:
date: &#123;&#123; date &#125;&#125;
<span class="hljs-keyword">tags:</span>
categories:</code></pre>
<p>然后，在配置文件<code>_config.yml</code>中，将永久链接<code>permalink</code>的形式改为</p>
<pre><code class="hljs elixir"><span class="hljs-symbol">permalink:</span> <span class="hljs-symbol">:category/</span><span class="hljs-symbol">:urlname/</span></code></pre>
<p>也就是类别加上自定义的url链接。</p>
<p>每次写文章时，可以自己设计该页的<code>url</code>，使得它变得简单，同时也利于区分。</p>
<p>但是，这种修改方法的链接会随着文件目录的改变而改变，</p>
<p>比如一篇文章<code>HelloWorld.md</code>本来放在<code>_posts</code>目录下，链接为<code>https://xxx/_posts/HelloWorld.md</code></p>
<p>之后归类到<code>_posts/A</code>目录下，那么链接变为<code>https://xxx/_posts/A/HelloWorld.md</code></p>
<p>这样不太利于分享，所以推荐使用第二种方法。</p>
<h2 id="方法二：插件"><a href="#方法二：插件" class="headerlink" title="方法二：插件"></a>方法二：插件</h2><p>使用<code>hexo-abbrlink</code>这个插件</p>
<ol>
<li><p>安装</p>
<pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-abbrlink <span class="hljs-comment">--save</span></code></pre>
</li>
<li><p>设置</p>
<p>在<code>_config.yml</code>文件中修改永久链接格式</p>
<pre><code class="hljs dts"><span class="hljs-symbol">permalink:</span> posts/:abbrlink.html
<span class="hljs-symbol">abbrlink:</span>
<span class="hljs-symbol">  alg:</span> crc32  <span class="hljs-meta"># 算法：crc16(default) and crc32</span>
<span class="hljs-symbol">  rep:</span> hex    <span class="hljs-meta"># 进制：dec(default) and hex</span></code></pre>
<p><code>posts</code>部分是可以更改的，也可以仿照方法一添加一个关键词便于识别</p>
<pre><code class="hljs elixir"><span class="hljs-symbol">permalink:</span> <span class="hljs-symbol">:keywords/</span><span class="hljs-symbol">:abbrlink</span>.html</code></pre>
</li>
<li><p>生成</p>
<p>在根目录创建<code>Gruntfile.js</code>文件，让插件到<code>source/_posts/</code>下读取所有的.md文件，把文件中的@@abbrlink替换成文件内容的hash值。</p>
<pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">grunt</span>) </span>&#123;
 
  grunt.initConfig(&#123;

    rewrite: &#123;
      abbrlink: &#123;
        src: <span class="hljs-string">&#x27;source/_posts/**/*.md&#x27;</span>,
        editor: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">contents, filepath</span>)</span>&#123;
          <span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);
          <span class="hljs-keyword">const</span> hash = crypto.createHash(<span class="hljs-string">&#x27;sha256&#x27;</span>);

          hash.update(contents);
          <span class="hljs-keyword">var</span> hashValue = hash.digest(<span class="hljs-string">&#x27;hex&#x27;</span>);

          <span class="hljs-keyword">return</span> contents.replace(<span class="hljs-regexp">/@@abbrlink/g</span>, hashValue.substring(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>));
        &#125;
      &#125;,
    &#125;,
  &#125;);
 
  grunt.loadNpmTasks(<span class="hljs-string">&#x27;grunt-rewrite&#x27;</span>);
&#125;;</code></pre>
</li>
</ol>
<p>这种方法生成的链接是不带目录的，直接就是第二步设置中<code>permalink</code>的样式，所以也没有了被改变的风险。</p>
<p>参考</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://blog.jvaeyhcd.wang/posts/05c9df7e0c47bd64.html">http://blog.jvaeyhcd.wang/posts/05c9df7e0c47bd64.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo部署到云服务器</title>
    <url>/posts/e80e623c.html</url>
    <content><![CDATA[<h3 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h3><p>博客的搭建和域名的绑定可以参考我以前的博客。<br><a href="https://zhouzhuyan.com/posts/ae6c038e.html">使用Github pages + Hexo搭建个人博客</a><br><a href="https://zhouzhuyan.com/posts/2cd2c226.html">Hexo个人博客绑定域名</a></p>
<p>由于博客是基于Github pages搭建的，所以在国内的访问速度比较慢，可以部署到云服务器上加快访问的速度，我使用的是<a target="_blank" rel="noopener" href="https://cloud.tencent.com/act/campus">腾讯云学生机</a>。注意在国内使用云服务器部署网站需要对网站进行备案，详细步骤可以参考腾讯的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/243">官方文档</a>。在备案完成后，就可以进行网站的部署了。</p>
<h3 id="1-配置git"><a href="#1-配置git" class="headerlink" title="1.  配置git"></a>1.  配置git</h3><p><strong>Tip</strong><br>我的服务器型号是<code>CentOS 7.5</code></p>
<h4 id="1-1-安装git"><a href="#1-1-安装git" class="headerlink" title="1.1 安装git"></a>1.1 安装git</h4><pre><code class="hljs shell">yum install -y git</code></pre>
<p>看到complete字样说明安装完成了，可以通过如下命令验证</p>
<pre><code class="hljs shell">git --version</code></pre>
<p>出现版本则说明安装成功。</p>
<h4 id="1-2-创建git账户"><a href="#1-2-创建git账户" class="headerlink" title="1.2 创建git账户"></a>1.2 创建git账户</h4><pre><code class="hljs shell">adduser git
passwd git</code></pre>
<p>注意一定要有第二步<code>passwd git</code>，这是给git账户设置密码，否则账户不会使用。</p>
<h4 id="1-3-设置免密登录git"><a href="#1-3-设置免密登录git" class="headerlink" title="1.3 设置免密登录git"></a>1.3 设置免密登录git</h4><p>使用<code>su</code>命令切换至git用户，并进入用户git的根目录</p>
<pre><code class="hljs shell">su git
cd</code></pre>
<p>创建<code>~/.ssh</code>文件夹和<code>~/.ssh/authorized_keys</code>文件</p>
<pre><code class="hljs shell">mkdir ~/.ssh
touch ~/.ssh/authorized_keys</code></pre>
<p>将本地的<code>id_rsa.pub</code>文件中的公匙复制到<code>authorized_keys</code>文件中，在mac中，该文件的地址是<code>/Users/你的用户名/.ssh/id_rsa.pub</code>，可以在终端中使用如下命令打开<code>.ssh</code>文件夹，然后使用vs code打开该文件</p>
<pre><code class="hljs shell">open /Users/galahad/.ssh</code></pre>
<p>复制其中的内容，然后打开<code>authorized_keys</code>文件</p>
<pre><code class="hljs shell">vi ~/.ssh/authorized_keys</code></pre>
<p>按<code>i</code>进入插入模式，复制内容<br>按<code>esc</code>键进入命令模式，输入<code>:wq</code>保存并退出<br>最后对文件赋予对应的权限</p>
<pre><code class="hljs shell">chmod 600 /home/git/.ssh/authorized_keys
chmod 700 /home/git/.ssh</code></pre>
<p>这样就可以使得本地终端可以免密登录git用户，可以在本地终端使用ssh远程连接测试</p>
<pre><code class="hljs shell">ssh git@你的IP</code></pre>
<p>如果仍需输入密码，那说明配置有问题，可以重新按照1.3的步骤再配置一遍，当然，1.3的部分不是必须的，这只是为了在本地提交文件到服务器的时候不用输入密码，省点儿力气。</p>
<h4 id="1-4-配置git仓库"><a href="#1-4-配置git仓库" class="headerlink" title="1.4 配置git仓库"></a>1.4 配置git仓库</h4><p>在git用户的根目录下创建hexo存储的目录</p>
<pre><code class="hljs shell">mkdir -p projects/blog</code></pre>
<p>再创建一个git仓库，并初始化一个仓库</p>
<pre><code class="hljs shell">mkdir repos
cd repos
git init --bare blog.git</code></pre>
<p>之后，在<code>blog.git</code>文件夹下会产生一个<code>hooks</code>文件夹，在其中创建一个文件<code>post-receive</code>，在其中配置一个钩子</p>
<pre><code class="hljs shell">cd blog.git/hooks
vi post-receive</code></pre>
<p>将如下内容复制到其中</p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span>
git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f</code></pre>
<p>保存退出之后，赋予文件可执行权限</p>
<pre><code class="hljs shell">chmod +x post-receive</code></pre>
<p>然后输入<code>exit</code>回到<code>root</code>用户下，输入如下命令</p>
<pre><code class="hljs shell">chown -R git:git /home/git/repos/blog.git</code></pre>
<p>配置完仓库后，可以在本地使用<code>git clone</code>命令测试是否能够成功克隆仓库</p>
<pre><code class="hljs shell">git clone git@server_ip:/home/git/repos/blog.git</code></pre>
<h3 id="2-配置Nginx"><a href="#2-配置Nginx" class="headerlink" title="2 配置Nginx"></a>2 配置Nginx</h3><h4 id="2-1-安装Nginx"><a href="#2-1-安装Nginx" class="headerlink" title="2.1 安装Nginx"></a>2.1 安装Nginx</h4><pre><code class="hljs shell">yum install -y nginx</code></pre>
<p>启动nginx</p>
<pre><code class="hljs shell">nginx</code></pre>
<h4 id="2-2-配置文件"><a href="#2-2-配置文件" class="headerlink" title="2.2 配置文件"></a>2.2 配置文件</h4><p>先暂停服务</p>
<pre><code class="hljs shell">nginx -s stop</code></pre>
<p>进入nginx目录，编辑配置文件</p>
<pre><code class="hljs shell">cd /etc/nginx
vi nginx.conf</code></pre>
<p>注意要修改两个地方，一个是将<code>user nginx</code>改为<code>user root</code><br>第二个就是在server的位置，添加root解析路径<code>/home/git/projects/blog/</code>，如果你已经有了域名，那么在server_name后面添加上你的域名。其它保持不变。</p>
<pre><code class="hljs shell">server &#123;
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  zhouzhuyan.com www.zhouzhuyan.com;
        root         /home/git/projects/blog/;
        index index.html index.htm;
    &#125;</code></pre>
<p>保存退出<br>重新启动nginx</p>
<pre><code class="hljs shell">systemctl restart nginx</code></pre>
<h4 id="2-3-检查"><a href="#2-3-检查" class="headerlink" title="2.3 检查"></a>2.3 检查</h4><p>检查nginx状态</p>
<pre><code class="hljs shell">systemctl status nginx</code></pre>
<p>如果看到绿色的<code>active</code>就表示配置成功了。我在这里遇到了一个问题，它的状态显示红色的<code>failed</code>,，错误是<code>98: Address already in use</code>，80端口已经被占用，这个时候可以用如下命令检查一下是谁占用了80端口</p>
<pre><code class="hljs shell">netstat -ntpl</code></pre>
<p>如果就是nginx的话，应该是由于之前的配置文件中，<code>listen       80 default_server;</code>监听ipv4的80端口，而<code>listen       [::]:80 default_server;</code>监听的是ipv6的80端口，于是就重复占用了。可以在配置文件中这样更改</p>
<pre><code class="hljs shell">listen       [::]:80 ipv6only=on  default_server;</code></pre>
<p>然后重启nginx应该就可以了。</p>
<h3 id="3-Hexo本地配置"><a href="#3-Hexo本地配置" class="headerlink" title="3. Hexo本地配置"></a>3. Hexo本地配置</h3><p>hexo的站点配置文件<code>_config.yml</code></p>
<pre><code class="hljs shell">deploy:
  type: git
  repo: git@你的IP:/home/git/repos/blog.git
  branch: master</code></pre>
<p>然后进行部署</p>
<pre><code class="hljs shell">hexo clean
hexo g -d</code></pre>
<h3 id="4-启用https"><a href="#4-启用https" class="headerlink" title="4. 启用https"></a>4. 启用https</h3><p>由于nginx默认使用的是http，所以在网站访问的时候，会显示不安全，可以通过配置来开启https</p>
<h4 id="4-1-申请SSL证书"><a href="#4-1-申请SSL证书" class="headerlink" title="4.1 申请SSL证书"></a>4.1 申请SSL证书</h4><p>阿里云和腾讯云都提供免费的SSL证书下载，因为我的域名是在腾讯云云购买的，所以我就从腾讯云上下载了<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/ssl">SSL证书</a></p>
<h4 id="4-2-传输文件到服务器"><a href="#4-2-传输文件到服务器" class="headerlink" title="4.2 传输文件到服务器"></a>4.2 传输文件到服务器</h4><p>从腾讯云上下载证书到本地，会得到一个自己域名命名的文件夹，里面有<code>Apache</code>，<code>Nginx</code>，<code>Tomcat</code>，<code>IIS</code>的证书，由于我们使用的是nginx服务，所以只需要Nginx文件夹内的<code>xxx.crt</code>和<code>xxx.key</code>两个文件。<br>在服务端创建文件夹存储证书</p>
<pre><code class="hljs shell">mkdir /home/git/SSL</code></pre>
<p>我们可以使用scp命令将本地的文件传输到服务器</p>
<pre><code class="hljs shell">scp -r xxx/Nginx git@你的IP /home/git/SSL</code></pre>
<h4 id="4-3-配置nginx"><a href="#4-3-配置nginx" class="headerlink" title="4.3 配置nginx"></a>4.3 配置nginx</h4><p>然后再次编辑<code>nginx.conf</code>文件，这里可以参考官方文档<a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/400/35244">Nginx 服务器证书安装</a>，文档写的很清晰，按照其中的步骤配置一下就可以完成了。<br>之后我们就可以通过https访问网页，在网址旁边会出现一把锁。</p>
<p>参考：<br>[1]HJX.将Hexo部署到阿里云轻量级服务器(保姆级教程)<br>[EB/OL].<a target="_blank" rel="noopener" href="https://hjxlog.com/posts/20191130a1.html,2019-11-30.">https://hjxlog.com/posts/20191130a1.html,2019-11-30.</a><br>[2]Dreamy.TZK.将Hexo部署到云服务器<br>[EB/OL].<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1632020,2020-05-25.">https://cloud.tencent.com/developer/article/1632020,2020-05-25.</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo写作</title>
    <url>/posts/c4064b2b.html</url>
    <content><![CDATA[<h1 id="Hexo写作"><a href="#Hexo写作" class="headerlink" title="Hexo写作"></a>Hexo写作</h1><p>本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。</p>
<a id="more"></a>
<h3 id="1-Hexo基本命令"><a href="#1-Hexo基本命令" class="headerlink" title="1. Hexo基本命令"></a>1. Hexo基本命令</h3><pre><code class="hljs shell">hexo g = hexo generate  #生成
hexo s = hexo server  #启动本地预览
hexo d = hexo deploy  #远程部署
hexo n &quot;文章标题&quot; = hexo new &quot;文章标题&quot;  #新建一篇博文</code></pre>
<h3 id="2-整体配置"><a href="#2-整体配置" class="headerlink" title="2. 整体配置"></a>2. 整体配置</h3><p><code>\hexo\_config.yml</code></p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Site</span>
title:  # 网站名，标签页显示
subtitle:  # 副标题，网站名下显示
description:  # 网站描述，便于搜索
keywords:
author: # 作者
language: zh-CN # 中文
timezone: Asia/Shanghai # 时区</code></pre>
<h3 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3. 更换主题"></a>3. 更换主题</h3><p>推荐使用<code>melody</code></p>
<p><a href="[https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html#%E5%AE%89%E8%A3%85](https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html#安装">hexo-theme-melody快速开始</a>)</p>
<p>这个主题就是我现在网站使用的主题，它有完整的中文教程，功能齐全。按照教程配置就可以了。</p>
<h3 id="4-写作步骤"><a href="#4-写作步骤" class="headerlink" title="4. 写作步骤"></a>4. 写作步骤</h3><ol>
<li><p>新建文章</p>
<pre><code class="hljs shell">hexo new &quot;title&quot;</code></pre>
</li>
<li><p>写作</p>
<p><code>\hexo\source\_post</code>中找到<code>title.md</code>，使用<code>typora</code>打开</p>
<p>注意文章的<code>tags</code>格式是<code>[]</code></p>
<p>在信息栏填写<code>top_img</code>信息可以自定义该页图片情况，如<code>false</code>表示不显示</p>
<p><code>文章中&lt;!-- more --&gt;</code>之前的部分会显示在主页上，并出现<code>Read more</code>按钮，点击阅读更多内容</p>
</li>
</ol>
<ol>
<li><p>预览</p>
<pre><code class="hljs shell">hexo s
hexo s --debug // 在命令行生成debug信息</code></pre>
</li>
<li><p>同步到远程</p>
<pre><code class="hljs shell">hexo d -g</code></pre>
</li>
</ol>
<h3 id="5-问题"><a href="#5-问题" class="headerlink" title="5.  问题"></a>5.  问题</h3><ol>
<li><p>Template render error: (unknown path)</p>
<p>在命令行输入<code>hexo -g</code>后报错，原因在于文章内容中有<strong>{}</strong>时，如果它没有被代码块包括，解析会出现错误，所以需要写成</p>
<pre><code class="hljs routeros">&#123;%<span class="hljs-built_in"> raw </span>%&#125;</code></pre>
</li>
<li><p>本地预览与远程显示不一致</p>
<p>删除缓存</p>
<pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span></code></pre>
<p>在网页上刷新</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github pages+Hexo 搭建个人博客</title>
    <url>/posts/ae6c038e.html</url>
    <content><![CDATA[<h1 id="Github-pages-Hexo-搭建个人博客"><a href="#Github-pages-Hexo-搭建个人博客" class="headerlink" title="Github pages + Hexo 搭建个人博客"></a>Github pages + Hexo 搭建个人博客</h1><p>2019年11月19日，我决定开始写<strong>博客</strong>，首先要用<em>github pages+hexo</em>搭建一个个人博客，其中的过程我就记录在这里面。</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>注册一个 GitHub 账户</li>
<li>安装 Node.js<br>下载链接<br> <a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br> 下面这个是中文网，对于国内用户来说下载速度非常快。<br> <a target="_blank" rel="noopener" href="http://nodejs.cn/download/">http://nodejs.cn/download/</a><br> 推荐菜鸟教程关于node的安装教程以及简易的语法介绍<a target="_blank" rel="noopener" href="https://www.runoob.com/nodejs/nodejs-install-setup.html">https://www.runoob.com/nodejs/nodejs-install-setup.html</a><ol>
<li>安装git</li>
<li>markdown语法学习<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/191d1e21f7ed">https://www.jianshu.com/p/191d1e21f7ed</a></li>
<li>git语法学习<br>推荐廖雪峰的git教程<br><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></li>
</ol>
</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在终端检查node和npm的版本情况</p>
<pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span>
npm -v</code></pre>
<p>然后输入命令安装hexo</p>
<pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span></code></pre>
<p>我使用的是Mac电脑，在这一步出现了问题，终端显示如下</p>
<pre><code class="hljs coffeescript">rollbackFailedOptional verb <span class="hljs-built_in">npm</span>-session</code></pre>
<p>然后我又等了一会儿，终端又报错了。</p>
<pre><code class="hljs livescript"><span class="hljs-built_in">npm</span> WARN checkPermissions Missing write access <span class="hljs-keyword">to</span> /usr/local/lib/node_modules
<span class="hljs-built_in">npm</span> ERR! code EACCES
<span class="hljs-built_in">npm</span> ERR! syscall access
<span class="hljs-built_in">npm</span> ERR! path /usr/local/lib/node_modules
<span class="hljs-built_in">npm</span> ERR! errno -<span class="hljs-number">13</span>
<span class="hljs-built_in">npm</span> ERR! Error: EACCES: permission denied, access <span class="hljs-string">&#x27;/usr/local/lib/node_modules&#x27;</span>
<span class="hljs-built_in">npm</span> ERR!  [Error: EACCES: permission denied, access <span class="hljs-string">&#x27;/usr/local/lib/node_modules&#x27;</span>] &#123;
<span class="hljs-built_in">npm</span> ERR!   stack: <span class="hljs-string">&quot;Error: EACCES: permission denied, access &#x27;/usr/local/lib/node_modules&#x27;&quot;</span>,
<span class="hljs-built_in">npm</span> ERR!   errno: -<span class="hljs-number">13</span>,
<span class="hljs-built_in">npm</span> ERR!   code: <span class="hljs-string">&#x27;EACCES&#x27;</span>,
<span class="hljs-built_in">npm</span> ERR!   syscall: <span class="hljs-string">&#x27;access&#x27;</span>,
<span class="hljs-built_in">npm</span> ERR!   path: <span class="hljs-string">&#x27;/usr/local/lib/node_modules&#x27;</span>
<span class="hljs-built_in">npm</span> ERR! &#125;
<span class="hljs-built_in">npm</span> ERR! 
<span class="hljs-built_in">npm</span> ERR! The operation was rejected <span class="hljs-keyword">by</span> your operating system.
<span class="hljs-built_in">npm</span> ERR! It <span class="hljs-keyword">is</span> likely you <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> have the permissions <span class="hljs-keyword">to</span> access <span class="hljs-built_in">this</span> file <span class="hljs-keyword">as</span> the current user
<span class="hljs-built_in">npm</span> ERR! 
<span class="hljs-built_in">npm</span> ERR! If you believe <span class="hljs-built_in">this</span> might be a permissions issue, please double-check the
<span class="hljs-built_in">npm</span> ERR! permissions <span class="hljs-keyword">of</span> the file <span class="hljs-keyword">and</span> its containing directories, <span class="hljs-keyword">or</span> <span class="hljs-keyword">try</span> running
<span class="hljs-built_in">npm</span> ERR! the command again <span class="hljs-keyword">as</span> root/Administrator.</code></pre>
<p>根据官方文档，如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code>权限错误，要遵循由<a target="_blank" rel="noopener" href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally#reinstall-npm-with-a-node-version-manager">npmjs</a>发布的指导修复该问题。强烈建议不要使用 root、sudo 等方法覆盖权限。<br>根据要求，下载了<strong>nvm</strong>，并且在终端利用nvm下载了最新版本的node和更新了npm后，hexo下载成功了。（以下是下载和使用nvm的教程链接）<br><a target="_blank" rel="noopener" href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a>.        </p>
<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>输入以下命令hexo就会出现在指定的文件夹中</p>
<pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">init &lt;folder&gt;</span>
<span class="hljs-attr">cd</span> <span class="hljs-string">&lt;folder&gt;</span>
<span class="hljs-attr">npm</span> <span class="hljs-string">install</span></code></pre>
<p>如果出现错误</p>
<pre><code class="hljs java">-bash: syntax error near unexpected token `newline<span class="hljs-string">&#x27;</span></code></pre>
<p>这是占位符的问题，将第一行命令的&lt;&gt;去除，再重新输入即可。</p>
<p>到此，建站的基本操作就完成了。</p>
<p>界面的设计等就可以由自己来操作了。放一个hexo的官方网站供大家参考。<br><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p>
<h2 id="创建Github远程仓库"><a href="#创建Github远程仓库" class="headerlink" title="创建Github远程仓库"></a>创建Github远程仓库</h2><p>注意仓库名为github的用户名.github.io，勾选readme<br><img src="https://img-blog.csdnimg.cn/20191123194438458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dhbGFoYWR6aG91,size_16,color_FFFFFF,t_70" alt=""></p>
<p>创建之后，进入仓库，点击<strong>Settings</strong>按钮，然后翻到GitHub Pages的部分，点击网页链接，就能够看到一个简易的网页了。</p>
<p><img src="https://img-blog.csdnimg.cn/20191123194913735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dhbGFoYWR6aG91,size_16,color_FFFFFF,t_70" alt=""></p>
<h2 id="部署hexo"><a href="#部署hexo" class="headerlink" title="部署hexo"></a>部署hexo</h2><p>进入本地的hexo文件，找到 <strong>_config.yml</strong>，打开后翻到最后，修改成</p>
<pre><code class="hljs java">deploy:
  type: git
  repo:
     gitHub: git<span class="hljs-meta">@github</span>.com:你的GitHub用户名/你的GitHub用户名.github.io.git
  branch: master</code></pre>
<p>repo后面的内容要修改成自己github仓库的SSH密匙。</p>
<p>然后在终端中输入</p>
<pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span></code></pre>
<p>开始安装hexo-deploy-git，安装完成后，开始部署，在终端中输入</p>
<pre><code class="hljs ebnf"><span class="hljs-attribute">hexo deploy</span></code></pre>
<p>部署完成。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这个时候，再次进入刚刚进入过的网页链接，就会看到一个船新版本的界面，也就是本地的hexo库已经部署到github上了。</p>
<p><img src="https://img-blog.csdnimg.cn/20191123195408260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dhbGFoYWR6aG91,size_16,color_FFFFFF,t_70" alt=""></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop与Spark集群搭建</title>
    <url>/posts/e567410e.html</url>
    <content><![CDATA[<h1 id="Hadoop与Spark集群搭建"><a href="#Hadoop与Spark集群搭建" class="headerlink" title="Hadoop与Spark集群搭建"></a>Hadoop与Spark集群搭建</h1><p>本文介绍了如何在虚拟机上搭建Hadoop集群与Spark集群，为云计算实践做好了准备工作。文章共分为3个部分，准备工作，Hadoop集群搭建和Spark集群搭建。</p>
<p><strong>强烈建议在Linux操作系统上部署Hadoop集群与Spark集群，在Windows和macOS上安装会在部署和后续的开发中遇到各种各样的问题！！！</strong></p>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><h3 id="1-1-环境"><a href="#1-1-环境" class="headerlink" title="1.1 环境"></a>1.1 环境</h3><p>3台VMware虚拟机 <code>Ubuntu 18.04.5</code></p>
<p><strong>Tip：</strong>可以先安装好一台虚拟机，然后通过克隆再制作另外2台虚拟机，这样就不用在每台机器上重复配置了，克隆的方式后续会介绍。</p>
<p>在虚拟机中创建一个<code>hadoop</code>用户，然后进入<code>hadoop</code>用户的根目录</p>
<pre><code class="hljs shell">sudo addgroup hadoop
sudo adduser --ingroup hadoop hadoop
cd /home/hadoop</code></pre>
<h3 id="1-2-虚拟机克隆"><a href="#1-2-虚拟机克隆" class="headerlink" title="1.2 虚拟机克隆"></a>1.2 虚拟机克隆</h3><p>vmware fusion的虚拟机克隆步骤如下，进入<code>Virtual Machine Library</code>右键虚拟机，然后点击<code>show in finder</code>，复制一份后更改名字即可。克隆成功将3台虚拟机全部启动。</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20201201-02.png" alt=""></p>
<h3 id="1-3-网络规划与配置静态ip"><a href="#1-3-网络规划与配置静态ip" class="headerlink" title="1.3 网络规划与配置静态ip"></a>1.3 网络规划与配置静态ip</h3><p>集群需要运行在局域网下(比如开一个手机热点)，不同的机器才可以互相连通，所以需要配置好网络。</p>
<p>我的网络规划如下，集群共3台机器，一台为<code>master</code>，两台为<code>slave</code></p>
<pre><code class="hljs accesslog"><span class="hljs-number">172.20.10.3</span> master
<span class="hljs-number">172.20.10.4</span> slave1
<span class="hljs-number">172.20.10.5</span> slave2</code></pre>
<p>在master机器修改主机名</p>
<pre><code class="hljs shell">hostname master</code></pre>
<p>编辑<code>/etc/hosts</code>文件，注释掉前两行，并加上我们自定义的配置。</p>
<pre><code class="hljs shell">sudo vi /etc/hosts</code></pre>
<pre><code class="hljs css"><span class="hljs-selector-id">#127</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1</span>	<span class="hljs-selector-tag">localhost</span>
<span class="hljs-selector-id">#127</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.1</span>	<span class="hljs-selector-tag">ubuntu</span>
172<span class="hljs-selector-class">.20</span><span class="hljs-selector-class">.10</span><span class="hljs-selector-class">.3</span> <span class="hljs-selector-tag">master</span>
172<span class="hljs-selector-class">.20</span><span class="hljs-selector-class">.10</span><span class="hljs-selector-class">.4</span> <span class="hljs-selector-tag">slave1</span>
172<span class="hljs-selector-class">.20</span><span class="hljs-selector-class">.10</span><span class="hljs-selector-class">.5</span> <span class="hljs-selector-tag">slave2</span></code></pre>
<p>虚拟机网络需要选择<strong>桥接模式</strong>，如下图</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20201201-01.png" alt=""></p>
<p>然后配置静态ip地址，<code>ubuntu18</code>以后采用了<code>netplan</code>来配置静态ip，与以前有所不同。</p>
<pre><code class="hljs shell">cd /etc/netplan
vi 01-network-manager-all.yaml</code></pre>
<p>在文件中写入如下内容</p>
<pre><code class="hljs yaml"><span class="hljs-comment"># Let NetworkManager manage all devices on this system</span>
<span class="hljs-attr">network:</span>
    <span class="hljs-attr">ethernets:</span>
        <span class="hljs-attr">ens33:</span>                  <span class="hljs-comment"># 配置的网卡名称</span>
            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>           <span class="hljs-comment"># 关闭dhcp4</span>
            <span class="hljs-attr">dhcp6:</span> <span class="hljs-literal">no</span>           <span class="hljs-comment"># 关闭dhcp6</span>
            <span class="hljs-attr">addresses:</span> [<span class="hljs-number">172.20</span><span class="hljs-number">.10</span><span class="hljs-number">.3</span><span class="hljs-string">/24</span>]       <span class="hljs-comment"># 设置本机IP地址及掩码</span>
            <span class="hljs-attr">gateway4:</span> <span class="hljs-number">172.20</span><span class="hljs-number">.10</span><span class="hljs-number">.1</span>             <span class="hljs-comment"># 设置网关</span>
            <span class="hljs-attr">nameservers:</span>
                    <span class="hljs-attr">addresses:</span> [<span class="hljs-number">172.20</span><span class="hljs-number">.10</span><span class="hljs-number">.1</span>, <span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>]       <span class="hljs-comment"># 设置DNS</span>
    <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
</code></pre>
<p>按<code>:wq</code>保存退出，然后如下命令使得网络设置生效</p>
<pre><code class="hljs shell">sudo netplan apply</code></pre>
<p>通过<code>ping</code>命令检测网络运行是否正常</p>
<pre><code class="hljs shell">ping www.baidu.com
PING www.a.shifen.com (39.156.66.18) 56(84) bytes of data.
64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=1 ttl=50 time=55.8 ms
64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=2 ttl=50 time=83.2 ms
64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=3 ttl=50 time=104 ms
64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=4 ttl=50 time=119 ms</code></pre>
<p>在两台<code>slave</code>机器上进行同样的操作，修改主机名分别为<code>slave1</code>和<code>slave2</code>，然后修改<code>/etc/hosts</code>文件，在配置静态ip时要注意将<code>addresses: [172.20.10.3/24]</code>修改为<code>addresses: [172.20.10.4/24]</code>和<code>addresses: [172.20.10.5/24]</code>。</p>
<p>最后，在<code>master</code>机器上<code>ping slave1</code>和<code>slave2</code>验证</p>
<pre><code class="hljs shell">ping slave1
PING slave1 (172.20.10.4) 56(84) bytes of data.
64 bytes from slave1 (172.20.10.4): icmp_seq=1 ttl=64 time=0.684 ms
64 bytes from slave1 (172.20.10.4): icmp_seq=2 ttl=64 time=0.997 ms
64 bytes from slave1 (172.20.10.4): icmp_seq=3 ttl=64 time=1.19 ms
64 bytes from slave1 (172.20.10.4): icmp_seq=4 ttl=64 time=0.591 ms</code></pre>
<p>能够<code>ping</code>通则说明网络配置成功。</p>
<h2 id="2-Hadoop集群搭建"><a href="#2-Hadoop集群搭建" class="headerlink" title="2. Hadoop集群搭建"></a>2. Hadoop集群搭建</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>在安装<code>hadoop</code>之前。首先需要安装<code>java</code></p>
<pre><code class="hljs shell">apt-get update
apt-get install -y openjdk-8-jdk openjdk-8-jre</code></pre>
<p>然后下载<code>hadoop</code>安装包，解压后移动到<code>/usr/local</code>目录下</p>
<pre><code class="hljs shell">wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz
tar -zxf hadoop-3.2.1.tar.gz
sudo mv ./hadoop-3.2.1 /usr/local/</code></pre>
<p>安装完成后，将其写入环境变量</p>
<pre><code class="hljs shell">sudo vi /etc/bash.bashsrc</code></pre>
<pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_HOME</span>=/usr/local/hadoop
<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$HADOOP_HOME</span>/bin:$HADOOP_HOME/sbin:$PATH
<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_CONF_DIR</span>=<span class="hljs-variable">$HADOOP_HOME</span>/etc/hadoop
<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/lib/jvm/java-8-openjdk-amd64/</code></pre>
<p>在终端输入如下命令验证，出现命令下的内容说明配置成功</p>
<pre><code class="hljs shell">java -version</code></pre>
<pre><code class="hljs apache"><span class="hljs-attribute">openjdk</span> version <span class="hljs-string">&quot;1.8.0_275&quot;</span>
<span class="hljs-attribute">OpenJDK</span> Runtime Environment (build <span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>_<span class="hljs-number">275</span>-<span class="hljs-number">8</span>u<span class="hljs-number">275</span>-b<span class="hljs-number">01</span>-<span class="hljs-number">0</span>ubuntu<span class="hljs-number">1</span>~<span class="hljs-number">18</span>.<span class="hljs-number">04</span>-b<span class="hljs-number">01</span>)
<span class="hljs-attribute">OpenJDK</span> <span class="hljs-number">64</span>-Bit Server VM (build <span class="hljs-number">25</span>.<span class="hljs-number">275</span>-b<span class="hljs-number">01</span>, mixed mode)</code></pre>
<pre><code class="hljs shell">hadoop version</code></pre>
<pre><code class="hljs shell">Hadoop 3.2.1
Source code repository https://gitbox.apache.org/repos/asf/hadoop.git -r b3cbbb467e22ea829b3808f4b7b01d07e0bf3842
Compiled by rohithsharmaks on 2019-09-10T15:56Z
Compiled with protoc 2.5.0
From source with checksum 776eaf9eee9c0ffc370bcbc1888737
This command was run using /usr/local/hadoop/share/hadoop/common/hadoop-common-3.2.1.jar</code></pre>
<p>上述安装步骤3台机器都需要执行。</p>
<h3 id="2-2-SSH免登陆"><a href="#2-2-SSH免登陆" class="headerlink" title="2.2 SSH免登陆"></a>2.2 SSH免登陆</h3><p>在<code>master</code>机器上创建ssh密匙</p>
<pre><code class="hljs shell">ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa
cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
chmod 0600 ~/.ssh/authorized_keys</code></pre>
<p>将密匙分发给两台<code>slave</code>机器</p>
<pre><code class="hljs shell">ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop@slave1
ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop@slave2</code></pre>
<p>并且在两台<code>slave</code>机器上分别创建密匙</p>
<pre><code class="hljs shell">ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsa
cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
chmod 0600 ~/.ssh/authorized_keys</code></pre>
<h3 id="2-3-配置文件"><a href="#2-3-配置文件" class="headerlink" title="2.3 配置文件"></a>2.3 配置文件</h3><p>在<code>master</code>机器上进入<code>hadoop</code>配置目录，修改配置文件</p>
<pre><code class="hljs shell">cd /usr/local/hadoop/etc/hadoop
rm core-site.xml hdfs-site.xml mapred-site.xml yarn-site.xml 
wget https://gitee.com/focksor/hadoop-config/raw/master/Cluster/core-site.xml
wget https://gitee.com/focksor/hadoop-config/raw/master/Cluster/hdfs-site.xml
wget https://gitee.com/focksor/hadoop-config/raw/master/Cluster/mapred-site.xml
wget https://gitee.com/focksor/hadoop-config/raw/master/Cluster/yarn-site.xml</code></pre>
<p>修改workers文件，这里我们将3台机器都作为子节点。</p>
<pre><code class="hljs crmsh"><span class="hljs-literal">master</span>
slave1
slave2</code></pre>
<p>然后将配置内容分发给两台<code>slave</code>机器</p>
<pre><code class="hljs shell">cd /usr/local/hadoop/etc
scp -r hadoop/ hadoop@slave1:/usr/local/hadoop/etc
scp -r hadoop/ hadoop@slave2:/usr/local/hadoop/etc</code></pre>
<h3 id="2-4-启动"><a href="#2-4-启动" class="headerlink" title="2.4 启动"></a>2.4 启动</h3><p>在<code>master</code>机器上输入命令启动集群</p>
<pre><code class="hljs shell">start-all.sh</code></pre>
<p>会输出如下内容</p>
<pre><code class="hljs shell">WARNING: Attempting to start all Apache Hadoop daemons as hadoop in 10 seconds.
WARNING: This is not a recommended production deployment configuration.
WARNING: Use CTRL-C to abort.
Starting namenodes on [master]
Starting datanodes
Starting secondary namenodes [master]
Starting resourcemanager
Starting nodemanagers</code></pre>
<p>等待命令执行完毕，然后在浏览器打开<code>master:9870</code>查看网页，在<code>DataNode</code>页面可以看到3个节点，说明集群正常启动。</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20201201-03.png" alt=""></p>
<h2 id="3-Spark集群搭建"><a href="#3-Spark集群搭建" class="headerlink" title="3. Spark集群搭建"></a>3. Spark集群搭建</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p><strong>Tip</strong>：搭建集群时所有机器上的spark版本必须一致，否则无法成功连接</p>
<p>下载spark，解压后移动到指定的目录</p>
<pre><code class="hljs shell">wget https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-3.0.1/spark-3.0.1-bin-hadoop3.2.tgz
tar -zvxf spark-3.0.1-bin-hadoop3.2.tgz 
sudo mv spark-3.0.1-bin-hadoop3.2 /usr/local/
cd /usr/local
sudo mv spark-3.0.1-bin-hadoop3.2/ spark</code></pre>
<p>配置环境变量</p>
<pre><code class="hljs shell">sudo vi /etc/profile</code></pre>
<p>按<code>i</code>进入编辑模式，输入如下内容</p>
<pre><code class="hljs shell">export SPARK_HOME=/usr/local/spark
export PATH=$PATH:$&#123;SPARK_HOME&#125;/bin</code></pre>
<p>按<code>esc</code>键后输入<code>:wq</code>保存退出</p>
<p>使用<code>source</code>命令使得修改生效</p>
<pre><code class="hljs shell">source /etc/profile</code></pre>
<p>使用<code>spark-shell</code>命令验证安装情况</p>
<pre><code class="hljs shell">spark-shell</code></pre>
<p>如果出现spark的图标并出现scala的输入就说明成功了。</p>
<h3 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h3><p>进入<code>spark/conf</code>目录，编辑<code>spark-env.sh</code>文件</p>
<pre><code class="hljs shell">cd /usr/local/spark/conf
cp spark-env.sh.template spark-env.sh
vi spark-env.sh</code></pre>
<p>注意<code>SPARK_MASTER_HOST</code>需要根据自己配置的集群的Master机器IP地址进行改变</p>
<pre><code class="hljs shell">export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/
export SPARK_MASTER_HOST=172.20.10.3
export SPARK_WORKER_MEMORY=2g
export SPARK_WORKER_CORES=1
export HADOOP_HOME=/usr/local/hadoop
export HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop</code></pre>
<p>配置slaves文件，将3个节点都都当做worker</p>
<pre><code class="hljs shell">cp slaves.template slaves
vi slaves</code></pre>
<pre><code class="hljs crmsh"><span class="hljs-literal">master</span>
slave1
slave2</code></pre>
<p><strong>Tip：</strong>因为3台机器的用户名都是<code>hadoop</code>，所以这里只需要写上主机名，如果用户名不一致，需要写成<code>hadoop@master</code>的形式，这样比较麻烦，所以推荐集群所有机器用户名保持一致。</p>
<h3 id="3-3-启动"><a href="#3-3-启动" class="headerlink" title="3.3 启动"></a>3.3 启动</h3><p>进入<code>sbin</code>目录，启动</p>
<pre><code class="hljs shell">cd /usr/local/spark/sbin
sudo ./start-all.sh</code></pre>
<p>可以看到如下界面，出现3个节点则说明配置成功。</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20201201-04.png" alt=""></p>
<p>引用：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangyongli2011/p/10572152.html">Hadoop集群+Spark集群搭建一篇文章就够了</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/focksor/p/install_hadoop_on_ubuntu_on_vmware.html">使用vmware+Ubuntu搭建hadoop集群</a></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>Hadoop</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算概述</title>
    <url>/posts/756f403a.html</url>
    <content><![CDATA[<h1 id="云计算概述"><a href="#云计算概述" class="headerlink" title="云计算概述"></a>云计算概述</h1><h2 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a>1. 起源</h2><p>自计算机诞生之日起，人类就从未停止对更高计算性能的追求。</p>
<p>那么如何提高计算性能呢？</p>
<p><strong>思路1</strong></p>
<p>把一台计算机做的足够强大</p>
<p>计算范式：<strong>集中式计算</strong></p>
<p>将所有计算资源集中在一个物理系统之内，所有资源（处理器，内存，存储器）是共享的，并且紧耦合在一个集成式操作系统中。</p>
<p>计算范式：<strong>并行计算</strong></p>
<p>提高效率，同一时间执行多个计算</p>
<p>所有处理器紧耦合于中心共享内存或松耦合于分布式内存，处理器通信通过共享内存或通过消息传递完成。</p>
<p><strong>问题</strong>：单台计算机价格高昂，并行计算有瓶颈</p>
<p><strong>思路2</strong></p>
<p>人多力量大，机多计算强</p>
<p>由众多自治计算机组成，各自拥有私有内存，通过计算机网络通信，信息交换通过信息传递完成。</p>
<p>多个物理系统：分布式系统，分布式程序，分布式编程</p>
<h3 id="1-1-传统分布式计算系统"><a href="#1-1-传统分布式计算系统" class="headerlink" title="1.1 传统分布式计算系统"></a>1.1 传统分布式计算系统</h3><p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200915-01.png" alt=""></p>
<h4 id="1-1-1-计算集群"><a href="#1-1-1-计算集群" class="headerlink" title="1.1.1 计算集群"></a>1.1.1 计算集群</h4><p>实现<strong>计算抽象</strong></p>
<p><strong>特点</strong></p>
<ul>
<li>基本组件为计算节点、通信软件、网络接口卡<br>以单独身份接入互联网</li>
</ul>
<h4 id="1-1-2-P2P系统"><a href="#1-1-2-P2P系统" class="headerlink" title="1.1.2  P2P系统"></a>1.1.2  P2P系统</h4><p>实现了<strong>存储抽象</strong></p>
<p><strong>特点</strong></p>
<ul>
<li>节点是简单接入互联网的客户机，自治，自由加入和退出<br><strong>问题</strong></li>
<li>无中心协作或中心数据库，有专用的物理互联网络，不稳定，不可靠，不安全</li>
</ul>
<h4 id="1-1-3-计算网络"><a href="#1-1-3-计算网络" class="headerlink" title="1.1.3 计算网络"></a>1.1.3 计算网络</h4><p><strong>接近”云“</strong></p>
<p><strong>特点</strong></p>
<ul>
<li>计算资源整合，一个集成的资源池，提供基础设施</li>
<li>节点包括：工作站，服务器，集群，超级计算机<br>问题：</li>
<li>异构、用户管理、耗资源的协议、安全性、应用受限</li>
</ul>
<h3 id="1-2-云计算"><a href="#1-2-云计算" class="headerlink" title="1.2 云计算"></a>1.2 云计算</h3><h4 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h4><p><strong>云计算</strong>是相对与1.1中的3个系统更好的解决方案，它对网格进行优化，可以完美解决分布式计算。</p>
<ul>
<li>大量计算节点，同构可控</li>
<li>专用内部网络</li>
<li>通过互联网对外服务（公有云）</li>
<li>全面虚拟化（计算、存储、网络、桌面）</li>
<li>集中管理 安全高效</li>
</ul>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200925-02.png" alt=""></p>
<p>云计算的定义基本可以总结为：</p>
<p>云计算是一种<strong>商业计算模型</strong>，通过网络<strong>按需</strong>提供可以<strong>动态伸缩</strong>的廉价计算<strong>服务</strong>。</p>
<p><strong>云</strong>是一些可以自我维护和管理的虚拟计算资源，通常是一些大型服务器集群，包括计算服务器，存储服务器和宽带资源等。</p>
<p>之所以称为云，是因为其具有现实中云的特征——云一般都较大，云的规模可以动态伸缩，它的边界是模糊的，位置是不确定的，</p>
<h4 id="1-2-2-概念模型"><a href="#1-2-2-概念模型" class="headerlink" title="1.2.2 概念模型"></a>1.2.2 概念模型</h4><p>PPT p11</p>
<h4 id="1-2-3-云计算-vs-网格计算"><a href="#1-2-3-云计算-vs-网格计算" class="headerlink" title="1.2.3 云计算 vs 网格计算"></a>1.2.3 云计算 vs 网格计算</h4><table>
<tr>
<th>网格计算</th>
<th>云计算</th>
</tr>
<tr>
    <td colspan="2">共同：
            <ul>
                        <li>提升计算能力，完成数据处理</li>
                        <li>构建虚拟资源池且动态可伸缩</li>
                        <li>支持多承租任务</li>
            </ul>
    </td>
</tr>
<tr>
    <td>聚合分布的资源，恰好有</td>
    <td>使用专有的资源，专门做</td>
</tr>
<tr>
    <td>强调虚拟组织，立足特定任务</td>
    <td>不强调虚拟组织，重视通用性</td>
</tr>
<tr>
    <td>利用中间件来屏蔽异构系统</td>
    <td>不强调异构性</td>
</tr>
<tr>
    <td>面向科研，商业模式不清晰</td>
    <td>针对企业应用，商业模式清晰</td>
</tr>
</table>


<h2 id="2-初探"><a href="#2-初探" class="headerlink" title="2. 初探"></a>2. 初探</h2><h3 id="2-1-时代背景"><a href="#2-1-时代背景" class="headerlink" title="2.1 时代背景"></a>2.1 时代背景</h3><p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200925-03.png" alt=""></p>
<p>今天是<strong>大数据</strong>的时代，一切皆为大数据，一切皆为大数据。我们先来简单的介绍一下大数据。</p>
<p>什么是大数据？</p>
<p>海量数据或巨量数据，其规模巨大到无法通过目前主流的计算机系统在合理时间内获取、存储、管理、处理并提炼以帮助使用者决策。  （刘鹏，《云计算》第三版）</p>
<p>为什么会产生大数据？</p>
<ul>
<li>数据产生方式的改变，越来越自动化</li>
<li>人类活动越来越依赖数据</li>
<li>互联网+物联网<br>大数据有怎样的特征？</li>
<li>3V: Volume(量大), Variety(多样), Velocity(快速)</li>
<li>4V+1C: Value(低价值密度), Complexity(复杂:处理和分析难度大)</li>
<li>5V: Volume, Variety, Velocity, Value, Veracity(真实)</li>
</ul>
<p>云计算是处理大数据的手段。大数据促进了云计算的产生，激发了云计算的潜力。云计算为大数据的收集，存储，加工和应用提供了更好的支持。</p>
<h3 id="2-2-云的服务模型"><a href="#2-2-云的服务模型" class="headerlink" title="2.2 云的服务模型"></a>2.2 云的服务模型</h3><p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200925-04.png" alt=""></p>
<h4 id="2-2-1-IaaS"><a href="#2-2-1-IaaS" class="headerlink" title="2.2.1 IaaS"></a>2.2.1 IaaS</h4><p>将硬件设备等基础资源封装成服务服务提供给用户。用户相当于在使用裸机和磁盘，比如亚马逊云计算AWS的弹性计算云EC2</p>
<p>通过虚拟机的方式对外提供计算和存储能力</p>
<p>机器享有公网IP，多个虚拟机之间通过网络进行通信</p>
<p>类似租用独立的计算机</p>
<p>用户自行解决多台机器之间的协同问题</p>
<p><strong>优势</strong></p>
<ul>
<li>允许用户动态申请和释放资源</li>
<li>按使用量计费</li>
<li>由公众共享，具有更高的资源使用效率（节能环保）</li>
</ul>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200925-05.png" alt=""></p>
<h4 id="2-2-2-PaaS"><a href="#2-2-2-PaaS" class="headerlink" title="2.2.2 PaaS"></a>2.2.2 PaaS</h4><p>抽象层次更进一步，提供用户应用程序的运行环境</p>
<p>自身负责资源的动态扩展和容错管理</p>
<p><strong>优势</strong></p>
<p>用户无需考虑节点间的配合问题</p>
<p><strong>缺陷</strong></p>
<p>用户自主权降低，需按照给定的编程环境和编程模型构建应用</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200925-06.png" alt=""></p>
<h4 id="2-2-3-SaaS"><a href="#2-2-3-SaaS" class="headerlink" title="2.2.3 SaaS"></a>2.2.3 SaaS</h4><p>针对性更强，将某些特定应用软件功能封装成服务。只提供某些专门用途的服务供应用调用</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200925-07.png" alt=""></p>
<h4 id="2-2-4-实现机制"><a href="#2-2-4-实现机制" class="headerlink" title="2.2.4 实现机制"></a>2.2.4 实现机制</h4><p>不同的供应商提供了不同的解决方案，没有同意的技术体系结构。下图是云计算体系结构参考模型</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200925-08.png" alt=""></p>
<p><strong>SOA构建层</strong></p>
<p>封装云计算能力成标准的Web Service服务，并纳入SOA体系</p>
<p>其中，SOA是面向服务的体系结构(<em>Service-oriented Architecture</em>)</p>
<p><strong>管理中间件层</strong></p>
<p>云计算的资源管理，并对众多应用任务进行调度，使资源能够高效、安全的为应用提供服务</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200916-01.png" alt=""></p>
<p><strong>资源池层</strong></p>
<p>将大量相同类型的资源构成同构或接近同构的资源池</p>
<p><strong>物理资源层</strong></p>
<p>计算机、存储器、网路设施、数据库和软件等</p>
<p><strong>Tip</strong></p>
<p><strong>管理中间件层</strong>和<strong>资源池层</strong>是云计算技术最关键的部分，SOA构建层的功能更多依靠外部设施提供。</p>
<p>下面以IaaS为例，简述云计算的实现机制。<br><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200916-02.png" alt=""></p>
<ul>
<li>用户交互接口向应用以<em>Web Services</em>方式提供访问接口，获取用户需求。</li>
<li>服务目录是用户可以访问的服务清单。</li>
<li>系统管理模块负责管理和分配所有可用的资源，其核心是负载均衡。</li>
<li>配置工具负责在分配的节点上准备任务运行环境。</li>
<li>监视统计模块负责监视节点的运行状 态，并完成用户使用节点情况的统计</li>
</ul>
<h3 id="2-3-风险和挑战"><a href="#2-3-风险和挑战" class="headerlink" title="2.3 风险和挑战"></a>2.3 风险和挑战</h3><h4 id="2-3-1-云计算压倒性的成本优势"><a href="#2-3-1-云计算压倒性的成本优势" class="headerlink" title="2.3.1 云计算压倒性的成本优势"></a>2.3.1 云计算压倒性的成本优势</h4><p>云计算之所以拥有划时代的优势，就是因为它的技术特征和规模效应所带来的的压倒性的性能价格比优势。</p>
<p>全球企业的IT开销分为三部分：硬件开销、能耗和管理成本。调查显示，在硬件开销持平的同时，能耗和管理成本上升非常迅速。而云计算的经济性主要体现在以下两个方面：</p>
<p>一方面，如果使用云计算，可以获得更低的硬件和网络成本，更低管理成本和电力成本。比如Google的数据中心就建立在人烟稀少，气候寒冷，水电资源丰富的地区，这样使得电价、场地、人力都远远比在城市建立要低，今天的中小企业直接租用相关的云服务也比自己去租用场地，搭建服务器要便宜的多。</p>
<p>另一方面，云计算与传统的互联网数据中心(<em>IDC</em>)的资源利用率有很大不同。在以前，每个租用<em>IDC</em>的网站所获得的带宽，处理能力和存储空间都是固定的，但是网站的访问量并不均衡，比如有的网站白天没啥人看，晚上流量很多。为了应对这些情况，网站拥有者需要按照峰值要求来配置服务器和网络资源，这就造成了资源的浪费。而云计算平台提供弹性服务，动态分配和释放资源，大大提高了资源的利用效率。</p>
<h4 id="2-3-2-其它优势"><a href="#2-3-2-其它优势" class="headerlink" title="2.3.2 其它优势"></a>2.3.2 其它优势</h4><ul>
<li>可扩展性和可伸缩性</li>
<li>虚拟化 模拟符合用户需求的任何计算环境</li>
<li>高可靠 多副本容错 计算节点同构可互换等保障措施</li>
<li>管理简单</li>
<li>安全</li>
</ul>
<h4 id="2-3-3-云计算技术难点"><a href="#2-3-3-云计算技术难点" class="headerlink" title="2.3.3 云计算技术难点"></a>2.3.3 云计算技术难点</h4><p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200916-03.png" alt=""></p>
<h4 id="2-3-4-风险与挑战"><a href="#2-3-4-风险与挑战" class="headerlink" title="2.3.4 风险与挑战"></a>2.3.4 风险与挑战</h4><p><strong>增加了安全漏洞</strong></p>
<ul>
<li>运程使用IT资源需要云用户将信任边界扩展到外部的云，建立这样的安全架构同时又不引入安全漏洞是非常困难的</li>
<li>重叠的信任边界和不断增加的数据曝光为恶意的云用户提供了更多的攻击IT资源、窃 取或破坏企业数据的机会</li>
</ul>
<p><strong>降低了运营管理控制</strong></p>
<ul>
<li>云用户对云资源的管理控制低于对企业内部IT资源的管理控制</li>
<li><ul>
<li>云提供者可能不遵守它发布的云服务保证</li>
</ul>
</li>
<li><ul>
<li>云用户和云提供者之间较长的地理距离可能需要更多的网络跳数，会带来延迟波 动和带宽受限</li>
</ul>
</li>
</ul>
<p><strong>云提供者之间有限的可移植性</strong></p>
<ul>
<li>由于缺乏行业标准，不同的云提供者提供的服务存在较大差异</li>
<li>出于商业原因，云平台也不希望用户更换平台</li>
</ul>
<p><strong>多地区法规和法律问题</strong></p>
<ul>
<li>第三方云提供者通常选择造价较低、方便的地理位置建立数据中心，而云用户通常不会意识到所使用IT资源和自身数据所存放的位置 </li>
<li>潜在的数据获得和公开，比如某些国家的法律规定，某些类型的数据必须向某些政府机构或数据主体公开</li>
</ul>
<p>参考：</p>
<ol>
<li>《云计算 （第三版）》 刘鹏</li>
</ol>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化技术</title>
    <url>/posts/aa435277.html</url>
    <content><![CDATA[<h1 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h1><p>虚拟化意味着对计算机资源的抽象。在云计算中，虚拟化技术可以用来对<strong>数据中心</strong>的各种资源进行虚拟化和管理，是实现云计算的关键技术。可以实现<strong>服务器虚拟化、存储虚拟化、网络虚拟化和桌面虚拟化。</strong></p>
<h2 id="1-虚拟化技术简介"><a href="#1-虚拟化技术简介" class="headerlink" title="1. 虚拟化技术简介"></a>1. 虚拟化技术简介</h2><h3 id="1-1-核心思想"><a href="#1-1-核心思想" class="headerlink" title="1.1 核心思想"></a>1.1 核心思想</h3><p>虚拟化技术的<strong>核心思想</strong>是利用软件或固件管理程序构成虚拟化层，<strong>把物理资源映射为虚拟资源</strong>。在虚拟资源上可以<strong>安装和部署多个虚拟机</strong>，实现<strong>多用户共享物理资源</strong>。</p>
<h3 id="1-2-虚拟化的实现"><a href="#1-2-虚拟化的实现" class="headerlink" title="1.2 虚拟化的实现"></a>1.2 虚拟化的实现</h3><p>添加一个称为虚拟化层的软件，管理客户操作系统，使其能够独立于主机操作系统同时运行在同一个硬件上。</p>
<h2 id="2-数据中心虚拟化"><a href="#2-数据中心虚拟化" class="headerlink" title="2. 数据中心虚拟化"></a>2. 数据中心虚拟化</h2><p>云计算中运用虚拟化技术主要体现在对<strong>数据中心</strong>的虚拟化上。</p>
<p>数据中心是云计算技术的核心，由于数据中心的规模不断增大，成本上升，管理日趋复杂，传统的数据中心网络采用的多种技术，业务之间的孤立性，使得其结构复杂，导致服务器之间存在操作系统和上层软件异构、接口和数据格式不统一等问题。</p>
<p>随着云计算的发展，传统数据中心逐渐过渡到虚拟化数据中心，即采用虚拟化技术将原来数据中心的物理资源进行抽象整合。满足虚拟数据中心网络高速、扁平、虚拟化的要求。它的<strong>作用</strong>如下：</p>
<ul>
<li>实现资源的动态分配和调度，提高现有资源的利用率和服务可靠性</li>
<li>提供自动化的服务开通能力，降低运维成本</li>
<li>具有有效的安全机制和可靠性机制，满足公众客户和企业客户的安全需求</li>
<li>方便系统升级、迁移和改造</li>
</ul>
<p>数据中心的虚拟化是通过服务器虚拟化、存储虚拟化和网络虚拟化实现的。服务器虚拟化在云计算中是最重要和最关键的。</p>
<ul>
<li><strong>服务器虚拟化</strong>：将一个或多个物理服务器虚拟成多个逻辑上的服务器，集中管理</li>
<li><strong>存储虚拟化</strong>：把分布的异构存储设备统一为一个或几个大的存储池，方便用户使用和管理</li>
<li><strong>网络虚拟化</strong>：在底层物理网络和网络用户之间增加一个抽象层，其向下对物理网络资源进行分割，向上提供虚拟网络</li>
</ul>
<h3 id="2-1-服务器虚拟化"><a href="#2-1-服务器虚拟化" class="headerlink" title="2.1 服务器虚拟化"></a>2.1 服务器虚拟化</h3><h4 id="2-2-1-服务器虚拟化的层次"><a href="#2-2-1-服务器虚拟化的层次" class="headerlink" title="2.2.1 服务器虚拟化的层次"></a>2.2.1 服务器虚拟化的层次</h4><h5 id="1-寄居虚拟化"><a href="#1-寄居虚拟化" class="headerlink" title="1. 寄居虚拟化"></a>1. 寄居虚拟化</h5><p>寄居虚拟化层一般称为<strong>虚拟机监控器（VMM）</strong>。VMM安装在已有的主机操作系统上。损耗大，没有独立的<em>Hypervisor</em>层。</p>
<h5 id="2-裸机虚拟化"><a href="#2-裸机虚拟化" class="headerlink" title="2. 裸机虚拟化"></a>2. 裸机虚拟化</h5><p>直接将VMM安装在服务器硬件设备中，也可以认为该架构中的VMM是一个操作系统，一般称为<code>Hypervisor</code>，实现从虚拟资源到物理资源的映射。</p>
<p>x86体系结构的处理器并不是完全支持虚拟化，因为某些x86特权指令在地特权级上下文执行时，不能产生自陷，导致VMM无法直接捕获特权指令。解决方案是基于动态指令转换或硬件辅助的完全虚拟化技术和半虚拟化技术。</p>
<h4 id="2-2-2-服务器虚拟化的底层实现"><a href="#2-2-2-服务器虚拟化的底层实现" class="headerlink" title="2.2.2 服务器虚拟化的底层实现"></a>2.2.2 服务器虚拟化的底层实现</h4><h5 id="1-CPU的虚拟化"><a href="#1-CPU的虚拟化" class="headerlink" title="1. CPU的虚拟化"></a>1. CPU的虚拟化</h5><ul>
<li>任意时刻一个物理CPU只能运行一个虚拟CPU</li>
<li>每个客户操作系统可以使用一个或多个虚拟CPU</li>
<li>在各个操作系统之间，虚拟CPU运行相互隔离，互不影响</li>
</ul>
<p>CPU虚拟化需要解决<strong>正确运行</strong>和<strong>调度</strong>两个关键问题。</p>
<p>虚拟CPU的<strong>正确运行</strong>是要保证虚拟机指令正确运行，而且各个虚拟机之间不能相互影响。现有的实现技术包括模拟执行和监控执行。</p>
<p><strong>调度</strong>问题是指VMM决定当前哪个虚拟CPU在物理CPU上运行，要保证隔离性、公平性和性能。</p>
<h5 id="2-内存虚拟化"><a href="#2-内存虚拟化" class="headerlink" title="2. 内存虚拟化"></a>2. 内存虚拟化</h5><p>内存虚拟化技术把物理内存统一管理，包装成多个虚拟的物理内 存提供给若干虚拟机使用，每个虚拟机拥有各自独立的内存空间。</p>
<p>内存虚拟化的思路主要是分块共享，内存共享的核心是内存页面的写时复刻（Copy on Write）</p>
<p>虚拟内存的管理包括3种地址：机器地址、物理地址和虚拟地址。</p>
<h5 id="3-I-O设备虚拟化"><a href="#3-I-O设备虚拟化" class="headerlink" title="3. I/O设备虚拟化"></a>3. I/O设备虚拟化</h5><p>把真实的设备统一管理起来，包装成多个虚拟设备给虚拟机使用。</p>
<p>I/O设备虚拟化同样是由VMM进行管理的，主要有全虚拟化、半虚拟化和软件模拟3种思路。其中软件模拟是主流。</p>
<h4 id="2-2-3-虚拟机迁移"><a href="#2-2-3-虚拟机迁移" class="headerlink" title="2.2.3 虚拟机迁移"></a>2.2.3 虚拟机迁移</h4><p>将虚拟机实例从源宿主机迁移到目标宿主机，并且在目标宿主机上能够将虚拟机运行状态恢复到其在迁移之前的状态。从虚拟机迁移的源于目的的角度看，虚拟机迁移包括3类：</p>
<ul>
<li>物理机到虚拟机 P2V （Physical-to-Virtual）</li>
<li>虚拟机到虚拟机 V2V</li>
<li>虚拟机到物理机 V2P</li>
</ul>
<p>其中<strong>虚拟机到虚拟机</strong>的迁移是云计算关注的<strong>重点</strong>。</p>
<h5 id="1-虚拟机动态迁移"><a href="#1-虚拟机动态迁移" class="headerlink" title="1. 虚拟机动态迁移"></a>1. 虚拟机动态迁移</h5><p><strong>实时迁移</strong>（Live Migration），就是保持虚拟机运行的同时，把它从一台计算机迁移到另一台计算机，并在目的计算机恢复运行的技术。<strong>动态实时迁移</strong>对云计算至关重要。</p>
<ul>
<li>云计算中心物理服务器负载处于动态变化中，当无法提供额外的物理资源时，可以将占用热门物理资源的虚拟机迁移到其它物理服务器，以达到负载均衡</li>
<li>物理服务器定期升级的需要，升级前将虚拟机迁移到其他物理服务器，等升级完成再迁移回来</li>
</ul>
<h5 id="2-迁移的步骤"><a href="#2-迁移的步骤" class="headerlink" title="2. 迁移的步骤"></a>2. 迁移的步骤</h5><ol>
<li>预迁移：主机A选定一个目的计算机作为VM的新主机</li>
<li>预定资源：主机向主机B发送迁移请求，确认B是否有必须资源，有就预定这些资源</li>
<li>预复制：主机A以迭代的方式将VM的内存页复制到主机B上，第一轮迭代传送所有的页，后面的迭代只复制前一轮传送过程中被修改过的页面。</li>
<li>停机复制：停止主机A的VM，把它的网络连接重定向到B。传送CPU状态和前一轮传送过程中被修改过的页。此时，主机A与B有一致的VM映像</li>
<li>提交：主机B通知A成功收到VM映像，主机A确认消息，抛弃或销毁其上的VM</li>
<li>启动：启动B上的VM，迁移后使用B上的设备驱动，广播新的IP地址</li>
</ol>
<h5 id="3-迁移的内容"><a href="#3-迁移的内容" class="headerlink" title="3. 迁移的内容"></a>3. 迁移的内容</h5><h6 id="内存迁移"><a href="#内存迁移" class="headerlink" title="内存迁移"></a>内存迁移</h6><p>是虚拟机迁移最困难的部分。</p>
<p>一个完整的内存迁移可以分为3个阶段：</p>
<ol>
<li>Push：在VM运行的同时，将它的一些内存页面通过网络复制到目的机器上，过程中被修改的页面需要重传，以保证内容的一致性。</li>
<li>Stop-and-Copy：VM停止工作，把剩下的页面复制到计算机上，然后在目的计算机启动新的VM</li>
<li>Pull：新的虚拟机运行过程中，如果访问到未被复制的页面，就会出现页错误并从原来的VM处把该页复制过来</li>
</ol>
<p>实际操作中没有必要同时包含上述3个阶段。下面是3种迁移策略的优劣比较：</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20201031-01.png" alt=""></p>
<h6 id="网络资源的迁移"><a href="#网络资源的迁移" class="headerlink" title="网络资源的迁移"></a>网络资源的迁移</h6><ul>
<li>虚拟机这种系统级别的封装方式意味着迁移时VM的所有网络设备，包括协议状态(如TCP连接状态)以及IP地址都要随之一起迁移。</li>
<li>在局域网内，可以通过发送ARP重定向包，将VM的IP地址与目的机器的MAC地址相绑定， 之后的所有包就可以发送到目的机器上。</li>
</ul>
<h6 id="存储设备的迁移"><a href="#存储设备的迁移" class="headerlink" title="存储设备的迁移"></a>存储设备的迁移</h6><ul>
<li>迁移存储设备的最大障碍在于需要占用大量时间和网络带宽，通常的解决办法是以共享的方式共享数据和文件系统，而非真正迁移。</li>
<li>目前大多数集群使用NAS(Network Attached Storage，网络连接存储)作为存储设备共 享数据。</li>
</ul>
<h4 id="2-2-4-隔离技术"><a href="#2-2-4-隔离技术" class="headerlink" title="2.2.4 隔离技术"></a>2.2.4 隔离技术</h4><p>虚拟机隔离是指虚拟机之间在没有授权许可的情况下，互相之间不可通信，不可联系的一种技术。</p>
<ul>
<li>软件角度：互相隔离的虚拟机之间保持独立，如同一个完整的计算机</li>
<li>硬件角度：被隔离的虚拟机相当于一台物理机，有自己的CPU、内存、硬盘、I/O等，它与宿主机之间保持互相独立的状态</li>
<li>网络角度：被隔离的虚拟机如同物理机一样，既可以对外提供网络服务，也一样可以从外界接受网络服务</li>
</ul>
<p>现有虚拟机隔离机制主要包括：</p>
<ul>
<li>网络隔离</li>
<li>构建虚拟安全文件防护网</li>
<li>基于访问控制的逻辑隔离机制</li>
<li>通过硬件虚拟让每一个虚拟机无法突破虚拟机管理器给出的资源限制</li>
<li>硬件提供的内存保护机制</li>
<li>进程地址空间的保护机制，IP地址隔离</li>
</ul>
<p><strong>确保虚拟机之间的安全与可靠性</strong></p>
<h5 id="1-内存隔离"><a href="#1-内存隔离" class="headerlink" title="1. 内存隔离"></a>1. 内存隔离</h5><p><strong>内存管理单元</strong>（MMU Memory Management Unit）</p>
<ul>
<li>管理虚拟存储器、物理存储器的控制路线</li>
<li>负责将虚拟地址映射为物理地址</li>
<li>提供硬件机制的内存访问授权</li>
</ul>
<p>以Xen为例，它在虚拟内存到机器内存之间引入了一层中间地址，Guest OS看到的是这层中间地址，而不是机器的实际地址。Guest OS感觉自己的物理地址从0开始，是连续的，但Xen将这层中间地址真正地映射到机器地址上却可以是不连续的，这样保证了所有的物理内存可被任意分配给不同的Guest OS。</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20201031-02.png" alt=""></p>
<p>虚拟机监控器使用分段和分页机制对自身的物理内存进行保护。x86体系结构提供了支 持分段机制的虚拟内存，这能够提供另一种形式的特权级分离。</p>
<p>每个段包括基址、段限和一些属性位。</p>
<h5 id="2-网络隔离"><a href="#2-网络隔离" class="headerlink" title="2. 网络隔离"></a>2. 网络隔离</h5><p><strong>目标</strong>：确保把有害的攻击隔离，在可信网络之外和保证可信网络内部信息不外泄的前提下，完成网间数据的安全交换。</p>
<p><strong>关键</strong>：系统对通信数据的控制，即通过不可路由的协议完成网间数据交换</p>
<p><strong>问题</strong>：通信硬件工作在网络最下层（物理层），不能感知交换数据的机密性、完整性、可用性、可控性、抗抵赖等安全要素。</p>
<p><strong>解决方案</strong>：通过访问控制、身份认证、加密签名等安全机制来实现，这些机制都是通过软件实现的。</p>
<p><strong>实现原理</strong>：通过专用通信设备、专有安全协议和加密验证机制及应用数据提取和鉴别认证技术，进行不同安全级别网络之间的数据交换。</p>
<p><strong>效果</strong>：</p>
<ul>
<li>彻底阻断了网络间的直接TCP/IP连接</li>
<li>保证了网间数据交 换的安全、可控</li>
<li>杜绝了由于操作系统和网络协议自身漏洞带来的安全风险 </li>
</ul>
<h3 id="2-2-存储虚拟化"><a href="#2-2-存储虚拟化" class="headerlink" title="2.2 存储虚拟化"></a>2.2 存储虚拟化</h3><p>存储虚拟化将系统中分散的存储资源整合起来。</p>
<ul>
<li>提高了存储资源利用率</li>
<li>降低单位存储空间成本</li>
<li>降低存储管理的负担和复杂性</li>
</ul>
<p><strong>技术与效果</strong></p>
<p>在虚拟层通过适用数据镜像、数据校验和多路径等技术，提高了数据的可靠性及系统的可用性</p>
<p>利用负载均衡、数据迁移、数据块重组等技术，提升系统的潜在性能</p>
<p>整合和重组底层物理资源，得到多种不同性能和可靠性的 新的虚拟设备，满足多种存储应用的需求</p>
<h4 id="2-2-1-存储虚拟化的一般模型"><a href="#2-2-1-存储虚拟化的一般模型" class="headerlink" title="2.2.1 存储虚拟化的一般模型"></a>2.2.1 存储虚拟化的一般模型</h4><p>虚拟化存储系统在原有存储系统结构上增加了虚拟化层，将多个存储单元抽象成一个虚拟存储池。</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20201101-01.png" alt=""></p>
<p>它的优势如下：</p>
<ul>
<li>减少存储系统的管理开销</li>
<li>实现存储系统数据共享</li>
<li>提供透明的高可靠性和可扩展性</li>
</ul>
<h4 id="2-2-2-存储虚拟化的实现方式"><a href="#2-2-2-存储虚拟化的实现方式" class="headerlink" title="2.2.2 存储虚拟化的实现方式"></a>2.2.2 存储虚拟化的实现方式</h4><h5 id="1-基于主机的存储虚拟化"><a href="#1-基于主机的存储虚拟化" class="headerlink" title="1. 基于主机的存储虚拟化"></a>1. 基于主机的存储虚拟化</h5><p>也称基于服务器的存储虚拟化或者基于系统卷管理器的存储虚拟化，其一般是通过逻辑卷管理来实现的。虚拟机为物理卷映射到逻辑卷提供了一个虚拟层。</p>
<p>虚拟机的主要功能如下：</p>
<ul>
<li>数据存储共享</li>
<li>存储资源管理</li>
<li>数据复制及迁移 </li>
<li>集群系统</li>
<li>远程备份</li>
<li>灾难恢复</li>
</ul>
<h5 id="2-基于存储设备的存储虚拟化"><a href="#2-基于存储设备的存储虚拟化" class="headerlink" title="2. 基于存储设备的存储虚拟化"></a>2. 基于存储设备的存储虚拟化</h5><p>也称基于存储控制器的存储虚拟化。主要是在存储设备的磁盘、 适配器或者控制器上实现虚拟化功能。</p>
<p>有很多的存储设备的内部都有功能比较强的处理器，带有专门的嵌入式 统，可以在存储子系统的内部进行存储虚拟化，对外提供虚拟化磁盘。</p>
<h5 id="3-基于网络的存储虚拟化"><a href="#3-基于网络的存储虚拟化" class="headerlink" title="3. 基于网络的存储虚拟化"></a>3. 基于网络的存储虚拟化</h5><p>在网络设备上实现存 储虚拟化功能，包括基于<strong>互连设备</strong>和基于<strong>路由器</strong>两种方式。</p>
<h5 id="4-优劣比较"><a href="#4-优劣比较" class="headerlink" title="4. 优劣比较"></a>4. 优劣比较</h5><div class="table-container">
<table>
<thead>
<tr>
<th>方式</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td>主机</td>
<td>性价比较高</td>
<td>性能较差、可扩展性差、不支持异构平台</td>
</tr>
<tr>
<td>存储设备</td>
<td>存储子系统与主机无关，对系统性能的影响比较小，较容易管理</td>
<td>对于包含异构存储设备的SAN存储系统，虚拟化方法的效果不好，设备规模有限并不能进行级联，可扩展性差</td>
</tr>
<tr>
<td>网络</td>
<td>在<strong>性能、效果和安全</strong>都要好一些</td>
<td>连接主机到存储网络的<strong>路由器出现故障</strong>导致与故障路由器连接在一起的主机受到影响，数据无法访问</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-网络虚拟化"><a href="#2-3-网络虚拟化" class="headerlink" title="2.3 网络虚拟化"></a>2.3 网络虚拟化</h3><p>传统数据中心由于服务器之间操作系统和上层软件异构、接口于数据格式不统一，数据中心内网络传输效率低。使用云计算后，数据同步传送的大流量、备份的大流量、虚拟机迁移的大流量，采用统一的交换网络减少布线、维护工作量和扩容成本。引入虚拟化技术后，数据中心网络虚拟化分为核心层、接入层和虚拟机网络虚拟化三个层面</p>
<h3 id="2-4-桌面虚拟化"><a href="#2-4-桌面虚拟化" class="headerlink" title="2.4 桌面虚拟化"></a>2.4 桌面虚拟化</h3><p>每个桌面镜像就是一个带有应用程序的操作系统，终端用户通过一个虚拟显示协议来访问他们的桌面系统。这样做 的目的就是使用户的使用体验同他们使用桌面上的PC一样。</p>
<p>引用：</p>
<p>[1]刘鹏.云计算[M].电子工业出版社:北京,2015:250-268.</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线程（一）</title>
    <url>/posts/909f13b2.html</url>
    <content><![CDATA[<h1 id="线程（一）"><a href="#线程（一）" class="headerlink" title="线程（一）"></a>线程（一）</h1><h2 id="1-线程的基本概念"><a href="#1-线程的基本概念" class="headerlink" title="1. 线程的基本概念"></a>1. 线程的基本概念</h2><p>一个<strong>线程</strong>是程序内部的顺序控制流</p>
<h3 id="1-1-线程与进程："><a href="#1-1-线程与进程：" class="headerlink" title="1.1 线程与进程："></a>1.1 线程与进程：</h3><p>每个<strong>进程</strong>都有独立的代码和数据空间，进程切换的开销大</p>
<p><strong>线程</strong>是轻量的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器，线程切换的开销小</p>
<p><strong>多进程</strong>：在操作系统中，能同时运行多个任务（程序）</p>
<p><strong>多线程</strong>：在同一个应用程序中，有多个顺序流同时执行（有多个代码段同时在运行）</p>
<p>关于线程与进程的辨析可以看这一篇文章<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">进程与线程的一个简单解释</a></p>
<h3 id="1-2-线程的概念模型："><a href="#1-2-线程的概念模型：" class="headerlink" title="1.2 线程的概念模型："></a>1.2 线程的概念模型：</h3><p>虚拟的CPU，封装在<code>java.lang.Thread</code>类中</p>
<p>CPU所执行的代码和所处理的数据，传递给<code>Thread</code>类</p>
<p><strong>线程体</strong></p>
<p>Java的线程是通过<code>java.lang.Thread</code>类来实现的</p>
<p>每个线程都是通过某个特定的<code>Thread</code>对象的方法<code>run()</code>来完成其操作的，方法<code>run()</code>称为线程体</p>
<h2 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2. 线程状态"></a>2. 线程状态</h2><p>线程可以有如下6种状态：</p>
<ul>
<li>New（新建）</li>
<li>Runnable（可运行）</li>
<li>Blocked （阻塞）</li>
<li>Waiting （等待）</li>
<li>Timed waiting（计时等待）</li>
<li>Terminated （终止）</li>
</ul>
<h3 id="2-1-新建线程"><a href="#2-1-新建线程" class="headerlink" title="2.1 新建线程"></a>2.1 新建线程</h3><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(t);</code></pre>
<p>当使用<code>new</code>新建一个线程时，这个线程还没有开始运行，状态是<strong>新建</strong></p>
<h3 id="2-2-可运行线程"><a href="#2-2-可运行线程" class="headerlink" title="2.2 可运行线程"></a>2.2 可运行线程</h3><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(t).start();</code></pre>
<p>调用<code>start</code>方法，线程就处于<strong>可运行</strong>状态。它可能正在运行也可能没有运行，由操作系统决定它具体的运行时间。所以这个状态被称为<strong>可运行</strong>，而不是运行。</p>
<h3 id="2-3-阻塞和等待线程"><a href="#2-3-阻塞和等待线程" class="headerlink" title="2.3 阻塞和等待线程"></a>2.3 阻塞和等待线程</h3><p>当线程处于阻塞或等待状态时，它暂时是不活动的。</p>
<p>要由线程调度器重新激活这个线程，具体细节取决于它是怎样到达非活动状态的。</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200926-01.png" alt=""></p>
<h3 id="2-4-终止线程"><a href="#2-4-终止线程" class="headerlink" title="2.4 终止线程"></a>2.4 终止线程</h3><p>线程终止的原因有2个：</p>
<ul>
<li><code>run</code>方法正常退出，线程自然终止</li>
<li>因为一个没有捕获的异常终止了<code>run</code>方法，使线程意外终止</li>
</ul>
<h2 id="3-如何创建线程"><a href="#3-如何创建线程" class="headerlink" title="3. 如何创建线程"></a>3. 如何创建线程</h2><p>构造线程的两种方法</p>
<ul>
<li>定义一个线程类，它继承类<code>Thread</code>并重写其中的方法<code>run()</code></li>
<li>提供一个实现接口<code>Runnable</code>的类作为线程的目标对象，在初始化一个<code>Thread</code>类或者<code>Thread</code>子类的线程对象时，把目标对象传递给这个线程实例，由该目标对象提供线程体<code>run()</code></li>
</ul>
<h3 id="3-1-通过Thread类创建线程"><a href="#3-1-通过Thread类创建线程" class="headerlink" title="3.1 通过Thread类创建线程"></a>3.1 通过Thread类创建线程</h3><p>通过<code>Thread</code>类来创建线程</p>
<p>继承<code>Thread</code>类，创建多线程的方法之一</p>
<ul>
<li>从<code>Thread</code>类派生一个子类，并创建子类的对象</li>
<li>子类应该重写<code>Thread</code>类的<code>run</code>方法，写入需要在新线程中执行的语句段</li>
<li><strong>调用<code>start</code>方法来启动新线程</strong>，自动进入<code>run</code>方法（不是直接调用<code>run</code>方法）</li>
</ul>
<p>我们来看下面这个计算阶乘的程序</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactorialThreadTester</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;main thread starts&quot;</span>);
        FactorialThread myThread = <span class="hljs-keyword">new</span> FactorialThread(<span class="hljs-number">10</span>);
        myThread.start();
        System.out.println(<span class="hljs-string">&quot;main thread ends&quot;</span>);
    &#125;
&#125;</code></pre>
<p>我们自定义了<code>FactorialThread</code>类继承<code>Thread</code>类，重写了<code>run</code>方法</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactorialThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FactorialThread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.num = num;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = num;
        <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;
        System.out.println(<span class="hljs-string">&quot;new thread starts&quot;</span>);
        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;
            result *= i;
            i--;
        &#125;
        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result);
        System.out.println(<span class="hljs-string">&quot;new thread ends&quot;</span>);
    &#125;
&#125;</code></pre>
<p>结果：</p>
<pre><code class="hljs autohotkey">main <span class="hljs-keyword">thread</span> starts
main <span class="hljs-keyword">thread</span> ends
<span class="hljs-keyword">new</span> <span class="hljs-keyword">thread</span> starts
<span class="hljs-title">Result:</span> <span class="hljs-number">3628800</span>
<span class="hljs-keyword">new</span> <span class="hljs-keyword">thread</span> ends</code></pre>
<p>主线程的任务就是创新新线程，创建完成后主线程就结束了</p>
<p>结果说明：</p>
<ul>
<li><code>main</code>线程已经执行完后，新线程才执行完</li>
<li><code>main</code>方法调用<code>thread.start()</code>方法启动新线程后并不等待<code>run</code>方法返回就继续运行，线程的<code>run</code>方法在一边独自运行，不影响原来的<code>main</code>方法的运行，也就是说新建的线程调用<code>start()</code>方法后不一定立即进入运行状态</li>
</ul>
<h3 id="3-2-通过Runnable接口构造线程"><a href="#3-2-通过Runnable接口构造线程" class="headerlink" title="3.2 通过Runnable接口构造线程"></a>3.2 通过Runnable接口构造线程</h3><ul>
<li>只有一个<code>run()</code>方法</li>
<li><code>Thread</code>类实现了<code>Runnable</code>接口</li>
<li>便于多个线程共享资源</li>
<li>Java不支持多继承，如果定义的类已经继承了某个基类，便需要实现<code>Runnable</code>接口来实现多线程</li>
<li>以实现<code>Runnable</code>的对象为参数建立新的线程</li>
</ul>
<p>我们定义一个<code>ThreadSleep</code>类实现<code>Runnable</code>接口</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSleep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sleepTime;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadSleep</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.sleepTime = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">6000</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is going to sleep for &quot;</span> + sleepTime);
            Thread.sleep(sleepTime);
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;

        &#125;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ends&quot;</span>);
    &#125;
&#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ThreadSleep t = <span class="hljs-keyword">new</span> ThreadSleep();
        <span class="hljs-keyword">new</span> Thread(t, <span class="hljs-string">&quot;task1&quot;</span>).start();
    &#125;
&#125;</code></pre>
<p>或者也可以使用lambda表达式来创建实例</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Runnable task1 = () -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">int</span> sleepTime = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">6000</span>);
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is going to sleep for &quot;</span> + sleepTime);
                Thread.sleep(sleepTime);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ends&quot;</span>);
        &#125;;
        <span class="hljs-keyword">new</span> Thread(task1, <span class="hljs-string">&quot;task1&quot;</span>).start();
    &#125;
&#125;</code></pre>
<p>使用<code>Runnable</code>接口实现线程可以将CPU，代码和数据分开，形成清晰的模型，还可以从其他类继承</p>
<p>直接继承<code>Thread</code>类实现线程，编写简单，直接继承，重写<code>run</code>方法，但是不能再从其他类继承</p>
<h2 id="3-线程属性"><a href="#3-线程属性" class="headerlink" title="3. 线程属性"></a>3. 线程属性</h2><h3 id="3-1-中断线程"><a href="#3-1-中断线程" class="headerlink" title="3.1 中断线程"></a>3.1 中断线程</h3><p>除了已经废弃的<code>stop</code>方法，没有方法可以<strong>强制</strong>线程终止。不过，<code>interrupt</code>方法可以用来<strong>请求</strong>终止一个线程</p>
<p>当对一个线程调用<code>interrupt</code>方法时，就会设置线程的<strong>中断状态</strong>为<code>true</code>，如果当前线程被一个<code>sleep</code>调用阻塞，则抛出一个<code>InterruptedException</code>异常。</p>
<pre><code class="hljs java"><span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;
  <span class="hljs-comment">//blablabla</span>
&#125;</code></pre>
<p><code>static Thread currentThread()</code>返回表示当前正在执行的线程的<code>Thread</code>对象</p>
<p><code>boolean isInterrupted()</code>测试线程是否被中断</p>
<h3 id="3-2-守护线程"><a href="#3-2-守护线程" class="headerlink" title="3.2 守护线程"></a>3.2 守护线程</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDaemon</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isDaemon)</span></span></code></pre>
<p>调用<code>t.setDaemon(true)</code>将一个线程转换为守护线程，必须在线程启动之前调用，作用是为其它线程提供服务。比如计时器定时发送信号给其它线程，如果只剩下守护线程，虚拟机就会退出。</p>
<h2 id="4-线程的休眠"><a href="#4-线程的休眠" class="headerlink" title="4. 线程的休眠"></a>4. 线程的休眠</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactorialThreadTester</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;main thread starts&quot;</span>);
        FactorialThread myThread = <span class="hljs-keyword">new</span> FactorialThread(<span class="hljs-number">10</span>);
        myThread.start();
        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">1000</span>);
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;

        &#125;
        System.out.println(<span class="hljs-string">&quot;main thread ends&quot;</span>);
    &#125;
&#125;</code></pre>
<p>结果</p>
<pre><code class="hljs autohotkey">main <span class="hljs-keyword">thread</span> starts
<span class="hljs-keyword">new</span> <span class="hljs-keyword">thread</span> starts
<span class="hljs-title">Result:</span> <span class="hljs-number">3628800</span>
<span class="hljs-keyword">new</span> <span class="hljs-keyword">thread</span> ends
main <span class="hljs-keyword">thread</span> ends</code></pre>
<p>运行结果说明，新线程结束后<code>main</code>线程才结束。</p>
<p>线程休眠就是为了让其他线程得到执行的机会</p>
<h2 id="5-线程内部的数据共享"><a href="#5-线程内部的数据共享" class="headerlink" title="5. 线程内部的数据共享"></a>5. 线程内部的数据共享</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ThreadSleep t = <span class="hljs-keyword">new</span> ThreadSleep();
        System.out.println(<span class="hljs-string">&quot;Starting threads&quot;</span>);
        <span class="hljs-keyword">new</span> Thread(t, <span class="hljs-string">&quot;task1&quot;</span>).start();
        <span class="hljs-keyword">new</span> Thread(t, <span class="hljs-string">&quot;task2&quot;</span>).start();
        <span class="hljs-keyword">new</span> Thread(t, <span class="hljs-string">&quot;task3&quot;</span>).start();
        System.out.println(<span class="hljs-string">&quot;Thread started, main ends&quot;</span>);

    &#125;
&#125;
</code></pre>
<p>结果</p>
<pre><code class="hljs vim">Starting threads
Thread started, main ends
task1 <span class="hljs-keyword">is</span> going <span class="hljs-keyword">to</span> <span class="hljs-keyword">sleep</span> <span class="hljs-keyword">for</span> <span class="hljs-number">5235</span>
task3 <span class="hljs-keyword">is</span> going <span class="hljs-keyword">to</span> <span class="hljs-keyword">sleep</span> <span class="hljs-keyword">for</span> <span class="hljs-number">5235</span>
task2 <span class="hljs-keyword">is</span> going <span class="hljs-keyword">to</span> <span class="hljs-keyword">sleep</span> <span class="hljs-keyword">for</span> <span class="hljs-number">5235</span>
task2 ends
task1 ends
task3 ends</code></pre>
<p>3个线程的休眠时间是一样的，因为是用一个<code>Runnable</code>类型的对象创建的3个新线程，这3个线程就共享了这个对象的私有成员<code>sleepTime</code>。</p>
<p>在现实生活中，如果我们需要多个售票窗口同时销售200张票，就可以使用上述的方法。</p>
<p>参考：</p>
<ol>
<li><p>《Java核心技术 卷I》</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.xuetangx.com/learn/THU08091000252/THU08091000252/4230709/exercise/6246467">学堂在线-Java程序设计进阶</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 接口</title>
    <url>/posts/d993c7e9.html</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><strong>接口</strong>(<em>interface</em>)用来描述类应该做什么，而不指定它们具体该如何做。一个类可以<strong>实现</strong>(<em>implement</em>)一个或多个接口。</p>
<h2 id="1-接口的概念"><a href="#1-接口的概念" class="headerlink" title="1. 接口的概念"></a>1. 接口的概念</h2><p>接口不是类，而是对希望符合这个接口的类的一组<strong>需求</strong></p>
<p><strong>Tip</strong></p>
<ul>
<li>接口中的所有方法都自动是<code>public</code>，因此在接口中声明方法时，不必提供关键字<code>public</code></li>
<li>接口绝不会有实例字段</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-title">implement</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Employee</span>&gt; </span>&#123;
    <span class="hljs-comment">// blablabla</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Employee other)</span> </span>&#123;
        <span class="hljs-keyword">return</span> Integer.compare(salary, other.salary);
    &#125;
&#125;</code></pre>
<h2 id="2-接口的属性"><a href="#2-接口的属性" class="headerlink" title="2. 接口的属性"></a>2. 接口的属性</h2><p>接口不是类，不能够使用<code>new</code>实例化一个接口，但是可以声明接口的变量，接口变量必须引用实现这个接口的类对象</p>
<pre><code class="hljs java">Comparable x = <span class="hljs-keyword">new</span> Employee(. . .);</code></pre>
<p><strong>Tip</strong><br>为什么需要接口，而不是直接使用抽象类？<br>因为Java不支持多继承，所以每个类只能扩展一个类。<br>而接口提供了多继承的好处，而避免了多重继承的复杂性和低效性。</p>
<h2 id="3-接口与回调"><a href="#3-接口与回调" class="headerlink" title="3. 接口与回调"></a>3. 接口与回调</h2><p><strong>回调</strong>(<em>callback</em>)是一种常见的程序设计模式。在这种模式中，可以指定某个特定事件发生时应该采取的动作。比如我们设计了一个时钟，可以请求每秒更新一次，以便更新时钟的表盘。</p>
<p>下面是一个定时器和动作监听的具体使用的例子，定时器启动之后，程序将弹出一个消息对话框，并等待用户点击OK来终止程序的运行，在程序等待用户操作的同时，每隔1秒显示一次当前时间</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;
<span class="hljs-keyword">import</span> java.awt.event.*;
<span class="hljs-keyword">import</span> java.time.*;
<span class="hljs-keyword">import</span> javax.swing.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerTest</span></span>
<span class="hljs-class"></span>&#123;  
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">   </span>&#123;  
      TimePrinter listener = <span class="hljs-keyword">new</span> TimePrinter();

      <span class="hljs-comment">// construct a timer that calls the listener</span>
      <span class="hljs-comment">// once every second</span>
      Timer timer = <span class="hljs-keyword">new</span> Timer(<span class="hljs-number">1000</span>, listener);
      timer.start();

      <span class="hljs-comment">// keep program running until the user selects &quot;OK&quot;</span>
      JOptionPane.showMessageDialog(<span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Quit program?&quot;</span>);
      System.exit(<span class="hljs-number">0</span>);
   &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimePrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ActionListener</span></span>
<span class="hljs-class"></span>&#123;  
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent event)</span></span>
<span class="hljs-function">   </span>&#123;  
      System.out.println(<span class="hljs-string">&quot;At the tone, the time is &quot;</span> 
         + Instant.ofEpochMilli(event.getWhen()));
      Toolkit.getDefaultToolkit().beep();
   &#125;
&#125;
</code></pre>
<h2 id="4-Comparator接口"><a href="#4-Comparator接口" class="headerlink" title="4. Comparator接口"></a>4. Comparator接口</h2><p>如果我们想要对字符串数组进行排序，可以直接使用<code>String.compareTo</code>方法按字典顺序比较字符串。<br>如果我们希望按照字符串长度来进行比较，可以自己实现一个<strong>比较器</strong>(<em>comparator</em>)，如下面的例子中，将比较器作为参数传入<code>Arrays.sort</code>方法中。</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.Comparator;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LengthCompare</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        String[] friends = &#123;<span class="hljs-string">&quot;Adam&quot;</span>, <span class="hljs-string">&quot;Ben&quot;</span>, <span class="hljs-string">&quot;Peter&quot;</span>, <span class="hljs-string">&quot;Noah&quot;</span>&#125;;
        Arrays.sort(friends, <span class="hljs-keyword">new</span> LengthComparator());
        System.out.println(Arrays.toString(friends));
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LengthComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;
        <span class="hljs-keyword">return</span> o1.length() - o2.length();
    &#125;
&#125;</code></pre>
<p>参考：</p>
<ol>
<li>《Java核心技术 卷I》</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 继承</title>
    <url>/posts/8b3a0e63.html</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承(inheritance)的基本思想是基于已经有的类创建新的类，复用这些类的方法。</p>
<h2 id="一、类，超类和子类"><a href="#一、类，超类和子类" class="headerlink" title="一、类，超类和子类"></a>一、类，超类和子类</h2><p>在前面的文章中我们实现了一个<code>Employee</code>类，假设你在某个公司工作，这个公司的经理和员工的待遇不一样，普通员工在完成任务后仅领取薪水，而经理还拥有奖金。<br>这个时候，我们可以定义一个新类<code>Manager</code>，使用继承重用<code>Employee</code>中的代码，同时定义新的方法来增加奖金这一功能。</p>
<p><strong>Tip</strong><br><code>Manager</code> <strong>is-a</strong> <code>Employee</code><br><strong>is-a</strong>关系是继承的一个明显特征</p>
<h3 id="1-定义子类"><a href="#1-定义子类" class="headerlink" title="1. 定义子类"></a>1. 定义子类</h3><p>使用<code>extends</code>关键字来表示继承</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;
    <span class="hljs-comment">// blablabla</span>
&#125;</code></pre>
<p>关键字<code>extends</code>表明正在构造的新类派生于一个已经存在的类。这个类被称为<strong>超类</strong>(<em>superclass</em>) 或<strong>父类</strong>(<em>parent class</em>)，新类称为<strong>子类</strong>(<em>subclass</em>)<br>在设计类时，应该将一般方法放在超类中，将更特殊的方法放在子类中<br>比如我们在<code>Manager</code>类中应该实现一个设置奖金金额的方法。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bonus;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBonus</span><span class="hljs-params">(<span class="hljs-keyword">double</span> bonus)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.bonus = bonus;
    &#125;
&#125;</code></pre>
<h3 id="2-覆盖方法"><a href="#2-覆盖方法" class="headerlink" title="2. 覆盖方法"></a>2. 覆盖方法</h3><p>超类中的某些方法对子类不一定适用，比如<code>Manager</code>类中的<code>getSalary</code>方法应该返回薪水和奖金的总和，所以要提供一个新的方法来<strong>覆盖</strong>(<em>override</em>)超类中的某个方法。<br>要注意的是，<code>Manager</code>类的<code>getSalary</code>方法不能够直接访问<code>salary</code>字段，因为其实<code>Employee</code>类的私有字段，所以需要使用<code>super</code>关键字</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> baseSalary = <span class="hljs-keyword">super</span>.getSalary();
    <span class="hljs-keyword">return</span> baseSalary + bonus;
&#125;</code></pre>
<h3 id="3-子类构造器"><a href="#3-子类构造器" class="headerlink" title="3. 子类构造器"></a>3. 子类构造器</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> salary)</span> </span>&#123;
    <span class="hljs-keyword">super</span>(id, name, salary);
    bonus = <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>语句<code>super(id, name, salary);</code>实现了对<code>Employee</code>中私有字段的调用</p>
<h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4. 多态"></a>4. 多态</h3><p>我们可以通过<code>is-a</code>来判断是否将数据设计为继承关系，它的另外一种表述是<strong>替换原则</strong>，即程序中出现超类对象的任何地方都可以使用子类对象替换。</p>
<p>在Java中，对象变量时<strong>多态</strong>(<em>polymophic</em>)的。<br>一个<code>Employee</code>类型的变量既可以引用一个<code>Employee</code>类型的对象,也可以引用<code>Employee</code>类的任何一个子类的对象(比如<code>Manager</code>)</p>
<pre><code class="hljs java">Employee e;
e = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">10000</span>);
e = <span class="hljs-keyword">new</span> Manager(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">20000</span>);</code></pre>
<p>虽然这里的<code>e</code>引用了<code>Manager</code>类型的对象，但是编译器只将<code>e</code>看成是一个<code>Employee</code>对象，所以如下的调用是错误的。</p>
<pre><code class="hljs java">e.setBonus(<span class="hljs-number">10000</span>); <span class="hljs-comment">// ERROR</span></code></pre>
<h3 id="5-阻止继承-final类和方法"><a href="#5-阻止继承-final类和方法" class="headerlink" title="5. 阻止继承: final类和方法"></a>5. 阻止继承: final类和方法</h3><p>如果我们需要阻止某个类被继承，可以使用<code>final</code>关键字</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;
    <span class="hljs-comment">// blablabla</span>
&#125;</code></pre>
<p>类中的某个特定的方法也可以声明为<code>final</code>，这样子类就不能够覆盖这个方法。</p>
<p><strong>Tip</strong><br>为什么要将类或方法声明为<code>final</code>？<br>确保它们不会在子类中改变语义。比如<code>String</code>类是<code>final</code>类，所以一个<code>String</code>引用引用的一定是<code>String</code>对象，而不是其它。</p>
<h3 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6. 抽象类"></a>6. 抽象类</h3><p>在继承层次结构中，位于上层的类更具有一般性<br>比如我们加入<code>Person</code>类和<code>Student</code>类，下图是这三个类之间的继承关系</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200908-02.png" alt=""></p>
<p>每个人都有一些属性，比如姓名，年龄，引入一个公共的超类，就可以把<code>getName</code>方法放在继承层次结构中的更高一层，使用<code>abstract</code>关键字来定义抽象类</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span> <span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;
&#125;</code></pre>
<p>抽象类不能够实例化，如下的表达式是错误的</p>
<pre><code class="hljs java"><span class="hljs-keyword">new</span> Person(); <span class="hljs-comment">// ERROR</span></code></pre>
<h2 id="二、对象包装器与自动装箱"><a href="#二、对象包装器与自动装箱" class="headerlink" title="二、对象包装器与自动装箱"></a>二、对象包装器与自动装箱</h2><p>所有的基本类型都有一个与之对应的类，这些类被称为<strong>包装器</strong>(<em>wrapper</em>)，分别是<code>Integer, Long, Float, Double, Short, Byte, Character, Boolean</code>。<br>包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值，同时，包装器还是<code>final</code>，不能够派生它们的子类。</p>
<p><strong>Tip</strong><br>为什么需要包装类？<br>因为Java是一种面向对象程序设计语言，很多地方需要使用对象而不是基本类型。比如在<code>ArrayList</code>中，我们不能够写成<code>ArrayList&lt;int&gt;</code>，而要写成<code>ArrayList&lt;Integer&gt;</code>。</p>
<h3 id="2-自动拆箱与装箱"><a href="#2-自动拆箱与装箱" class="headerlink" title="2. 自动拆箱与装箱"></a>2. 自动拆箱与装箱</h3><p>自动装箱: 就是将基本数据类型自动转换成对应的包装类。<br>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</p>
<pre><code class="hljs java">Integer n = <span class="hljs-number">3</span>; <span class="hljs-comment">// 自动装箱</span>
<span class="hljs-keyword">int</span> m = n; <span class="hljs-comment">// 自动拆箱</span></code></pre>
<h2 id="三、继承的设计技巧"><a href="#三、继承的设计技巧" class="headerlink" title="三、继承的设计技巧"></a>三、继承的设计技巧</h2><ol>
<li>将公共操作和字段放在超类中</li>
<li>使用继承实现<strong>is-a</strong>关系</li>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>在覆盖方法时，不要改变预期的行为</li>
<li>使用多态，而不要使用类型信息</li>
</ol>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/boxing-unboxing">Java工程师成神之路</a></li>
<li>《Java核心技术 卷I》</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面向对象概述</title>
    <url>/posts/e27767b2.html</url>
    <content><![CDATA[<h1 id="对象与类概述"><a href="#对象与类概述" class="headerlink" title="对象与类概述"></a>对象与类概述</h1><h2 id="一、面向对象程序设计概述"><a href="#一、面向对象程序设计概述" class="headerlink" title="一、面向对象程序设计概述"></a>一、面向对象程序设计概述</h2><p>结构化程序：算法+数据结构 = 程序 </p>
<p>（即确定如何操作数据，再决定如何组织数据的结构）</p>
<p>面向对象程序设计(OOP)：将数据放在第一位，再考虑操作数据的算法</p>
<h3 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h3><ol>
<li><p><strong>类(class)</strong>是构造对象的模板或<strong>蓝图</strong>，就好像一个制作某件工艺品的模具，对象就是工艺品</p>
</li>
<li><p>由类构造(construct)对象的过程称为创建类的<strong>实例(instance)</strong></p>
</li>
<li><p><strong>封装(encapsulation)</strong>将<strong>数据</strong>和<strong>行为</strong>组合在一个包中，对对象的使用者隐藏具体的实现方式，也称为<strong>数据隐藏</strong></p>
</li>
<li><p>对象中的数据称为<strong>实例字段(instance field)</strong>，操作数据的过程称为<strong>方法(method)</strong></p>
</li>
<li><p>对象拥有的实例字段值的集合就是这个对象的当前<strong>状态(state)</strong></p>
</li>
<li>程序只能通过对象的方法和对象数据进行交互，对象被赋予了“黑盒”的特征，提高了重用性和可靠性</li>
<li>可以通过扩展一个类来构建新的类，这使得用户自定义类更加容易。在Java中，所有类都来自于一个<strong>超类</strong>，即<code>Object</code>。</li>
<li>通过扩展一个类来建立一个新的类的过程就是<strong>继承(inheritance)</strong>，新类具有被扩展的类的全部属性和方法，可以自定义新的属性和方法。</li>
</ol>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><p>对象的3个特性：</p>
<ul>
<li><strong>行为(behavior)</strong>——可以对对象完成的操作（应用的方法）</li>
<li><strong>状态(state)</strong>——描述当前状况的信息，状态的改变必须通过调用方法实现</li>
<li><strong>标识(identity)</strong>——每个对象有唯一的标识来区分（如两个订单的编号肯定不相同）</li>
</ul>
<h3 id="3-识别类"><a href="#3-识别类" class="headerlink" title="3. 识别类"></a>3. 识别类</h3><p>编写程序从<strong>识别类</strong>开始，然后为各个类添加方法。</p>
<p>一个简单的方法是在分析问题的过程中寻找<strong>名词——类</strong>，寻找<strong>动词——方法</strong></p>
<p>例如我们有商品，订单，账户这样的名词作为类，即Item，Order，Account</p>
<p>那么在账户这个类中，就可以有增加账户，修改账户等方法。</p>
<h3 id="4-类之间的关系"><a href="#4-类之间的关系" class="headerlink" title="4. 类之间的关系"></a>4. 类之间的关系</h3><p>类之间最常见的关系有：</p>
<ul>
<li><strong>依赖</strong>（”<em>uses-a</em>“）</li>
<li><strong>聚合</strong> （”<em>has-a</em>“）</li>
<li><strong>继承</strong>（<em>“is-a”</em>)</li>
</ul>
<h4 id="4-1-依赖（dependence）"><a href="#4-1-依赖（dependence）" class="headerlink" title="4.1 依赖（dependence）"></a>4.1 依赖（dependence）</h4><p>如果一个类的方法使用或操纵另一个类的对象，我们就可以说一个类依赖于另一个类</p>
<p>比如Order对象访问Account对象查看信用状态，这就是一个使用(“uses-a”)的关系。</p>
<p>（尽可能减少相互依赖的类，做到低耦合）</p>
<h4 id="4-2-聚合（aggregation）"><a href="#4-2-聚合（aggregation）" class="headerlink" title="4.2 聚合（aggregation）"></a>4.2 聚合（aggregation）</h4><p>类A的对象包含（”has-a”）类B的对象</p>
<p>如一个Order对象就包含了一些Item对象</p>
<h4 id="4-3-继承（inheritance）"><a href="#4-3-继承（inheritance）" class="headerlink" title="4.3 继承（inheritance）"></a>4.3 继承（inheritance）</h4><p>一个更特殊的类与一个更一般的类之间的关系</p>
<p>也就是前面提到的扩展，比如现在我们定义一个加急订单RushOrder类，那么它是一个（”is-a”)Order类</p>
<p>也就是有Order类继承而来。</p>
<p>下图展示了上述的三种关系。<br><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200423LearnJava01.png" alt=""></p>
<h2 id="二、使用预定义类"><a href="#二、使用预定义类" class="headerlink" title="二、使用预定义类"></a>二、使用预定义类</h2><p>我们通过可以Java中的预定于类来了解如何构造对象，以及如何使用类的方法。<br>如下的例子：</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Date birthday = <span class="hljs-keyword">new</span> Date();
        System.out.println(birthday.toString());
    &#125;
&#125;</code></pre>
<p>在Java中，要使用构造器(constructor)来构造新的实例，比如上面的代码中<code>new Date()</code>就构造了一个新的对象，这个对象被初始化为当前的日期和时间。</p>
<p><strong>Tip</strong><br>需要注意的是，单独的定义<code>Date birthday</code>中的<code>birthday</code>并不是对象，对它进行操作编译器会报错。一定要<strong>初始化</strong>变量<code>birthday</code>。<br>对象变量本身并不包含一个对象，而是<strong>引用</strong>一个对象，<code>new</code>操作符的返回值也是一个引用。</p>
<h2 id="三、自定义类"><a href="#三、自定义类" class="headerlink" title="三、自定义类"></a>三、自定义类</h2><h3 id="1-对象与对象变量"><a href="#1-对象与对象变量" class="headerlink" title="1. 对象与对象变量"></a>1. 对象与对象变量</h3><p>要想使用对象，就需要先构造对象，并指定其初始状态。在Java中，使用构造器（构造函数）来构造。</p>
<p>比如某公司有一个职员管理系统，其中有一个关于职员信息的类<em>Employee</em></p>
<p>那么我们可以通过下面这个表达式构造一个新对象</p>
<pre><code class="hljs java">Employee employee = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Allen&quot;</span>, <span class="hljs-number">10000</span>);</code></pre>
<p>其中<code>employee</code>是一个<strong>对象变量</strong>，我们用<code>new Employee(int id, String name, int salary)</code>构造了一个新对象，初始化该对象变量，要注意的是对象变量并没有包含一个对象，而是<strong>引用</strong>一个对象。</p>
<p>在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> salary;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> salary)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.salary = salary;
    &#125;
		
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> salary;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        Employee[] staff = <span class="hljs-keyword">new</span> Employee[<span class="hljs-number">3</span>];

        staff[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Allen&quot;</span>, <span class="hljs-number">10000</span>);
        staff[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Ben&quot;</span>, <span class="hljs-number">12000</span>);
        staff[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;David&quot;</span>, <span class="hljs-number">15000</span>);

        <span class="hljs-keyword">for</span> (Employee e : staff) &#123;
            System.out.println(<span class="hljs-string">&quot;id=&quot;</span> + e.getId() + <span class="hljs-string">&quot;,name=&quot;</span> + e.getName() + <span class="hljs-string">&quot;,salary=&quot;</span> + e.getSalary());
        &#125;
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">Output:</span>
<span class="hljs-comment">id=1,name=Allen,salary=10000</span>
<span class="hljs-comment">id=2,name=Ben,salary=12000</span>
<span class="hljs-comment">id=3,name=David,salary=15000</span>
<span class="hljs-comment">*/</span></code></pre>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><p>构造函数，与类同名，将实例初始化为指定的初始状态</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> salary)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.salary = salary;
    &#125;</code></pre>
<p><strong>Tip</strong></p>
<ul>
<li>构造函数根据参数的不同可以有多个，</li>
<li>构造函数没有返回值。</li>
</ul>
<h3 id="4-封装的优点"><a href="#4-封装的优点" class="headerlink" title="4. 封装的优点"></a>4. 封装的优点</h3><p>如下是一个访问器方法，又称为<strong>字段访问器</strong></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;</code></pre>
<p><strong>Tip</strong><br>为什么不直接将这些变量设为public公共访问呢？<br>因为这样的话这些变量就可以轻易的被外界修改，受到破坏<br>比如这里的职员id应该是只读的，不能够设置为public被外界随意更改。</p>
<h3 id="4-final"><a href="#4-final" class="headerlink" title="4. final"></a>4. final</h3><p>定义为final的实例字段必须在构造对象时<strong>初始化</strong>，否则编辑器会报错，顾名思义，<code>final</code>表示最终的，在初始化之后不能够再修改这个值。</p>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name = <span class="hljs-string">&quot;John&quot;</span>;</code></pre>
<p><strong>Tip</strong><br><code>final</code>修饰符对于基本类型和不可变类，如String类适用，但是对于可变的类，如<code>StringBuilder</code>就会出现问题，因为它仅仅保证了引用不会指向另外一个对象，但是这个对象是可以更改的。</p>
<h2 id="四、静态字段和静态方法"><a href="#四、静态字段和静态方法" class="headerlink" title="四、静态字段和静态方法"></a>四、静态字段和静态方法</h2><h3 id="1-静态字段"><a href="#1-静态字段" class="headerlink" title="1. 静态字段"></a>1. 静态字段</h3><p>回到我们之前的<code>Employee</code>类中，如果我们需要一个变量来记录公司有多少雇员，就可以使用<code>static</code>修饰符，定义一个静态变量</p>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;</code></pre>
<p>静态变量是属于类的变量，而不属于单个对象，对于<code>Employee</code>类的所有实例，共享一个<code>count</code>。<br>而对非静态的变量，每个对象都有一个自己的副本</p>
<h3 id="2-静态常量"><a href="#2-静态常量" class="headerlink" title="2. 静态常量"></a>2. 静态常量</h3><p><code>Math</code>类中定义了一个静态常量<code>PI</code></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">3.1415926535897932846</span>;
&#125;</code></pre>
<p>我们可以通过<code>Math.PI</code>来直接访问它，如果没有<code>static</code>，那么就需要创建<code>Math</code>类的对象来访问它，效率比较低。</p>
<h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h3><p>如果我们想要知道公司的雇员人数，就可以使用静态方法</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 返回静态变量</span>
    <span class="hljs-keyword">return</span> count; 
&#125;</code></pre>
<p>使用静态方法的两种情况：</p>
<ul>
<li>方法不需要访问对象状态</li>
<li>方法只需要访问类的静态字段（比如上面的例子）</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>异常与断言</title>
    <url>/posts/35f9d194.html</url>
    <content><![CDATA[<h1 id="异常与断言"><a href="#异常与断言" class="headerlink" title="异常与断言"></a>异常与断言</h1><p>在理想世界里，用户输入数据的格式永远都是正确的，代码永远不会出现bug，然而，在现实世界的开发过程中，总会遇到各种各样的问题，当然，我也可以说，这不是bug，而是特性~~~<br>言归正传，如果由于程序的错误导致用户所做的工作统统丢失，那用户可能就再也不会用它了。为了避免这样的情况，至少应该做到以下几点</p>
<ul>
<li>向用户通知错误</li>
<li>保存所有的工作</li>
<li>允许用户妥善地退出程序</li>
</ul>
<h2 id="1-处理错误"><a href="#1-处理错误" class="headerlink" title="1. 处理错误"></a>1. 处理错误</h2><p>为了能够处理程序中的异常情况，必须考虑到程序中可能会出现的错误和问题。比如：</p>
<ul>
<li>用户输入错误</li>
<li>设备错误</li>
<li>物理限制</li>
<li>代码错误</li>
</ul>
<h3 id="1-1-异常分类"><a href="#1-1-异常分类" class="headerlink" title="1.1 异常分类"></a>1.1 异常分类</h3><p>在Java中，异常对象都是派生于<code>Throwable</code>类的一个实例。在下一层分解为两个分支，<code>Error</code>和<code>Exception</code>。<br><code>Error</code>描述了Java运行时系统的内部错误和资源耗尽错误<br><code>Exception</code>又分解为两个分支<br>由编程错误导致的<code>RuntimeException</code>，比如错误的强制类型转换，数组访问越界等<br>由<code>I/O</code>错误导致的其他异常<code>IOException</code>，比如试图打开一个不存在的文件等<br>如下图所示是异常层次结构的一个示意图</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200912-02.png" alt=""></p>
<p><strong>Tip</strong></p>
<ul>
<li>如果出现<code>RuntimeException</code>，那么一定是你的问题</li>
<li>Java将派生于<code>Error</code>类或<code>RuntimeException</code>类的所有异常称为<strong>非检查型</strong>(<em>unchecked</em>)，所有其他异常称为<strong>检查型</strong>(<em>checked</em>)</li>
</ul>
<h3 id="1-2-如何抛出异常"><a href="#1-2-如何抛出异常" class="headerlink" title="1.2 如何抛出异常"></a>1.2 如何抛出异常</h3><p>假设我们正在读取一个文件，预期读取1024个字符，但是在读到500个字符的时候文件就结束了，出现了问题，我们希望抛出一个<code>EOFException</code>，即输入过程中意外遇到了EOF。</p>
<pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">readData</span><span class="hljs-params">(Scanner in)</span> <span class="hljs-keyword">throws</span> EOFException </span>&#123;
    <span class="hljs-comment">// blablabla</span>
    <span class="hljs-keyword">if</span> (!in.hasNext()) &#123;
        <span class="hljs-keyword">if</span> (n &lt; len) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EOFException();
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="1-3-创建异常类"><a href="#1-3-创建异常类" class="headerlink" title="1.3 创建异常类"></a>1.3 创建异常类</h3><p>如果我们遇到了标准异常类无法描述清楚的问题，可以自己创建异常类。我们可以定义一个派生于<code>Exception</code>的类，或者某个<code>Exception</code>的子类，比如<code>IOException</code>。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileFormatException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOException</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileFormatException</span><span class="hljs-params">()</span> </span>&#123;&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileFormatException</span><span class="hljs-params">(String gripe)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(gripe);
    &#125;
&#125;</code></pre>
<h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h2><p>要想捕获一个异常，需要设置<code>try/catch</code>块。</p>
<pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;
    <span class="hljs-comment">// blablabla</span>
&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
    <span class="hljs-comment">// blablabla</span>
&#125;</code></pre>
<p>如果<code>try</code>语句块中的代码抛出了<code>catch</code>子句中指定的一个类，那么程序将跳过<code>try</code>语句块中的其余代码，并执行<code>catch</code>语句块中的代码。如果<code>try</code>中的代码没有异常，那么程序就会跳过<code>catch</code>语句。</p>
<h3 id="2-1-finally子句"><a href="#2-1-finally子句" class="headerlink" title="2.1 finally子句"></a>2.1 finally子句</h3><p>代码抛出一个异常时，就会停止处理这个方法中的剩余代码，但是如果这个方法中存在一些资源需要被清理，就会产生问题。<br><code>finally</code>子句不管异常有没有被捕获，都会执行。比如下面的例子，所有情况下都会程序都会关闭输入流。</p>
<pre><code class="hljs java">FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream();
<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-comment">// blablabla</span>
&#125;
<span class="hljs-keyword">catch</span> (IOException e) &#123;
    <span class="hljs-comment">// blablabla</span>
&#125;
<span class="hljs-keyword">finally</span> &#123;
    in.close();
&#125;</code></pre>
<h3 id="2-2-try-with-resources语句"><a href="#2-2-try-with-resources语句" class="headerlink" title="2.2 try-with-resources语句"></a>2.2 try-with-resources语句</h3><p>对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。关闭资源的常用方式就是在finally块里是释放，即调用close方法。就像我们在2.1节中的例子一样，但是从java7开始，我们可以使用一种更好的方法<code>try-with-resources</code>语句来实现。它的形式如下</p>
<pre><code class="hljs java"><span class="hljs-keyword">try</span> (Resources res = ...) &#123;
    <span class="hljs-comment">// blablabla</span>
&#125;</code></pre>
<p>我们来看一个具体的例子，读取一个文件中的所有单词。</p>
<pre><code class="hljs java"><span class="hljs-keyword">try</span> (Scanner in = <span class="hljs-keyword">new</span> Scanner(
    <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/usr/share/dict/words&quot;</span>), StandardCharsets.UTF_8)) &#123;
    <span class="hljs-keyword">while</span> (in.hasNext()) &#123;
        System.out.println(in.next());
    &#125;
&#125;</code></pre>
<h2 id="3-使用断言"><a href="#3-使用断言" class="headerlink" title="3. 使用断言"></a>3. 使用断言</h2><p>断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查。断言的关键字是<code>assert</code>。有以下两种形式</p>
<pre><code class="hljs java"><span class="hljs-keyword">assert</span> condition;
<span class="hljs-keyword">assert</span> condition : expression;</code></pre>
<p>这两种形式都会计算条件，如果结果为<code>false</code>，抛出<code>AssertionError</code>异常。<br>在第二个语句中，表达式将传入<code>AssertionError</code>对象的构造器，并转换成一个消息字符串。</p>
<p>默认情况下，断言是禁用的，需要在运行程序时用<code>-ea</code>启用断言。</p>
<p>参考：</p>
<ol>
<li>《Java核心技术 卷I》</li>
<li><a target="_blank" rel="noopener" href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/try-with-resources">Java工程师成神之路</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型程序设计</title>
    <url>/posts/98735cb0.html</url>
    <content><![CDATA[<h1 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h1><h2 id="1-为什么要使用泛型程序设计？"><a href="#1-为什么要使用泛型程序设计？" class="headerlink" title="1. 为什么要使用泛型程序设计？"></a>1. 为什么要使用泛型程序设计？</h2><p><strong>泛型程序设计</strong>(<em>generic programming</em>)意味着编写的代码可以对多种不同类型的对象重用。能够提高代码的复用性，比如<code>ArrayList</code>就可以收集任何类的对象，比如<code>String</code>，<code>Integer</code>等，而不用为这些对象去编写不同的类。</p>
<h3 id="1-1-类型参数"><a href="#1-1-类型参数" class="headerlink" title="1.1 类型参数"></a>1.1 类型参数</h3><p>泛型允许在定义类和接口的时候使用<strong>类型参数</strong>(<em>type parameter</em>)，声明的类型参数在使用时使用具体的类来替换，比如下面这个例子</p>
<pre><code class="hljs java">List&lt;String&gt; files = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</code></pre>
<p>可以很明显的看出数组中包含的是<code>String</code>对象，类型参数使得程序更易读，也更安全。</p>
<h2 id="2-定义简单泛型类"><a href="#2-定义简单泛型类" class="headerlink" title="2. 定义简单泛型类"></a>2. 定义简单泛型类</h2><p><strong>泛型类</strong>(<em>generic class</em>)就是有一个或多个类型变量的类。下面定义了一个简单的泛型类<code>Pair</code></p>
<p><code>Pair</code>类引入了一个类型变量<code>T</code>，用于指定方法的返回类型，字段和局部变量的类型</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>
<span class="hljs-class"></span>&#123;
   <span class="hljs-keyword">private</span> T first;
   <span class="hljs-keyword">private</span> T second;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">()</span> </span>&#123; first = <span class="hljs-keyword">null</span>; second = <span class="hljs-keyword">null</span>; &#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T second)</span> </span>&#123; <span class="hljs-keyword">this</span>.first = first;  <span class="hljs-keyword">this</span>.second = second; &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> first; &#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getSecond</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> second; &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(T newValue)</span> </span>&#123; first = newValue; &#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSecond</span><span class="hljs-params">(T newValue)</span> </span>&#123; second = newValue; &#125;
&#125;</code></pre>
<h2 id="3-泛型方法与类型变量的限定"><a href="#3-泛型方法与类型变量的限定" class="headerlink" title="3. 泛型方法与类型变量的限定"></a>3. 泛型方法与类型变量的限定</h2><p>我们再定义了泛型类之后，就可以设计带有类型参数的方法，比如我们想要寻找数组中元素的最大最小值，就可以这样定义</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(T[] a)</span> </span>&#123;
	<span class="hljs-comment">// blablabla</span>
&#125;</code></pre>
<p>但是这样的设计有一个问题，在方法内部对元素进行比较时，需要使用<code>compareTo</code>方法，这就要求类型<code>T</code>实现<code>Comparable</code>接口，所以需要对其进行<strong>限定</strong>(<em>bound</em>)</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&gt; <span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(T[] a)</span> </span>&#123;
  <span class="hljs-comment">// blablabla</span>
&#125;</code></pre>
<p>之所以使用<code>extends</code>而不是使用<code>implements</code>是因为<code>T</code>是限定类型的子类型，而继承关系更接近于这种概念，一个类型变量也可以有多个限定</p>
<pre><code class="hljs java">T extends Comparable &amp; Serializable</code></pre>
<p>下面使用我们定义的泛型类实现了一个寻找数组元素最大和最小值的方法。</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PairTest2</span></span>
<span class="hljs-class"></span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">   </span>&#123;
      LocalDate[] birthdays = 
         &#123; 
            LocalDate.of(<span class="hljs-number">1906</span>, <span class="hljs-number">12</span>, <span class="hljs-number">9</span>), <span class="hljs-comment">// G. Hopper</span>
            LocalDate.of(<span class="hljs-number">1815</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>), <span class="hljs-comment">// A. Lovelace</span>
            LocalDate.of(<span class="hljs-number">1903</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>), <span class="hljs-comment">// J. von Neumann</span>
            LocalDate.of(<span class="hljs-number">1910</span>, <span class="hljs-number">6</span>, <span class="hljs-number">22</span>), <span class="hljs-comment">// K. Zuse</span>
         &#125;;
      Pair&lt;LocalDate&gt; mm = ArrayAlg.minmax(birthdays);
      System.out.println(<span class="hljs-string">&quot;min = &quot;</span> + mm.getFirst());
      System.out.println(<span class="hljs-string">&quot;max = &quot;</span> + mm.getSecond());
   &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayAlg</span></span>
<span class="hljs-class"></span>&#123;
   <span class="hljs-comment">/**</span>
<span class="hljs-comment">      Gets the minimum and maximum of an array of objects of type T.</span>
<span class="hljs-comment">      <span class="hljs-doctag">@param</span> a an array of objects of type T</span>
<span class="hljs-comment">      <span class="hljs-doctag">@return</span> a pair with the min and max values, or null if a is null or empty</span>
<span class="hljs-comment">   */</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&gt; <span class="hljs-function">Pair&lt;T&gt; <span class="hljs-title">minmax</span><span class="hljs-params">(T[] a)</span> </span>
<span class="hljs-function">   </span>&#123;
      <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> || a.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
      T min = a[<span class="hljs-number">0</span>];
      T max = a[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++)
      &#123;
         <span class="hljs-keyword">if</span> (min.compareTo(a[i]) &gt; <span class="hljs-number">0</span>) min = a[i];
         <span class="hljs-keyword">if</span> (max.compareTo(a[i]) &lt; <span class="hljs-number">0</span>) max = a[i];
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;&gt;(min, max);
   &#125;
&#125;</code></pre>
<h2 id="4-泛型代码和虚拟机"><a href="#4-泛型代码和虚拟机" class="headerlink" title="4. 泛型代码和虚拟机"></a>4. 泛型代码和虚拟机</h2><p>虚拟机没有泛型类型对象，所有对象都属于普通类。</p>
<h3 id="4-1-类型擦除"><a href="#4-1-类型擦除" class="headerlink" title="4.1 类型擦除"></a>4.1 类型擦除</h3><p>无论何时定义一个泛型类型，都会自动提供一个相应的<strong>原始类型</strong>(<em>raw type</em>)，这个原始类型的名字就是去掉类型参数后的泛型类型名。同时，类型变量会被<strong>擦除</strong>(<em>erased</em>)，并替换为其限定类型。</p>
<blockquote>
<p>类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。 类型擦除的主要过程如下： 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换  2.移除所有的类型参数。</p>
</blockquote>
<p>比如3中的例子，原始类型就会变成下面的样子</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;
  <span class="hljs-keyword">private</span> Object first;
  <span class="hljs-keyword">private</span> Object second;
&#125;</code></pre>
<p>由于<code>T</code>是一个无限定的变量，所以直接用<code>Object</code>替换。</p>
<h3 id="4-2-转换泛型表达式"><a href="#4-2-转换泛型表达式" class="headerlink" title="4.2 转换泛型表达式"></a>4.2 转换泛型表达式</h3><p>调用一个泛型方法时，如果擦除了返回类型，编译器会插入强制类型转换</p>
<pre><code class="hljs java">Pair&lt;Employee&gt; buddies = ...;
Employee buddy = buddies.getFirst();</code></pre>
<p><code>getFirst</code>方法擦除类型后的返回类型是<code>Object</code>，编译器自动插入转换到<code>Employee</code>的强制类型转换。</p>
<h3 id="4-3-转换泛型方法"><a href="#4-3-转换泛型方法" class="headerlink" title="4.3 转换泛型方法"></a>4.3 转换泛型方法</h3><p>类型擦除还会出现在泛型方法中，比如</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&gt; <span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(T[] a)</span></span></code></pre>
<p>在擦除类型之后，就会变成</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparable <span class="hljs-title">min</span><span class="hljs-params">(T[] a)</span></span></code></pre>
<h2 id="5-限制与局限性"><a href="#5-限制与局限性" class="headerlink" title="5. 限制与局限性"></a>5. 限制与局限性</h2><h3 id="5-1-泛型遇到重载"><a href="#5-1-泛型遇到重载" class="headerlink" title="5.1 泛型遇到重载"></a>5.1 泛型遇到重载</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> </span>&#123;
    
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(List&lt;String&gt; list)</span></span>
<span class="hljs-function">&#125;</span></code></pre>
<p>上述代码编译器会报错，提示两个方法冲突，因为它们被擦除之后都变为<code>List</code></p>
<h3 id="5-2-泛型类中静态变量无效"><a href="#5-2-泛型类中静态变量无效" class="headerlink" title="5.2 泛型类中静态变量无效"></a>5.2 泛型类中静态变量无效</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T singleInstance;
  
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 
&#125;</code></pre>
<p>静态变量被泛型类的所有实例对象所共享。</p>
<h3 id="5-3-不能抛出或捕获泛型类的实例"><a href="#5-3-不能抛出或捕获泛型类的实例" class="headerlink" title="5.3 不能抛出或捕获泛型类的实例"></a>5.3 不能抛出或捕获泛型类的实例</h3><p>既不能抛出也不能捕获泛型类的对象，泛型类扩展<code>Throwable</code>不合法。</p>
<h2 id="6-泛型类的继承规则"><a href="#6-泛型类的继承规则" class="headerlink" title="6. 泛型类的继承规则"></a>6. 泛型类的继承规则</h2><p>考虑一个父类和子类，比如<code>Employee</code>和<code>Manager</code>，需要注意的是，<code>Pair&lt;Manager&gt;</code><strong>不是</strong><code>Pair&lt;Employee&gt;</code>的子类。</p>
<p>也就是说，无论<code>S</code>和<code>T</code>又怎样的关系，<code>Pair&lt;T&gt;</code>和<code>Pair&lt;S&gt;</code><strong>没有任何关系</strong>，这对于类型安全非常重要。</p>
<p>参考：</p>
<ol>
<li>《Java核心技术 卷I》</li>
<li><a target="_blank" rel="noopener" href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/generics">Java成神之路</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论的基本概念</title>
    <url>/posts/36736857.html</url>
    <content><![CDATA[<p>本文介绍了概率论的基本概念，包括概率的定义，概率的计算，同时还有随机测试的简单介绍。</p>
<p><strong>重点</strong></p>
<ul>
<li>概率的定义</li>
<li>条件概率</li>
<li>乘法公式</li>
<li>全概率公式</li>
<li>贝叶斯公式</li>
</ul>
<a id="more"></a>
<h2 id="一、概率的定义"><a href="#一、概率的定义" class="headerlink" title="一、概率的定义"></a>一、概率的定义</h2><p>当我们还不能用数学符号描述一件事情，那么说明我们还没有想清楚这件事。</p>
<p>所以，我们需要建立元素到数据的<strong>映射</strong></p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><h4 id="1-1-随机实验"><a href="#1-1-随机实验" class="headerlink" title="1.1 随机实验"></a>1.1 随机实验</h4><ul>
<li>可以在相同的条件下重复进行</li>
<li>每次实验结果不止一个，并且事先明确实验的所有可能结果</li>
<li>进行一次实验前不能够确定那一个结果会出现</li>
</ul>
<p>例：抛一枚硬币，观察正面H与反面T出现的情况</p>
<h4 id="1-2-样本空间"><a href="#1-2-样本空间" class="headerlink" title="1.2 样本空间"></a>1.2 样本空间</h4><p>随机试验$E$的所有可能结果组成的集合称为$E$的<strong>样本空间</strong>，记为$\Omega$</p>
<p>样本空间中的每个元素，即$E$的每个结果，称为<strong>样本点</strong>，记为$e$</p>
<h4 id="1-3-随机事件"><a href="#1-3-随机事件" class="headerlink" title="1.3 随机事件"></a>1.3 随机事件</h4><p>样本空间$\Omega$的任意子集$A$称为<strong>随机事件</strong></p>
<p>观察到样本点$e$，若$e\in A$，则称这一事件发生。</p>
<ul>
<li>基本事件：由一个样本点组成的单点集</li>
<li>复合事件：由两个或两个以上样本点组成的集合</li>
<li>必然事件：全集$\Omega$</li>
<li>不可能事件：空集$\emptyset$</li>
</ul>
<h3 id="2-事件的集合运算"><a href="#2-事件的集合运算" class="headerlink" title="2. 事件的集合运算"></a>2. 事件的集合运算</h3><ul>
<li>包含：$A\subset B$，事件B包含事件A，则事件A发生必然导致事件B发生</li>
<li>相等：$A=B$，即$A\subset B$且$B\subset A$</li>
<li>和：$A\bigcup B$，即A和B至少有一个发生</li>
<li>差：$A-B$，即事件A发生且事件B不发生</li>
<li>积：$A\bigcup B$，记作$AB$，即事件A和事件B都发生</li>
<li>互不相容：$AB = \emptyset$，即A和B不能同时发生</li>
<li>互逆：$A\bigcup B=\Omega$ 且$AB = \emptyset$，A和B互逆，通常B记为$\overline{A}$</li>
</ul>
<h4 id="2-1-复杂事件的集合运算"><a href="#2-1-复杂事件的集合运算" class="headerlink" title="2.1 复杂事件的集合运算"></a>2.1 复杂事件的集合运算</h4><ul>
<li>A发生而B和C都不发生：$A\overline{B} \overline{C}=A-B-C=A-(B\bigcup C)$</li>
<li>A与B都发生而C不发生：$AB\overline{C}=AB-C=AB-ABC$</li>
<li>三个事件都发生：$ABC$</li>
<li>三个事件恰好有一个发生：$A\overline{B}\overline{C}+\overline{A}B\overline{C}+\overline{A}\overline{B}C$</li>
<li>三个事件至少发生一个：$A\bigcup B\bigcup C$</li>
</ul>
<h4 id="2-2-常用定律"><a href="#2-2-常用定律" class="headerlink" title="2.2 常用定律"></a>2.2 常用定律</h4><ul>
<li>交换律</li>
<li>结合律</li>
<li>分配率：$A\, \bigcup \,(B\bigcap C)=(A\bigcup B)\bigcap (A\bigcup C)$    $A\, \bigcap \,(B\bigcup C)=(A\bigcap B)\,\bigcup \,(A\bigcap C)$</li>
<li>德摩根定律：$\overline{A\bigcup B}=\overline{A}\bigcap\overline{B}$    $\overline{A\bigcap B}=\overline{A}\bigcup\overline{B}$</li>
</ul>
<h3 id="3-频率"><a href="#3-频率" class="headerlink" title="3. 频率"></a>3. 频率</h3><p>描述了事件发生的频繁程度</p>
<p><strong>定义</strong></p>
<ul>
<li>重复观察n次事件A发生的次数$n_A$称为A的<em>频数</em></li>
<li>比值$\frac{n_A}{n}$称为事件A发生的<strong>频率</strong>，并记为$f_n(A)$</li>
</ul>
<p><strong>性质</strong></p>
<ol>
<li><p>$0\,\leq\, f_n(A)\, \leq\, 1$ </p>
</li>
<li><p>$f_n(\Omega)=1$</p>
</li>
<li><p>若$A_1,\cdots,A_k$两两互不相容，则</p>
<script type="math/tex; mode=display">f_n(A_1\,\bigcup\,\cdots\bigcup\,A_k)=f_n(A_1)+\cdots+f_n(A_k)</script></li>
</ol>
<p><strong>收敛性</strong></p>
<ul>
<li>当n足够大，$f_n(A)$收敛于某个常数，这个常数就是<strong>概率</strong>（证明见后续）</li>
</ul>
<p><strong>我们应该都听说过德摩根抛硬币的故事，对一个事件进行大量的实验可以得到频率，但是我们不可能对所有事件都做类似的事情，所以就有了概率</strong></p>
<h3 id="4-概率"><a href="#4-概率" class="headerlink" title="4. 概率"></a>4. 概率</h3><p>表征事件发生的可能性大小</p>
<p><strong>定义</strong></p>
<p>$\Omega$为样本空间，对于每一事件A赋予一实数$P(A)$，若P(A)满足下列条件则被称为概率：</p>
<ul>
<li>非负性：$0\leq P(A)\leq 1$</li>
<li>规范性：$P(\Omega)=1$</li>
<li>可列可加性：$A_1,\cdots,A_n$互不相容，则$P(A_1\,\bigcup\,\cdots\bigcup\,A_k)=P(A_1)+\cdots+P(A_k)$</li>
</ul>
<p><strong>性质</strong></p>
<ol>
<li>$P(\emptyset)=0$</li>
<li>$P(\overline{A})=1-P(A)$</li>
<li>若$A\subset B$，则有$P(A)\leq P(B),\quad P(B-A)=P(B)-P(A)$</li>
<li>对于任意两个事件A和B，$P(A\bigcup B)=P(A)+P(B)-P(A+B)$</li>
</ol>
<h4 id="4-1-古典概型-等可能概型"><a href="#4-1-古典概型-等可能概型" class="headerlink" title="4.1 古典概型(等可能概型)"></a>4.1 古典概型(等可能概型)</h4><p><strong>定义</strong></p>
<p>若$\Omega$是**有限样本空间，其样本点为$e_1,\cdots e_n$，在有限样本空间中引进概率。</p>
<p><strong>1/n</strong>称为事件${e_i}$的概率，记为$P({e_i})$</p>
<script type="math/tex; mode=display">P(\{e_1\})+\cdots +P(\{e_n\})=P(\Omega)=1</script><p>从定义中不难发现古典概型的两个特点：</p>
<ul>
<li>样本空间包含<strong>有限</strong>个元素</li>
<li>试验中每个基本事件发生的可能性相同</li>
</ul>
<p>注：<strong>基本事件是两两不相容的</strong></p>
<p>若事件A包含k个基本事件，则有</p>
<script type="math/tex; mode=display">P(A)=\sum_{i=1}^kP(\{e_{i_k}\})=\frac{k}{n}</script><h4 id="4-2-几何概型"><a href="#4-2-几何概型" class="headerlink" title="4.2 几何概型"></a>4.2 几何概型</h4><p>数据从有限集合推广到无限集合</p>
<p>例：约会问题</p>
<p>两人约定7点到8点在某地会面，先到者等候另一人20分钟，过时就离去，试求这两人会面的概率。</p>
<p>解：以$x,y$分别表示两人到达的时刻，则会面的充要条件为$|x-y|\leq20$，这就是一个几何概率的问题，可能的结果全体是边长60的正方形里面的点，结果为</p>
<script type="math/tex; mode=display">P(A)=\frac{60^2-40^2}{60^2}</script><p>从上面的例子不难看出，样本空间从原来的有限的个数，变成了无限的点。</p>
<p>如果要在半径为1的圆内随机地取一条弦，问弦长超过$\sqrt{3}$的概率是多少？</p>
<p>3种思路有3种不同的答案</p>
<p><strong>在数据映射中，我们需要遵循物理世界到数据集合的某种结构保持</strong></p>
<hr>
<h2 id="二、概率的计算"><a href="#二、概率的计算" class="headerlink" title="二、概率的计算"></a>二、概率的计算</h2><h3 id="1-条件概率"><a href="#1-条件概率" class="headerlink" title="1. 条件概率"></a>1. 条件概率</h3><p>事件A发生的条件下事件B发生的概率</p>
<h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>设A，B是两事件，且$P(A)&gt;0$，称</p>
<script type="math/tex; mode=display">P(B|A)=\frac{P(AB)}{P(A)}</script><p>为在事件A发生的条件下事件B发生的<strong>条件概率</strong></p>
<p>条件概率符合概率定义中的3个条件</p>
<p>非负性</p>
<p>规范性</p>
<p>可列可加性：$B_1,\cdots,B_n$两两互不相容</p>
<script type="math/tex; mode=display">P(\bigcup_{i=1}^\infty B_i\,\mid\,A)=\sum_{i=1}^\infty P(B_i\mid A)</script><p>同时也可以使用概率的性质</p>
<script type="math/tex; mode=display">P(B_1\bigcup B_2)=P(B_1\mid A)+P(B_2\mid A)-P(B_1B_2\mid A)</script><p>注意这里是对任意事件$B_1,B_2$，两者不一定互不相容，如果互不相容，那么$P(B_1B_2)=\emptyset$，与可列可加性不矛盾。</p>
<h4 id="1-2-乘法公式"><a href="#1-2-乘法公式" class="headerlink" title="1.2 乘法公式"></a>1.2 乘法公式</h4><script type="math/tex; mode=display">P(AB)=P(A)P(B|A)</script><p>推广：一般地，我们有：</p>
<script type="math/tex; mode=display">P(A_1A_2\cdots A_n)=P(A_1)P(A_2\mid A_1)\cdots P(A_n\mid A_1A_2\cdots A_{n-1})</script><p>大多数应用中，我们会直接获取条件概率，通过它进行计算</p>
<h4 id="1-3-完备事件组"><a href="#1-3-完备事件组" class="headerlink" title="1.3  完备事件组"></a>1.3  完备事件组</h4><p>设$B_1,\cdots,B_n$是样本空间$\Omega$的一个事件组，若满足</p>
<ul>
<li>$B_i\bigcap B_j=\emptyset$ ，对于任意$i\neq j$</li>
<li>$\bigcup_iB_i=\Omega$</li>
</ul>
<p>则$B_1,\cdots,B_n$称为一个完备事件组</p>
<h4 id="1-4-全概率公式"><a href="#1-4-全概率公式" class="headerlink" title="1.4 全概率公式"></a>1.4 全概率公式</h4><p>设$B_1,\cdots,B_n$是样本空间$\Omega$的一个完备事件组，且$P(B_i)&gt;0(i=1,2,\cdots,n)$，则对于任一随机事件A，有</p>
<script type="math/tex; mode=display">P(A)=\sum_{i=1}^nP(B_i)P(A\mid B_i)</script><p>当$P(A)$不易求得时，利用此公式</p>
<h4 id="1-5-贝叶斯公式"><a href="#1-5-贝叶斯公式" class="headerlink" title="1.5 贝叶斯公式"></a>1.5 贝叶斯公式</h4><p>设实验E的样本空间为$\Omega$，$A$为$\Omega$的事件，$B_1,\cdots,B_n$为$S$的一个划分，且$P(A)&gt;0,P(B_i)&gt;0$，则</p>
<script type="math/tex; mode=display">P(B_i\mid A)=\frac{P(A\mid B_i)P(B_i)}{\sum_{j=1}^nP(A\mid B_j)P(B_j)},i=1,2,\cdots,n</script><p>如：设$A,B$为两事件，$P(B)&gt;0$，则</p>
<script type="math/tex; mode=display">P(A\mid B)=\frac{P(B\mid A)\times P(A)}{P(B)}</script><p>贝叶斯定理往往与全概率公式同时使用。全概率公式用于”由因求果“的问题，而贝叶斯定理用于”执果寻因“问题。</p>
<p><strong>常用</strong>：令$n=2$，那么全概率公式和贝叶斯公式分别为：</p>
<script type="math/tex; mode=display">P(A)=P(A\mid B)P(B)+P(A\mid \overline{B})P(\overline{B})</script><script type="math/tex; mode=display">P(B\mid A)=\frac{P(AB)}{P(A)}=\frac{P(A\mid B)P(B)}{P(A\mid B)P(B)+P(A\mid \overline{B})P(\overline{B})}</script><h4 id="1-6-独立性"><a href="#1-6-独立性" class="headerlink" title="1.6 独立性"></a>1.6 独立性</h4><p><strong>定义</strong>：设$A,B$是两事件，如果满足等式</p>
<script type="math/tex; mode=display">P(AB)=P(A)P(B)</script><p>则称事件$A$和事件$B$相互独立</p>
<p><strong>定理</strong>：设$A,B$是两事件，且$P(A)&gt;0$，若$A,B$相互独立，则$P(B\mid A)=P(B)$，反之亦然</p>
<p><strong>定理</strong>：若事件$A,B$相互独立，则下列各对事件也相互独立，$A\&amp;\overline{B},B\&amp;\overline{A},\overline{A}\&amp;\overline{B}$</p>
<p><strong>定义</strong>：设$A,B,C$是三个事件，如果满足等式</p>
<script type="math/tex; mode=display">P(AB)=P(A)P(B),\\ P(BC)=P(B)P(C)\\P(AC)=P(A)P(C)\\P(ABC)=P(A)P(B)P(C)</script><p>则称事件$A,B,C$相互独立</p>
<hr>
<h2 id="三、随机测试示例"><a href="#三、随机测试示例" class="headerlink" title="三、随机测试示例"></a>三、随机测试示例</h2><p>实际应用中使用概率论</p>
<h3 id="1-随机测试初步"><a href="#1-随机测试初步" class="headerlink" title="1.  随机测试初步"></a>1.  随机测试初步</h3><p>假设有一个计算多项式乘法的程序。</p>
<p>程序可能采用左右两边的某一方式实现：</p>
<script type="math/tex; mode=display">(x+1)(x-2)(x+3)(x-4)(x+5)(x-6)=x^6-7x^3+25</script><p>思考：</p>
<ul>
<li>如何验证左右两边的多项式相等</li>
<li>假设有一个超大规模的多项式呢？</li>
</ul>
<script type="math/tex; mode=display">F(X)?\equiv G(x)</script><h4 id="1-1-规范化"><a href="#1-1-规范化" class="headerlink" title="1.1 规范化"></a>1.1 规范化</h4><p>两个多项式相等当且仅当他们的规范式中所有的对应系数相等，</p>
<p>那么把$F(x)$变换为规范式，有$O(d^2)$的复杂度</p>
<h4 id="1-2-随机测试-初步"><a href="#1-2-随机测试-初步" class="headerlink" title="1.2 随机测试-初步"></a>1.2 随机测试-初步</h4><p>设$F(X),G(x)$的最高阶为的$d$，随机算法首先是从${1,\cdots,100d}$中均匀随机（等可能）地选择一个整数$r$，然后计算两个式子的值，进行判断。有$O(d)$的复杂度，大大提高了速度。</p>
<p>当然，这种算法可能会给出<strong>错误</strong>的答案。</p>
<p>$F(x)\neq G(x), F(r)=G(r)$，算法检测结果错误</p>
<p>错误的概率是多少？可以接受吗？</p>
<p>当$r$是方程$F(x)-G(x)=0$的根时，必然会出现错误结果。</p>
<p>$F(x)-G(x)$的次数不高于$d$，由代数的基本定理可知，$F(x)-G(x)=0$不可能多于$d$个根。</p>
<p>那么在${1,\cdots,100d}$中，给出错误答案的概率不会高于$\frac{1}{100}$</p>
<h3 id="2-随机测试改进"><a href="#2-随机测试改进" class="headerlink" title="2. 随机测试改进"></a>2. 随机测试改进</h3><p>如何改进算法正确率？</p>
<p>很容易想到两个方向，扩大检测范围，重复多次检测</p>
<h4 id="2-1-扩大范围"><a href="#2-1-扩大范围" class="headerlink" title="2.1 扩大范围"></a>2.1 扩大范围</h4><p>在更大的范围进行取值，比如在${1,\cdots,1000d}$中进行检测，那么错误答案概率不会超过$\frac{1}{1000}$</p>
<h4 id="2-2-重复检测"><a href="#2-2-重复检测" class="headerlink" title="2.2 重复检测"></a>2.2 重复检测</h4><p>重复多次进行随机检测</p>
<ul>
<li><p>有放回抽样</p>
<p>$k$次有放回抽样错误率为</p>
<script type="math/tex; mode=display">P(E_1\,\bigcap\cdots\bigcap\,E_k)=\prod_{i=1}^kP(E_i)\leq(\frac{1}{100})^k</script><p>可以看到，错误率指数级降低</p>
</li>
<li><p>无放回抽样</p>
</li>
</ul>
<p>总结：</p>
<p>无放回比有放回准确率高</p>
<p>有放回实现比无放回简单</p>
<p>当$d+1$次无放回抽样后，能够确保准确性，但是算法复杂度提升到$O(d^2)$</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="1-概率的定义"><a href="#1-概率的定义" class="headerlink" title="1. 概率的定义"></a>1. 概率的定义</h3><p>$\Omega$为样本空间，对于每一事件A赋予一实数$P(A)$，若P(A)满足下列条件则被称为概率：</p>
<ul>
<li>非负性：$0\leq P(A)\leq 1$</li>
<li>规范性：$P(\Omega)=1$</li>
<li>可列可加性：$A_1,\cdots,A_n$互不相容，则$P(A_1\,\bigcup\,\cdots\bigcup\,A_k)=P(A_1)+\cdots+P(A_k)$</li>
</ul>
<h3 id="2-条件概率"><a href="#2-条件概率" class="headerlink" title="2. 条件概率"></a>2. 条件概率</h3><script type="math/tex; mode=display">P(B|A)=\frac{P(AB)}{P(A)}</script><h3 id="3-乘法公式"><a href="#3-乘法公式" class="headerlink" title="3. 乘法公式"></a>3. 乘法公式</h3><script type="math/tex; mode=display">P(A_1A_2\cdots A_n)=P(A_1)P(A_2\mid A_1)\cdots P(A_n\mid A_1A_2\cdots A_{n-1})</script><h3 id="4-全概率公式"><a href="#4-全概率公式" class="headerlink" title="4. 全概率公式"></a>4. 全概率公式</h3><script type="math/tex; mode=display">P(A)=P(A\mid B_1)P(B_1)+\cdots+P(A\mid B_n)P(B_n)</script><h3 id="5-贝叶斯公式"><a href="#5-贝叶斯公式" class="headerlink" title="5. 贝叶斯公式"></a>5. 贝叶斯公式</h3><script type="math/tex; mode=display">P(A\mid B)=\frac{P(B\mid A)P(A)}{P(B)}</script><p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.icourse163.org/learn/NJU-1450307351?tid=1450738603#/learn/announce">中国大学MOOC-南京大学-数据科学基础</a></li>
<li>《概率论与数理统计》浙江大学第四版</li>
</ol>
]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>概述与递归简论</title>
    <url>/posts/ddb07891.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="1-什么是数据结构？"><a href="#1-什么是数据结构？" class="headerlink" title="1. 什么是数据结构？"></a>1. 什么是数据结构？</h2><p>我们把这个词分解开来，首先回答什么是数据。<br><strong>数据</strong>是信息的载体，是数字，字符或其它符号的集合。<br><strong>数据结构</strong>是数据对象和组成对象的数据成员之间的关系。</p>
<p><code>Data_Structure = &#123;D, R&#125;</code><br><em>D</em>是数据对象<br><em>R</em>是<em>D</em>中所有数据成员的关系</p>
<p>数据结构涉及3个方面：<br><strong>逻辑结构</strong>：从用户视图看，是面向问题的<br><strong>物理结构</strong>：从具体实现视图看，是面向计算机的<br><strong>操作及其实现</strong><br>我们以一个学生表为例，它的逻辑结构式线性表，物理结构是数组，而操作是增删改查</p>
<h2 id="2-递归简论"><a href="#2-递归简论" class="headerlink" title="2. 递归简论"></a>2. 递归简论</h2><h3 id="2-1-如何设计递归"><a href="#2-1-如何设计递归" class="headerlink" title="2.1 如何设计递归"></a>2.1 如何设计递归</h3><p>我们通过递归来引入数据结构与算法的学习。<br>当一个函数用它自己来定义时，我们就称它是<strong>递归</strong>(<em>recursive</em>)的。我们可以看下面这个简单的例子</p>
<script type="math/tex; mode=display">f(x) = \begin{cases} 0, & x=0 \\\\ 2f(x-1)+x^2, & x > 0\end{cases}</script><p>我们用代码来实现它</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * f(x - <span class="hljs-number">1</span>) + x * x;
&#125;</code></pre>
<p>观察这段代码，函数体内首先有一个<code>if</code>结构，这是递归的<strong>基准情况</strong>(<em>base case</em>)，即此时函数的值可以直接算出而不用进行递归。<br>再往下的<code>return</code>语句则进入了递归，要注意的是，递归调用将反复进行直到出现基准情况为止。比如我们计算<code>f(3)</code>，那么会调用<code>f(2), f(1)</code>直到出现基准情况<code>f(0)</code>，它的计算实际上是这样的</p>
<script type="math/tex; mode=display">(2\times(2\times(2\times f(0)+1\times1) + 2\times2)+3\times3)</script><p>下面我们再来看一种糟糕的递归设计</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bad</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    
    &#125;
    <span class="hljs-keyword">return</span> bad(n / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>) + n - <span class="hljs-number">1</span>;
&#125;</code></pre>
<p>我们会发现，在上述的代码中，<code>bad(1)</code>被定义为<code>bad(1)</code>，而不知道具体是多少，计算机会反复调用它，程序无法停止，也求不出解。</p>
<p>通过上面的两个例子，可以得出递归的设计准则</p>
<ol>
<li><strong>基准情形</strong>(<em>base case</em>)。必须有某些基准的情形，不用递归就能够求解。</li>
<li><strong>不断推进</strong>(<em>make progress</em>) 递归调用必须能够朝着一个基准情形推进。</li>
</ol>
<h3 id="2-2-递归实践"><a href="#2-2-递归实践" class="headerlink" title="2.2 递归实践"></a>2.2 递归实践</h3><p>我们通过几个经典的例子来加深对递归的理解。</p>
<h4 id="2-2-1-菲波那切数列"><a href="#2-2-1-菲波那切数列" class="headerlink" title="2.2.1 菲波那切数列"></a>2.2.1 菲波那切数列</h4><p>我们知道它的函数是<br>$fib(0)=0,\ fib(1)=1,\ fib(n)=fib(n-1)+fib(n-2); n&gt;=2$<br>可以很容易地将其用代码表示</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// base case</span>
        <span class="hljs-keyword">return</span> n;
    &#125;
    <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);
&#125;</code></pre>
<h4 id="2-2-2-排列"><a href="#2-2-2-排列" class="headerlink" title="2.2.2 排列"></a>2.2.2 排列</h4><p>现在有一个数组<code>&#123;a, b, c&#125;</code>，要求对它进行全排列，即排列结果是<code>abc,acb,bac,bca,cab,cba</code></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Permutation</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">permutation</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] list, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> m)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i;
        <span class="hljs-keyword">if</span> (k == m) &#123;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;
                System.out.print(list[i]);
            &#125;
            System.out.println();
        &#125;
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">for</span> (i = k; i &lt;= m; i++) &#123;
                <span class="hljs-keyword">char</span> temp = list[k];
                list[k] = list[i];
                list[i] = temp;
                permutation(list, k + <span class="hljs-number">1</span>, m);
                temp = list[k];
                list[k] = list[i];
                list[i] = temp;
            &#125;
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">char</span>[] list = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;
        permutation(list, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);
    &#125;
&#125;</code></pre>
<h4 id="2-2-3-汉诺塔问题"><a href="#2-2-3-汉诺塔问题" class="headerlink" title="2.2.3 汉诺塔问题"></a>2.2.3 汉诺塔问题</h4><p>汉诺塔问题是一个经典的问题。<strong>汉诺塔</strong>(<em>Hanoi Tower</em>)，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？<br>64个圆盘对于当前的计算机，可能需要几百上千年才能算出，但是我们可以简化这个问题，使用3个圆盘来看一下如何用递归来实现。</p>
<p>根据我们的递归设计准则，首先要明确基准条件，也就是只有一个圆盘，那很简单，就是把它从第一根柱子移动到第三根柱子，<br>然后设计不断推进的过程，有3根柱子，起点(<em>fromTower</em>)，终点(<em>toTower</em>)，中转(<em>auxTower</em>)。有一个非常易于理解的方式，我们首先将盘从起点移到中转点，这个时候的中转点实际上是终点，再从中转点移到终点，这个时候的中转点实际上是起点，所以设计的两个递归是这样的。</p>
<pre><code class="hljs java">moveDisks(n - <span class="hljs-number">1</span>, fromTower, auxTower, toTower);
moveDisks(n - <span class="hljs-number">1</span>, auxTower, toTower, fromTower);</code></pre>
<p>下面是完整的代码实现。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HanoiTower</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveDisks</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> fromTower, <span class="hljs-keyword">char</span> toTower, <span class="hljs-keyword">char</span> auxTower)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;
            System.out.println(<span class="hljs-string">&quot;move disk &quot;</span> + n + <span class="hljs-string">&quot; from &quot;</span> + fromTower + <span class="hljs-string">&quot; to &quot;</span> + toTower);
        &#125;
        <span class="hljs-keyword">else</span> &#123;
            moveDisks(n - <span class="hljs-number">1</span>, fromTower, auxTower, toTower);
            System.out.println(<span class="hljs-string">&quot;move disk &quot;</span> + n + <span class="hljs-string">&quot; from &quot;</span> + fromTower + <span class="hljs-string">&quot; to &quot;</span> + toTower);
            moveDisks(n - <span class="hljs-number">1</span>, auxTower, toTower, fromTower);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        moveDisks(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>);
    &#125;
&#125;</code></pre>
<p>打印结果</p>
<pre><code class="hljs shell">move disk 1 from A to C
move disk 2 from A to B
move disk 1 from C to B
move disk 3 from A to C
move disk 1 from B to A
move disk 2 from B to C
move disk 1 from A to C</code></pre>
<p>参考：</p>
<ol>
<li>《数据结构与算法 Java语言描述》</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/posts/6b3bea20.html</url>
    <content><![CDATA[<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>当我们需要实例化一些具体的类时，可能会写出如下的代码</p>
<pre><code class="hljs java"><span class="hljs-keyword">if</span> (cash) &#123;
  <span class="hljs-comment">// 现金支付处理</span>
&#125;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (creditcard) &#123;
  <span class="hljs-comment">// 信用卡支付</span>
&#125;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (alipay) &#123;
  <span class="hljs-comment">// 支付宝支付</span>
&#125;</code></pre>
<p>一旦需要进行变化或扩展，比如增加微信支付或者修改已有支付的逻辑，就需要修改原有的代码，更容易产生错误，也增加了维护的难度。我们的代码应该<strong>对扩展开放，对修改关闭</strong>（开闭原则）。所以，我们应该考虑在使用这些具体的类时，只需要知道一个参数，并提供一个调用方便的方法，将该参数传入方法返回一个相应的对象。我们可以使用<strong>简单工厂模式</strong>。</p>
<p>本质上，就是找出会变化的方面，把它们从不变的部分分离出来。</p>
<h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>又称为静态工厂方法。属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例，简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<h2 id="1-2-模式结构"><a href="#1-2-模式结构" class="headerlink" title="1.2 模式结构"></a>1.2 模式结构</h2><p><strong>Factory</strong>：工厂角色</p>
<p><strong>Product</strong>：抽象产品角色</p>
<p><strong>ConcreteProduct</strong>：具体产品角色</p>
<h2 id="1-3-代码实例"><a href="#1-3-代码实例" class="headerlink" title="1.3 代码实例"></a>1.3 代码实例</h2><p>我们将开头的支付逻辑代码使用简单工厂模式进行修改。</p>
<pre><code class="hljs java"><span class="hljs-comment">// 抽象支付类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractPay</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">// 具体支付类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CashPay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractPay</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 现金支付处理</span>
  &#125;
&#125;

<span class="hljs-comment">// 支付工厂</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayMethodFactory</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> class Abstarct <span class="hljs-title">getPayMethod</span><span class="hljs-params">(String type)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (cash) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CashPay(); <span class="hljs-comment">// 根据参数创建具体产品</span>
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (creditcard) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Creditcard();
    &#125;
    ......
  &#125;
&#125;</code></pre>
<h2 id="1-4-模式分析"><a href="#1-4-模式分析" class="headerlink" title="1.4 模式分析"></a>1.4 模式分析</h2><h3 id="1-4-1-优缺点"><a href="#1-4-1-优缺点" class="headerlink" title="1.4.1 优缺点"></a>1.4.1 优缺点</h3><div class="table-container">
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>将对象的<strong>创建</strong>和对象本身的<strong>业务处理</strong>分离可以降低系统的耦合度（责任的分割）</td>
<td>工厂职责过重，集中了所有创建逻辑，出问题会影响整个系统</td>
</tr>
<tr>
<td>客户端无需知道所创建的产品类的类名，只需要知道其所对应的参数</td>
<td>更多的类，增加了系统的复杂度，（降低耦合的代价，难以两全其美）</td>
</tr>
<tr>
<td>使用静态方法，可以通过引入配置文件，在不修改代码的情况下增加新的具体产品类，提高了灵活性</td>
<td>系统扩展困难，一旦添加新产品就要更改工厂逻辑，使得逻辑越来越复杂，<br/>由于使用静态方法，不能通过继承来改变创建方法的行为。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-4-2-适用环境"><a href="#1-4-2-适用环境" class="headerlink" title="1.4.2 适用环境"></a>1.4.2 适用环境</h3><ol>
<li>工厂类负责创建的对象比较少，工厂逻辑不复杂</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心</li>
</ol>
<h3 id="1-4-3-不足"><a href="#1-4-3-不足" class="headerlink" title="1.4.3 不足"></a>1.4.3 不足</h3><p>前面提到的开闭原则，我们的代码应该<strong>对扩展开放，对修改关闭</strong>，但是如果要添加新的产品到系统中，必须修改工厂类，加入必要的处理逻辑，这其实还是违背了“开闭原则”。而且工厂类的职责重，业务逻辑复杂，影响了系统的灵活性和扩展性。要想解决这个问题，就需要使用工厂模式。</p>
<h2 id="1-5-模式应用"><a href="#1-5-模式应用" class="headerlink" title="1.5 模式应用"></a>1.5 模式应用</h2><p>在实际的项目中的使用</p>
<p>待补充</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/posts/72e3b671.html</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote>
<p>问题：<br>假设有一个模拟鸭子的游戏，游戏中拥有各种鸭子，我们设计了一个鸭子的超类，并且让各种鸭子，比如红头鸭，橡皮鸭等，继承它。<br>现在，我们需要更新这个游戏，使得鸭子可以飞起来，该怎么做？</p>
</blockquote>
<h2 id="使用继承？"><a href="#使用继承？" class="headerlink" title="使用继承？"></a>使用继承？</h2><p>如果依然使用继承，在超类中添加一个fly()方法，会出现不适合该行为的子类也具有该行为的问题，比如橡皮鸭就不会飞，但继承的做法使得它也可以飞起来。<br><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200902-01.png" alt=""></p>
<p>如果选择覆盖<code>fly()</code>方法，那么在后续的更新中，我们需要不断地检查可能需要覆盖的<code>fly()</code>方法。<br>所以使用继承来提供行为，会造成代码在多个子类最终重复，复用性差，难以知道鸭子的全部行为，运行时的行为不容易改变等问题。</p>
<h2 id="使用接口？"><a href="#使用接口？" class="headerlink" title="使用接口？"></a>使用接口？</h2><p>如果抽象出一个<code>Flyable</code>接口，只有会飞的鸭子才实现这个接口呢？<br>设想一下，如果我们有上百种会飞的鸭子，那么就会造成大量的代码重复，每个子类中都要实现一次<code>fly()</code>方法，而且代码无法复用，如果我们需要修改这个方法，想象一下，这简直就是一场灾难。</p>
<h2 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h2><p>软件开发过程中总是伴随着变更。<br><strong>设计原则</strong></p>
<blockquote>
<p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码放在一起。<br>也就是说我们把会变化的部分取出并封装起来，以便以后的改动和扩充。</p>
</blockquote>
<h3 id="分离变化与不变的部分"><a href="#分离变化与不变的部分" class="headerlink" title="分离变化与不变的部分"></a>分离变化与不变的部分</h3><p>在鸭子类中，我们可以发现<code>fly()</code>和<code>quack()</code>两个方法经常需要修改，那么我们就可以建立两组远离<code>Duck</code>类的类，一个与<code>fly</code>相关，一个与<code>quack</code>相关，每一组类实现各自的动作，比如让一个类实现“呱呱叫”，一个类实现“吱吱叫”，还有一个类实现“安静”</p>
<h3 id="设计行为"><a href="#设计行为" class="headerlink" title="设计行为"></a>设计行为</h3><p><strong>设计原则</strong></p>
<blockquote>
<p>针对接口编程，而不是针对实现编程<br>用接口代表每个行为，鸭子类不会实现<code>Flying</code>的接口，而是制造一组专门的类来实现<code>FlyBahavior</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>
<h3 id="实现行为"><a href="#实现行为" class="headerlink" title="实现行为"></a>实现行为</h3><p>现在有一个<code>FlyBehavior</code>接口，还有对应的类，负责实现具体的行为。</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200902-02.png" alt=""></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyWithWings</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;I&#x27;m flying.&quot;</span>);
    &#125;
&#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyNoWay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;I can&#x27;t fly&quot;</span>);
    &#125;
&#125;</code></pre>
<h3 id="整合行为"><a href="#整合行为" class="headerlink" title="整合行为"></a>整合行为</h3><p>鸭子将飞行的动作<strong>委托</strong>给别人处理，而不是在鸭子类内部定义飞行方法。<br>在鸭子类中加入实例变量<code>flyBahavior</code>，声明为接口类型。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span>&#123;
    FlyBehavior flyBehavior;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performFly</span><span class="hljs-params">()</span> </span>&#123;
        flyBehavior.fly();
    &#125;
&#125;</code></pre>
<p>每个鸭子对象都会动态的设置这些变量以在运行时引用正确的类型。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MallardDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MallardDuck</span><span class="hljs-params">()</span> </span>&#123;
        flyBehavior = <span class="hljs-keyword">new</span> FlyWithWings(); <span class="hljs-comment">// 使用FlyWithWings作为FlyBehavior类型</span>
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;I&#x27;m a real Mallard duck.&quot;</span>);
    &#125;
&#125;</code></pre>
<p>测试</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiniDuckSimulator</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Duck mallard = <span class="hljs-keyword">new</span> MallardDuck();
        mallard.performFly();
    &#125;
&#125;
<span class="hljs-comment">// Output: I&#x27;m flying.</span></code></pre>
<h3 id="动态设定行为"><a href="#动态设定行为" class="headerlink" title="动态设定行为"></a>动态设定行为</h3><p>如果想要在运行时改变鸭子的行为，只需要调用鸭子的<code>setter</code>方法就可以了。<br>我们在鸭子类中增加设定方法</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlyBehavior</span><span class="hljs-params">(FlyBehavior fb)</span> </span>&#123;
        flyBehavior = fb;
&#125;</code></pre>
<p>创造一个新的类模型鸭</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ModelDuck</span><span class="hljs-params">()</span> </span>&#123;
        flyBehavior = <span class="hljs-keyword">new</span> FlyNoWay();
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;I&#x27;m a model duck.&quot;</span>);
    &#125;
&#125;</code></pre>
<p>建立一个新的<code>FlyBehavior</code>类型</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyRocketPowered</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;I&#x27;m flying with a rocket.&quot;</span>);
    &#125;
&#125;</code></pre>
<p>测试<br>调用<code>setter</code>方法，改变了模型鸭的飞行行为</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiniDuckSimulator</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Duck model = <span class="hljs-keyword">new</span> ModelDuck();
        model.performFly();;
        model.setFlyBehavior(<span class="hljs-keyword">new</span> FlyRocketPowered());
        model.performFly();
    &#125;
&#125;
<span class="hljs-comment">/* Output:</span>
<span class="hljs-comment">I can&#x27;t fly;</span>
<span class="hljs-comment">I&#x27;m flying with a rocket.</span>
<span class="hljs-comment">*/</span></code></pre>
<p>每一个鸭子都<strong>有一个(HAS-A)</strong><code>FlyBahavior</code>，将飞行委托给它处理。<br><strong>设计原则</strong></p>
<blockquote>
<p>多用组合，少用继承<br>使用组合建立系统具有很大的弹性，可以将算法族封装成类，还可以在运行时动态地改变行为。</p>
</blockquote>
<h2 id="策略模式小结"><a href="#策略模式小结" class="headerlink" title="策略模式小结"></a>策略模式小结</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一系列算法，把它们一个个<strong>封装</strong>起来，并且使它们可以相互替换。使得算法可以<strong>独立</strong>于它的客户变化。</p>
<h3 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h3><ol>
<li>许多相关的类仅仅只是行为有差别，比如鸭子类中的飞行</li>
<li>需要使用一个算法的不同变体</li>
<li>算法使用客户不应该知道的数据</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现（switch或if）</li>
</ol>
<h3 id="结构与参与者"><a href="#结构与参与者" class="headerlink" title="结构与参与者"></a>结构与参与者</h3><p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200902-04.png" alt=""></p>
<p><strong>Strategy</strong> (策略)<br>定义所有支持的算法的公共接口，Context使用这个接口来调用ConcreteStrategy定义的算法，比如<code>FlyBehavior</code>就是一个策略<br><strong>ConcreteStrategy</strong>(具体策略)<br>以Strategy接口实现某具体的算法，比如<code>FlyWithWings</code>,<code>FlyNoWay</code>等<br><strong>Context</strong> (上下文)</p>
<ul>
<li>用一个ConcreteStrategy对象来配置</li>
<li>维护一个对Strategy对象的引用</li>
<li>可定义一个接口让Strategy来访问它的数据<br>比如<code>Duck</code>类</li>
</ul>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>相关算法系列</strong> Strategy类层次为Context定义了一系列可供复用的算法或行为</li>
<li><strong>替代继承的方法</strong> 使用继承可以直接生成一个Context的子类，给它不同的行为，但这样会使得Context难以理解，维护和扩展，不能动态改变算法。而将算法封装在独立的Strategy类中使得我们可以独立于Context改变它，易于理解，修改和扩展。</li>
<li><strong>消除可一些条件语句</strong> 含有许多条件语句的代码通常需要使用策略模式</li>
<li><strong>实现的选择</strong> 策略模式可以提供相同行为的不同实现供客户选择</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>客户必须了解不同的策略</strong> 需要向客户暴露具体问题，所以只有当不同行为的变体与客户有关时，才使用策略模式</li>
<li><strong>Strategy和Context之间的通信开销</strong></li>
<li>增加了对象的数目</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>商业模式画布</title>
    <url>/posts/184fbc6f.html</url>
    <content><![CDATA[<h1 id="商业模式画布"><a href="#商业模式画布" class="headerlink" title="商业模式画布"></a>商业模式画布</h1><p>一种用来描述商业模式，可视化商业模式，评估商业模式以及改变商业模式的通用语言。</p>
<p><strong>商业模式</strong></p>
<p>描述了企业如何创造价值，传递价值和获取价值的基本原理</p>
<p>使用9个基本构造块描述并定义商业模式</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200917-01.png" alt=""></p>
<h2 id="1-客户细分-（Customer-Segments）"><a href="#1-客户细分-（Customer-Segments）" class="headerlink" title="1. 客户细分 （Customer Segments）"></a>1. 客户细分 （Customer Segments）</h2><p><strong>客户细分构造块用来描述一个企业想要接触和服务的不同人群或组织</strong></p>
<p>细分的条件：</p>
<ul>
<li><p>需求催生新供给 （4G网络使得人们分享生活的方式从图片到视频，抖音快手的出现）</p>
</li>
<li><p>需要新分销渠道和客户关系类型（新零售）</p>
</li>
<li><p>产生的利润率不同 （薄利多销还是三年不开张，开张吃三年）</p>
</li>
<li><p>愿意为某方面的特殊需求买单</p>
</li>
</ul>
<p>客户构成了任何商业模式的<strong>核心</strong>。没有（可获益的）客户，任何企业都无法长久存活。</p>
<p>需要谨慎的处理客户的细分与取舍，比如王者荣耀与Dota2，Dota2从魔兽，Dota而来，非常硬核，有一批持续的老玩家，但是王者荣耀的操作十分简单，能够吸引新人进入。<strong>明确服务于哪部分客户</strong></p>
<p>企业把客户分成不同的细分段，每个段中的客户拥有共同的需求。</p>
<p>商业模式可以定义客户细分群体。这里给出几个客户细分群体的例子：</p>
<ul>
<li><strong>大众市场</strong>(<em>Mass Market</em>) 聚焦大范围客户群体，常见于消费电子行业（<strong>找人群共性</strong>）</li>
<li><strong>小众市场</strong>(<em>Niche Market</em>) 常见与供应商-采购商的关系（<strong>强业务特征</strong>）</li>
<li><strong>区隔化市场</strong>(<em>Segmented</em>) 在略有不同的客户需求和困扰的市场细分群体间有所区别。比如瑞士精密微型系统公司，提供的微型机械设计和生产解决方案服务与3个不同的客户细分群体——钟表，医疗，工业自动化行业。（<strong>某业务下基于客户共性的细分</strong>）</li>
<li><strong>多元化市场</strong>(<em>Diversified</em>) 服务两个具有不同需求和困扰的客户细分群体。比如亚马逊的云计算服务，阿里，华为等（<strong>垄断地位、技术领先与外拓、团队能力与开拓意识强</strong>）</li>
<li><strong>多边平台或多边市场</strong>(<em>Multi-sided platforms/Multi-sided markets</em>) 大型互联网平台 例如b站（<strong>大流量，上升为生活方式的使用习惯，多种收益流的平衡与补贴</strong>）</li>
</ul>
<h2 id="2-价值主张-Value-Propositions"><a href="#2-价值主张-Value-Propositions" class="headerlink" title="2. 价值主张 (Value Propositions)"></a>2. 价值主张 (Value Propositions)</h2><p><strong>价值主张构造块用来描绘为特定客户细分创造价值的产品和服务</strong></p>
<p>它解决了客户困扰或满足了客户需求。使得客户能够有<strong>偏爱</strong>从而选择一家而放弃一家（但是在现实中往往会有两个共存的情况，比如美团和饿了么）</p>
<p>可以思考如下一些问题的答案：</p>
<ul>
<li>我们该向客户传递一种什么样的价值？</li>
<li>我们能帮助客户解决一个什么样的难题？</li>
<li>我们正在满足客户的那些需求？</li>
<li>我们正在提供给客户群体哪些系列的产品和服务？</li>
</ul>
<p>价值主张通过迎合细分群体的独特需求来创造价值，价值是可以定量（如价格，服务速度）或定性的（如设计，客户体验）。<br>下面有一些例子：</p>
<ul>
<li>新颖(<em>Newness</em>) 满足客户未曾察觉的全新需求</li>
<li>性能(<em>Performance</em>) PC与显卡</li>
<li>定制化(<em>Customization</em>) 大规模定制（联名款）客户参与创造（MIUI，UGC）</li>
<li>一站式服务(<em>Getting the job done</em>) 咨询公司</li>
<li>设计(<em>Design</em>) 时尚，消费电子产品</li>
<li>品牌/身份地位(<em>Brand/Status</em>) 奢侈品</li>
<li>价格(<em>Price</em>) 廉价航空</li>
<li>缩减成本(<em>cost reduction</em>) 服务外包</li>
<li>风险控制(<em>risk reduction</em>) 保险</li>
<li>可获得性(<em>accessibility</em>) 共享经济</li>
<li>便利性/实用性(<em>convinence/usability</em>) 云计算</li>
</ul>
<p>总的来说，可以分为3个部分：</p>
<ul>
<li>让事情更<strong>简单</strong>（解决痛点）价格，缩减成本，便利性，实用性</li>
<li>让事情更<strong>复杂</strong>（获取收益）定制，设计，品牌地位，可获得性</li>
<li>让事情更<strong>透明</strong>（解决痛点）风险控制，一站式服务</li>
</ul>
<h2 id="3-渠道通路-Channels"><a href="#3-渠道通路-Channels" class="headerlink" title="3. 渠道通路 (Channels)"></a>3. 渠道通路 (Channels)</h2><p><strong>描绘公司是如何与客户细分接触，沟通来描述其价值主张</strong></p>
<p>企业与客户交互体系：交流、分销、销售渠道、售后，是用户的交互触电</p>
<p>作用：了解产品与服务、评估价值主张；购买产品与服务、传递价值主张；提供售后支持</p>
<p><strong>商业真正的秘密，与产品设计的关系微妙（实现层面重合度小，却又容易受到产品口碑风险的冲击，需要做到真正的匹配），容易积累收益但是波动性大、风险高</strong></p>
<ul>
<li>通过哪些渠道可以接触客户细分群体？如何接触？</li>
<li>哪些渠道有效？成本效益最好？</li>
<li>渠道如何整合？渠道与客户的例行程序如何整合？</li>
</ul>
<p>把价值主张推向市场期间，发现如何接触客户的正确渠道组合是至关重要的。</p>
<p>如下是渠道五个阶段的示意图。</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200914-01.png" alt=""></p>
<p>合作伙伴渠道利润低，但是可以通过其扩展企业接触客户的范围和收益。自有渠道利润高，但其建立和运营成本都很高。需要在不同的渠道之间建立平衡，令客户满意的同时使得收益最大化。</p>
<p>一个渠道可以包含上图的一个或五个阶段：<strong>知名度-评价-购买-传递-售后</strong>。</p>
<p><strong>渠道的运营方式</strong>：</p>
<p>一个组织可选用自有渠道、合作方渠道、或混用，以追求获益与成本的平衡以及最佳的客户体验。</p>
<ul>
<li>自身强渠道：比如蓝绿大厂，也就是oppo和vivo，在哪里都可以看到它们的身影，还有品牌贴牌（南极人）与授权认证，能主动引发流量的互联网平台（淘宝）</li>
<li>合作方渠道：各大电商平台，贝业新兄弟（与宜家合作提供家具配送与安装服务），小红书（种草拔草社区）</li>
<li>混用：天猫上的苏宁易购官方店（阿里与苏宁在仓储、物流、售后上的合作），网易严选</li>
<li>（低价）团购与尾货清理：拼多多，唯品会，在线带货</li>
</ul>
<p><strong>一定要重视渠道-设计运维一体化，最容易产生新闻的地方，要能够从渠道构建与运维看出隐含的价值主张与客户关系</strong></p>
<h2 id="4-客户关系（Customer-Relationship）"><a href="#4-客户关系（Customer-Relationship）" class="headerlink" title="4. 客户关系（Customer Relationship）"></a>4. 客户关系（Customer Relationship）</h2><p><strong>一家企业针对某一个客户群体所建立的客户关系的类型</strong></p>
<ul>
<li>靠人员维护（“专属一对一财富管家”） VS 自动化设备（“24小时自助”）</li>
<li>动机：<ul>
<li>开发新客户（客户获取）</li>
<li>留住原客户（客户维系）提高使用频率</li>
<li>增加销售量或客单价（当习惯使用一款产品后，价格变高，比如携程杀熟，天猫的88VIP事件）   <ul>
<li>免费推广-提升忠诚度（全家桶、归属感、情怀）-提高客单价</li>
<li>新手礼包/老用户激活礼包-品牌宣传与建设/用户等级-老客户专属套餐</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>我们每个客户细分群体希望我们与之建立和保持何种关系？</strong></p>
<p><strong>客户关系类型</strong></p>
<ul>
<li><strong>私人服务</strong>(<em>personal assistance</em>)：基于人与人之间的互动（商场导购、柜台服务与电渠、销售员）</li>
<li><strong>专属私人服务</strong>(<em>dedicated personal assistance</em>)：为单一客户安排的专门的客户代表，是层次最深，最亲密的关系类型，需要较长的时间建立（私人银行服务、华为电信设备、健身/培训“私教”）</li>
<li><strong>自助服务</strong>(<em>self-service</em>)：一家公司与客户不存在直接的关系，而是为客户提供自助服务所需要的条件(话费流量充值、银行普通业务（ATM与大厅内自助服务）)</li>
<li><strong>自动化服务</strong>(<em>automated services</em>)：更加精细的自动化过程实现自助服务 （各类平台推荐系统、网站导航设计（活动、凑单、无货推荐、红色与橙色的加入购物车、立即购买））</li>
<li><strong>社区</strong>(<em>communities</em>)：与客户建立更深入的联系，促进社区成员的互动，帮助公司更好的理解客户需求（花粉俱乐部、小米之家、小红书、各类网游社区）</li>
<li><strong>客户共同创造</strong>(<em>co-creation</em>)：和客户共同创造价值 MIUI，UGC（土豆、B站、抖音），各种评论（电影书籍-豆瓣、旅游住宿-Airbnb、普通商品-“自发安利”与评论区），采纳用户反馈的社区（产品调查问卷、游戏平衡运维），小红书<ul>
<li>正面的例子是B站，设立了风纪委员，小黑屋等机制，维护了一个相对较好的社区环境，反面例子懂得都懂~</li>
</ul>
</li>
</ul>
<p>客户关系类型可以分为以下3类</p>
<p>成本导向：自助服务、自动化服务</p>
<p>价值导向：私人服务、专属私人服务、客户共同创造（<strong>差异化的服务 比如VIP</strong>）</p>
<p>兼顾：<strong>社区</strong></p>
<h2 id="5-收入来源（Revenue-Streams）"><a href="#5-收入来源（Revenue-Streams）" class="headerlink" title="5. 收入来源（Revenue Streams）"></a>5. 收入来源（Revenue Streams）</h2><p><strong>企业从每一个客户群体获得的现金收益（扣除成本的利润）</strong></p>
<ul>
<li><p><strong>探索用户真正愿意付费的点！</strong></p>
</li>
<li><p>两类收益来源：</p>
<ul>
<li>一次性交易收入</li>
<li>持续收入（进一步提供产品服务或售后支持）比如现在各种VIP的自动续费</li>
</ul>
</li>
<li><p>定价机制</p>
<ul>
<li><p>固定（基于静态变量）：目录价、基于产品特性（“青春版”、“畅享版”）、基于客户群（教育版）、基于数量</p>
</li>
<li><p>浮动（基于动态变量）：谈判/议价、收益管理（库存与发生购买的时间，如酒店、航班等）、实时市场价格、拍卖</p>
</li>
<li><strong>三级价格歧视（差异定价）</strong>：按人（杀价、拍卖、杀熟）、按量（批发、团购、套餐、优惠券、<em>峰谷阶梯定价</em>）、按类（可选择的差异化服务：氪金、VIP、加急、视频会员、精装与典藏、机票折扣、社交裂变）</li>
</ul>
</li>
</ul>
<p><strong>收入来源的方式</strong></p>
<ul>
<li><strong>资产销售</strong>（<em>asset sale</em>）：实物产品所有权转让，消费者拥有处置的全部权利</li>
<li><strong>使用费</strong>（<em>usage fee</em>）：特定的服务收费，客户使用服务越多，付费越多（电信、宾馆、快递、付费网游点卡、公共交通车票）</li>
<li><strong>会员费</strong>（<em>subscription fee</em>）：销售重复使用的服务（健身卡、付费网游月卡、公共交通月票、音乐会员）</li>
<li><strong>租赁</strong>（<em>lending/renting/leasing</em>）：特定资产在特定时间的使用权转移并获益（<strong>充电宝</strong>）</li>
<li><strong>许可使用费</strong>（<em>licensing</em>）：专利授权、版权（图片、音乐、字体）、<strong>加盟或特许经营</strong></li>
<li><strong>经纪人佣金</strong>（<em>brokerage fees</em>）：信用卡（交易手续费）、支付平台（交易与提现手续费）、中介</li>
<li><strong>广告费</strong>（<em>advertising</em>）：传媒、品牌策划、软件业与服务业；<em>广告费增长乏力，分蛋糕的太多</em></li>
</ul>
<h2 id="6-核心资源（Key-Resources）"><a href="#6-核心资源（Key-Resources）" class="headerlink" title="6. 核心资源（Key Resources）"></a>6. 核心资源（Key Resources）</h2><p><strong>保证一个商业模式顺利运行所需的最重要的资产</strong></p>
<p>每个商业模式都需要核心资源，这些资源使得企业组织能够创造和提供价值主张，接触市场，与客户细分群体建立关系并获取收入。</p>
<ul>
<li>用于：价值主张的创造与提供、开拓市场、维护客户关系并获益</li>
<li>可以“拥有”或者“租赁”<ul>
<li>“拥有”意味着额外的管理、折旧和风险，“租赁”意味着让出的利润空间</li>
</ul>
</li>
</ul>
<p><strong>类型</strong></p>
<ul>
<li><strong>实物资源</strong>（<em>physical</em>）：生产设备、房屋、车辆、机器、系统、销售点管理系统、分销渠道</li>
<li><strong>知识性资源</strong>（<em>intellectual</em>）：品牌（可口可乐）、专利（高通与华为）、知识产权与体系（微软、SAP）</li>
<li><strong>人力资源</strong>（<em>human</em>）：普遍存在，对于创新性和知识密集产业最重要（如IT业），出色的营销团队</li>
<li><strong>金融资源</strong>（<em>financial</em>）：车贷、电子设备免息分期、GE的膨胀与衰落</li>
</ul>
<h2 id="7-关键业务（Key-Activities）"><a href="#7-关键业务（Key-Activities）" class="headerlink" title="7. 关键业务（Key Activities）"></a>7. 关键业务（Key Activities）</h2><p><strong>保障其商业模式正常运行所需做的最重要的事情</strong></p>
<ul>
<li>价值主张、获得市场、客户关系与收益</li>
<li>与价值主张强相关，价值主张的具象化</li>
<li>构建护城河：商业模式创新-&gt;构建不可替代的关键业务-&gt;支撑服务升级-&gt;基础设施投资-&gt;底层技术突破<ul>
<li>09年开始建立阿里云，因为阿里巴巴意识到如果不建立自己的云服务平台，它在淘宝的利润将因为不断扩大的云服务需求被Amazon吞噬</li>
</ul>
</li>
</ul>
<p><strong>类型</strong></p>
<ul>
<li><strong>生产</strong>(<em>production</em>)：包含分销（企业商业模式的核心）</li>
<li><strong>解决方案</strong>(<em>problem solving</em>)：知识管理与持续的培训（咨询公司，医院）</li>
<li><strong>平台/网络</strong>(<em>platform/network</em>)：以平台为核心资源的商业模式，其关键业务与平台管理，服务提供和平台推广相关（XX网、Visa卡、操作系统、应用商店、游戏平台）</li>
</ul>
<h2 id="8-重要合作（Key-Partnership）"><a href="#8-重要合作（Key-Partnership）" class="headerlink" title="8. 重要合作（Key Partnership）"></a>8. 重要合作（Key Partnership）</h2><p><strong>保证一个商业模式顺利运行所需的供应商和合作伙伴网络</strong></p>
<ul>
<li>非竞争者之间的战略联盟 <ul>
<li>3q大战之后的腾讯联盟（与阿里直营思路显著不同）</li>
</ul>
</li>
<li>竞争者之间的战略合作 <ul>
<li>红蓝快乐水、微信支付与支付宝、米国两党制</li>
</ul>
</li>
<li>新业务的合资公司托拉斯 <ul>
<li>大厂“生态” 、微信v.s. 苹果、Fortnite v.s. App Store + Google Play（fortnite试图使得不同系统上的账户可以互通）</li>
</ul>
</li>
<li>稳定供应关系的供应商和采购商 <ul>
<li>产业园、苹果认证供应商、闭环的互联网影视平台（传统影视产业：制作、发行、院线）</li>
</ul>
</li>
</ul>
<p><strong>合作动机</strong></p>
<ul>
<li>优化与规模效应：降低成本，外包或共享基础设施</li>
<li>特殊资源及活动的获得：高技术产品、销售团队、特许商品</li>
<li>降低风险和不确定性：某领域内的战略联盟（蓝光、5g）</li>
</ul>
<h2 id="9-成本结构（Cost-Structure）"><a href="#9-成本结构（Cost-Structure）" class="headerlink" title="9. 成本结构（Cost Structure）"></a>9. 成本结构（Cost Structure）</h2><p><strong>运营一个商业模式所发生的全部成本</strong></p>
<ul>
<li>确定核心资源、关键业务和重要合作之后，成本核算将相对容易</li>
<li>也有以低成本结构为核心的商业模式（廉航、红米、Zara）</li>
</ul>
<p><strong>什么是我们我们商业模式中最重要的固有成本？</strong></p>
<p><strong>哪些核心资源、关键业务花费最多</strong></p>
<p><strong>导向</strong></p>
<ul>
<li>成本导向 cost-driven：成本最小化，创造并维持极尽精简的成本结构 比如廉价航空公司</li>
<li>价值导向 value-driven：高端的价值主张与高度的个性化服务 比如豪华酒店</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li><p>固定成本：管理员工工资，租金，生产设备</p>
</li>
<li><p>可变成本：加工工人工资，加（bai）班（ri）费（meng），广告推广费，水电，原材料消耗</p>
</li>
<li><p>规模经济：大宗采购，大规模生产摊薄的固定成本</p>
</li>
<li><p>范围经济：渠道的复用</p>
</li>
</ul>
<p>  小米台灯为什么那么便宜？</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200926-04.png" alt=""></p>
<p>参考：</p>
<ol>
<li>《商业模式新生代》</li>
</ol>
]]></content>
      <categories>
        <category>需求与商业模式分析</category>
      </categories>
      <tags>
        <tag>商业模式</tag>
      </tags>
  </entry>
  <entry>
    <title>商业模式类型</title>
    <url>/posts/dc6b170d.html</url>
    <content><![CDATA[<h1 id="商业模式类型"><a href="#商业模式类型" class="headerlink" title="商业模式类型"></a>商业模式类型</h1><p>本文将介绍5种商业模式类型</p>
<ul>
<li>分拆商业模式</li>
<li>长尾商业模式</li>
<li>开放式的商业模式</li>
<li>多边商业模式</li>
<li>免费商业模式</li>
</ul>
<h2 id="1-分拆商业模式"><a href="#1-分拆商业模式" class="headerlink" title="1. 分拆商业模式"></a>1. 分拆商业模式</h2><p>对于分拆商业模式，首先需要了解一些基本概念。</p>
<p>我们认为企业内部有3类<strong>规则</strong>：</p>
<ul>
<li>经济</li>
<li>竞争</li>
<li>文化</li>
</ul>
<p>存在3种不同的基本<strong>业务类型</strong>以及它们对应的<strong>价值信条</strong>：</p>
<ul>
<li>客户关系型业务——亲近顾客</li>
<li>产品创新型业务——产品领先</li>
<li>基础设施型业务——运营卓越</li>
</ul>
<p>每种类型的业务都有不同的驱动因素，虽然它们可能同时存在于一家公司，但是由于彼此之间的冲突，需要进行分拆。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>新产品开发</th>
<th>客户关系管理</th>
<th>基础设施管理</th>
</tr>
</thead>
<tbody>
<tr>
<td>经济</td>
<td>速度是关键，越早获得的溢价越高</td>
<td>获取成本高，提高客单价，范围经济</td>
<td>大规模生产降低单位成本，规模是关键</td>
</tr>
<tr>
<td>竞争</td>
<td>针对人才，门槛低，小玩家多</td>
<td>针对范围竞争，寡头占领市场(7:3:1)</td>
<td>针对规模竞争，寡头占领市场(8:2)</td>
</tr>
<tr>
<td>文化</td>
<td>以员工为核心，鼓励创新人才</td>
<td>高度面向服务，客户至上心态</td>
<td>关注成本，统一标准，可预测性和有效性</td>
</tr>
</tbody>
</table>
</div>
<p>分拆商业模式的一个典型的例子是可口可乐。</p>
<ul>
<li><p>新产品</p>
<p>追求健康化：适应无糖的趋势</p>
<p>Costa咖啡，运动饮料，不再局限于可乐</p>
</li>
<li><p>客户关系</p>
<p>本地品牌收购</p>
<p>产品运营：diet coke到zero零度，摆脱女性专属的形象</p>
<p>外包装营销：小瓶，时尚罐和小罐</p>
</li>
<li><p>基础运营</p>
<p>调整灌装线：外包灌装</p>
</li>
</ul>
<h2 id="2-多边平台商业模式"><a href="#2-多边平台商业模式" class="headerlink" title="2. 多边平台商业模式"></a>2. 多边平台商业模式</h2><p>多边平台将两个或更多独立但相互依存的客户群体连接在一起。</p>
<p>只有相关客户群体同时存在的时候，平台才具有价值。平台通过促进不同群体之间的互动而创造价值。比如信用卡连接商家和持卡人，计算机操作系统连接硬件厂商，应用开发商和用户。</p>
<p>单个用户群体的价值本质上取决于平台中另一群体的用户数量，这就产生了一个难题：“先有鸡还是先有蛋“。需要弄清楚哪一“边”能够更好的吸引其它“边”，从而提供免费服务甚至补贴，比如B站：观众免费，补贴Up主。</p>
<p>多边平台的价值提升在于它所吸引的用户数量的增加，这一现象也叫做网络效应。</p>
<h2 id="3-免费商业模式"><a href="#3-免费商业模式" class="headerlink" title="3. 免费商业模式"></a>3. 免费商业模式</h2><p>在免费商业模式中，至少有一个关键的客户群体可以持续免费地享受服务。</p>
<p><strong>三种可行的免费商业模式</strong>：（至少一个群体将得到免费的商品）</p>
<ul>
<li>广告模式：基于多边平台的免费商品</li>
<li>免费增值：免费的基本服务，可选的增值服务</li>
<li>诱饵&amp;陷阱：以免费或很便宜的初始价格吸引客户，并引导其重复购买</li>
</ul>
<p>好的产品和服务以及高流量会吸引广告商，进而补贴产品和服务。但是要考虑广告费能否支撑起产品服务质量，现在的情况是巨头吞噬广告费的产品太多，流量红利已见底。</p>
<h2 id="4-诱饵-amp-陷阱模式"><a href="#4-诱饵-amp-陷阱模式" class="headerlink" title="4. 诱饵&amp;陷阱模式"></a>4. 诱饵&amp;陷阱模式</h2><p>通过廉价的，有吸引力的初始产品或服务，来促进相关产品未来的重复购买。</p>
<p>典型的例子有吉列剃须刀，刀柄加上频繁替换的刀片。</p>
<p>产品与后续产品之间要有紧密连接，从而使得极小收益的初始购买为后续高收益产品或服务的重复购买创造可能。关注后续产品交付，需要强大品牌支撑</p>
<h2 id="5-长尾商业模式"><a href="#5-长尾商业模式" class="headerlink" title="5. 长尾商业模式"></a>5. 长尾商业模式</h2><p>核心是多样少量，进行极致的客户细分。</p>
<p>专注满足非主流市场需要以获得媲美主流产品的收益</p>
<p>信息技术与运营管理方法的改善使得定制化价值主张可以面向大量新客户，并且成本低廉。</p>
<p>参考：</p>
<ol>
<li>《商业模式新生代》</li>
</ol>
]]></content>
      <categories>
        <category>需求与商业模式分析</category>
      </categories>
      <tags>
        <tag>商业模式</tag>
      </tags>
  </entry>
  <entry>
    <title>商业模式设计</title>
    <url>/posts/f47639cf.html</url>
    <content><![CDATA[<h1 id="商业模式设计"><a href="#商业模式设计" class="headerlink" title="商业模式设计"></a>商业模式设计</h1><p>作为一名设计师，<strong>必须</strong>执着地探究所有可能性，直到创造出崭新的设计，开拓从未被人开发的领域，最终实现想要的功能（<strong>所有创新类工作的本质</strong>）</p>
<p>设计师的工作：挑战思维边界、创造新选择、最终为用户创造价值</p>
<p>设计的三个相互重叠的空间：<strong>灵感，构思，实施</strong></p>
<p>本文将介绍6种商业模式设计方法。分别是客户洞察，创意构思，可视思考，原型制作，故事讲述，情景推测。</p>
<h2 id="1-客户洞察"><a href="#1-客户洞察" class="headerlink" title="1. 客户洞察"></a>1. 客户洞察</h2><p>客户视角是商业模式的指导性原则，客户的观点决定了我们选择怎样的价值主张、渠道、客户关系和收益来源。</p>
<ul>
<li>透彻的观察，发现情感的源泉，发现内在的内容、意义与本质</li>
<li>事实上，企业在市场上重金投入的产品、服务和商业模式往往会忽略客户的观点</li>
<li>成功的创新需要深入理解客户的环境、日常工作、担忧和渴望</li>
</ul>
<p>但是，客户洞察也存在一些难点。</p>
<ul>
<li>透彻理解客户（ “问题背后的问题” ）需要人类学、社会学理论（笼统的人），以及与实地调研（具体的人）结合；</li>
<li>清楚了解企业当前关注哪些客户（的需要），忽略哪些客户（的需要）</li>
</ul>
<p><strong>洞察力</strong>是设计思维的关键来源之一</p>
<p><strong>换位思考</strong>促使我们体会每个人的感受</p>
<p>我们可以使用移情图来辅助构建用户画像。罗列所有客户群体，挑选3个最有希望的，选择一个作为分析对象。</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20201116-01.png" alt=""></p>
<ul>
<li><strong>看：</strong>描述该客户在她所处的环境中所看到的东西</li>
<li><strong>听：</strong>描述环境如何影响到这个客户</li>
<li><strong>想&amp;感受：</strong>尝试勾勒你的客户思维的过程</li>
<li><strong>说&amp;做：</strong>想象客户可能的言辞，或公共场合的行为</li>
<li><strong>痛点：</strong>已遭受的挫折、正遇到的阻碍、怕承担的风险</li>
<li><strong>收益：</strong>预期成就、成功衡量标准、实现目标所采用的策略</li>
</ul>
<h2 id="2-创意构思"><a href="#2-创意构思" class="headerlink" title="2. 创意构思"></a>2. 创意构思</h2><p>一个能够产生大量商业模式创意，并成功识别出其中最佳创意的流程被称作构思（ideation）</p>
<ul>
<li>大多数行业只有一种主流商业模式的现状已经改变，同一个市场中会有多种商业模式进行竞争，行业之间的界限也正变得模糊甚至消失</li>
<li>创造新商业模式时需要忽略现状并停止对操作性问题的担忧</li>
<li>商业模式创新不是抄袭经典或者对标“友商”，而是创造新机制来满足那些未被满足的、新的或者隐藏在背后的客户需求</li>
</ul>
<p>构思的两个步骤：生成大量创意-&gt;对创意进行整合并挑选</p>
<p>生成阶段要重视数量；可行的创意可以是颠覆性的，也可以是领域的扩展</p>
<p>提出新创意的两个出发点</p>
<ul>
<li>从画布中寻找创新的焦点</li>
<li>不断提出“如果…会怎样”的问题”</li>
</ul>
<p>商业模式创新的<strong>焦点</strong>：</p>
<ul>
<li>资源驱动：创新来源于组织现有的基础设施或合作伙伴资源<ul>
<li>云计算服务、高传输低时延的5g网络</li>
</ul>
</li>
<li>供给驱动：创造全新的价值主张，并影响到其它模块<ul>
<li>水泥输送从48小时减为4小时</li>
<li>云端的全托管机器学习与自动调优、云游戏</li>
</ul>
</li>
<li>客户驱动：基于客户需求、可获得性或便利性的提升，并影响其他模块<ul>
<li>23andMe的个人DNA测试服务（从医疗与研究领域转来）</li>
<li>付费自习室：价值主张-（成年人）沉浸式学习空间；收入来源：5-20元/小时租赁</li>
</ul>
</li>
<li>财务驱动：由新收益来源、定价机制或者被缩减的成本驱动的创新<ul>
<li>施乐复印机从卖设备转向复印机出租（月费95美元，含2000份复印，超出5美分每张）</li>
<li>IBM服务器从软件+硬件转型为开源+咨询+硬件</li>
</ul>
</li>
<li>多点驱动：多焦点驱动的创新，并对其它模块产生深远影响<ul>
<li>“卖产品”转为“卖服务”</li>
<li>B站：与共青团及官媒的合作、内容从二次元到多圈融合、从内容转向社交（陪伴）、高粘性用户的游戏运营与内容驱动直播</li>
</ul>
</li>
</ul>
<p><strong>头脑风暴</strong>是构思的重要手段。它的规则是：</p>
<ul>
<li>保持聚焦：精确表达当前问题、始终与客户需求有关、不要跑题太远、将讨论拉回到开始问题</li>
<li>执行规则：坚决执行开始时的规则：“不过早下结论”、“每次一人讲“、”追求数量”、“可视化”、“疯狂创意”</li>
<li>视觉化思考：将创意写或者画在每个人都能看到的地方：便利贴+黑板/墙</li>
<li>准备：为一次头脑风暴所准备的钻研：技术研讨、实地考察、客户讨论等各种形式</li>
</ul>
<h2 id="3-可视思考"><a href="#3-可视思考" class="headerlink" title="3. 可视思考"></a>3. 可视思考</h2><p>商业模式的讨论需要视觉化思考：<strong>抽象的东西具体化、复杂的概念简单化</strong></p>
<ul>
<li>商业模式是一个由许多模块以及模块之间的复杂关系组成的复杂概念，其内部元素相互影响，但只有作为一个整体系统时才有意义</li>
<li>视觉化能够一目了然的刻画商业模式的主旨，并具象化其中的隐含假设</li>
<li>视觉化能够使商业模式变的明确，为团队讨论提供一些概念性的锚点，使讨论从抽象思维落实到具体、形象的东西</li>
<li>视觉化既能找出已有模式中的逻辑缺陷，又能在设计全新模式时更容易地添加、删除和移动相关的图片化概念</li>
</ul>
<p>视觉化思考使用的两项技术与四个流程</p>
<ul>
<li>如何使用便利贴+如何将草图与商业模式画布结合</li>
<li>四个流程：理解、对话、探索、沟通</li>
</ul>
<p>视觉化的作用：</p>
<ul>
<li>理解商业模式的本质</li>
<li>提升对话效率</li>
<li>探索创意</li>
<li>提升沟通</li>
</ul>
<h2 id="4-模型构建"><a href="#4-模型构建" class="headerlink" title="4. 模型构建"></a>4. 模型构建</h2><p>与视觉化思考一样，模型构建可以使抽象的概念具体化，帮助探索新的创意</p>
<ul>
<li>在产品、架构和交互设计上得到广泛应用，但在商业管理领域不太常用</li>
<li>这里的“模型”：用于讨论、探究或概念验证的工具，目标是探索未来潜在的商业模式（不等于软工领域的模型或原型），可以是草图、画布或财务报表</li>
</ul>
<p>模型构建有助于实际商业模式的探索</p>
<ul>
<li>建模-（疑问点明确化、视觉化）-添加、删除或修改元素-观察结果</li>
<li>在不同规模（抽象层面）的模型上进行互动</li>
<li>有助于获得突破性的商业模式，同时能够有效控制细节</li>
</ul>
<h2 id="5-讲故事"><a href="#5-讲故事" class="headerlink" title="5. 讲故事"></a>5. 讲故事</h2><p>故事是一个理想的热身工具，为深度讨论商业模式与其内在逻辑做好准备，将故事与画布结合，利用叙事性克服听众对不熟悉模式的抵触，放下对陌生事物的怀疑。</p>
<p>为什么要讲故事？</p>
<ul>
<li>介绍新想法：尝试融入组织战略</li>
<li>向投资人推销：争取外部资源（是什么，为谁服务，如何获得收益）</li>
<li>吸引员工（成员）：抓住组员的注意力和好奇心，为下一步探讨准备</li>
<li>让未来触手可及：激发创意、辩证变革</li>
</ul>
<p>故事拥有两个不同的视角：员工和客户</p>
<h2 id="6-情景"><a href="#6-情景" class="headerlink" title="6. 情景"></a>6. 情景</h2><p>将模型构建中明确的方向具体化，从而给出有见地的设计</p>
<p>两种场景</p>
<ul>
<li>不同的客户结构：结合客户洞察描绘出独特、具体的图景</li>
<li>未来可能的竞争环境：想象未来可能的具体细节，品味特定条件下商业模式如何演进</li>
</ul>
]]></content>
      <categories>
        <category>需求与商业模式分析</category>
      </categories>
      <tags>
        <tag>商业模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Neo4j_CQL语法简介</title>
    <url>/posts/55958cb4.html</url>
    <content><![CDATA[<h1 id="Neo4j-CQL语法简介"><a href="#Neo4j-CQL语法简介" class="headerlink" title="Neo4j CQL语法简介"></a>Neo4j CQL语法简介</h1><p>注：本文中的示例来自于Neo4j的<code>Example Graphs</code>中的<code>Movies</code></p>
<h2 id="1-MATCH-amp-RETURN"><a href="#1-MATCH-amp-RETURN" class="headerlink" title="1. MATCH &amp; RETURN"></a>1. MATCH &amp; RETURN</h2><pre><code class="hljs CQL">MATCH (p:Person) RETURN p LIMIT 10</code></pre>
<p><code>match</code>查询节点，关系，标签，属性等。类似于SQL中的<code>SELECT</code></p>
<p>匹配10个<code>Person</code>并返回，注意如果需要使用<code>RETURN</code>就需要一个像<code>p</code>这样的变量来存储返回内容</p>
<pre><code class="hljs CQL">MATCH (p:Person &#123;name: &quot;Al Pacino&quot;&#125;) RETURN p</code></pre>
<p>查询姓名为<code>Al Pacino</code>的<code>Person</code>节点并返回</p>
<pre><code class="hljs CQL">MATCH (:Person &#123;name: &#39;Tom Hanks&#39;&#125;)-[:DIRECTED]-&gt;(movie:Movie)
RETURN movie.title</code></pre>
<p>查询Tom Hanks导演的电影，并返回电影的标题</p>
<pre><code class="hljs CQL">MATCH (tom:Person &#123;name:&#39;Tom Hanks&#39;&#125;)-[rel:DIRECTED]-(movie:Movie)
RETURN tom.name AS name</code></pre>
<p>使用<code>AS</code>关键字设置别名</p>
<h2 id="2-CREATE"><a href="#2-CREATE" class="headerlink" title="2. CREATE"></a>2. CREATE</h2><pre><code class="hljs CQL">CREATE (friend:Person &#123;name: &#39;Mark&#39;, born: 36&#125;)
RETURN friend</code></pre>
<p>创建一个<code>Person</code>界面，设置两个属性的值，返回创建的节点（这一步不是必须的，但在实际开发中可以作为测试）</p>
<pre><code class="hljs CQL">MATCH (jennifer:Person &#123;name: &#39;jennifer&#39;&#125;)
MATCH (mark:Person &#123;name: &#39;Mark&#39;&#125;)
CREATE (jennifer)-[rel:IS_FRIENDS_WITH]-&gt;(mark)</code></pre>
<p><strong>注意</strong>：<code>CREATE</code>不会判断节点在数据库中是否已经存在，为了避免重复插入，这里先使用<code>MATCH</code>查询节点是否已经存在，再在两者间建立关系</p>
<p>但是如果节点不存在，就不会执行？？？</p>
<h2 id="3-UPDATE"><a href="#3-UPDATE" class="headerlink" title="3. UPDATE"></a>3. UPDATE</h2><pre><code class="hljs CQL">MATCH (p:Person &#123;name: &#39;Keanu Reeves&#39;&#125;) set p.born &#x3D; 1962 RETURN p</code></pre>
<p>使用<code>set</code>关键字执行更新操作</p>
<ol>
<li>使用<code>MATCH</code>查找节点</li>
<li>使用<code>set</code>设置节点的属性值</li>
<li>返回节点确保更新正确</li>
</ol>
<pre><code class="hljs CQL">MATCH (:Person &#123;name: &#39;Keanu Reeves&#39;&#125;)-[rel:ACTED_IN]-&gt;(:Movie &#123;title: &#39;Something\&#39;s Gotta Give&#39;&#125;) 
set rel.roles &#x3D; &#39;阿巴阿巴&#39; 
RETURN rel</code></pre>
<p>也可以更新关系的属性，比如这里更新了演员在某部电影中饰演的角色</p>
<h2 id="4-DELETE-amp-REMOVE"><a href="#4-DELETE-amp-REMOVE" class="headerlink" title="4. DELETE &amp; REMOVE"></a>4. DELETE &amp; REMOVE</h2><p>由于Neo4j数据库具备原子性，一致性，隔离性和持久性，所以无法在一个节点仍然有关系的情况下删除它。</p>
<h3 id="4-1-删除关系"><a href="#4-1-删除关系" class="headerlink" title="4.1 删除关系"></a>4.1 删除关系</h3><pre><code class="hljs CQL">MATCH (j:Person &#123;name: &#39;Jennifer&#39;&#125;)-[r:IS_FRIENDS_WITH]-&gt;(m:Person &#123;name: &#39;Mark&#39;&#125;)
DELETE r</code></pre>
<p>要想删除一个关系，需要找到关系的起始节点和关系的终止节点，然后使用<code>`DELETE</code>关键字删除节点之间的关系</p>
<h3 id="4-2-删除节点"><a href="#4-2-删除节点" class="headerlink" title="4.2 删除节点"></a>4.2 删除节点</h3><pre><code class="hljs CQL">MATCH (m:Person &#123;name: &#39;Mark&#39;&#125;)
DELETE m</code></pre>
<p>如果一个节点没有任何的关系，那么可以直接删除它。</p>
<h3 id="4-3-同时删除节点和关系"><a href="#4-3-同时删除节点和关系" class="headerlink" title="4.3 同时删除节点和关系"></a>4.3 同时删除节点和关系</h3><pre><code class="hljs CQL">MATCH (m:Person &#123;name: &#39;Mark&#39;&#125;)
DETACH DELETE m</code></pre>
<p><code>DETACH DELETE</code>可以删除节点的所有关系，同时删除节点。</p>
<h3 id="4-4-删除属性"><a href="#4-4-删除属性" class="headerlink" title="4.4 删除属性"></a>4.4 删除属性</h3><pre><code class="hljs CQL">MATCH (n:Person &#123;name: &#39;Jennifer&#39;&#125;)
REMOVE n.birthdate</code></pre>
<p>第一种删除属性的方式是<code>REMOVE</code>关键字</p>
<pre><code class="hljs CQL">MATCH (n:Person &#123;name: &#39;Jennifer&#39;&#125;)
SET n.birthdate &#x3D; null</code></pre>
<p>第二种删除属性的方式是使用<code>set</code>关键字将属性的值设为<code>null</code>。因为neo4j数据库不会存储<code>null</code>值，所以它也会被删除。</p>
<h2 id="5-Merge"><a href="#5-Merge" class="headerlink" title="5. Merge"></a>5. Merge</h2><p>在第二部分里面提到的重复插入问题，可以通过关键字<code>merge</code>来解决。</p>
<h3 id="5-1-节点"><a href="#5-1-节点" class="headerlink" title="5.1 节点"></a>5.1 节点</h3><pre><code class="hljs CQL">MERGE (mark:Person &#123;name: &#39;Mark&#39;, born: 1999&#125;)
RETURN mark</code></pre>
<p>可以使用<code>merge</code>关键字来避免重复插入节点，它会事先检查节点是否已经存在在数据库中，执行的是<code>select-or-insert</code>的操作。</p>
<h3 id="5-2-关系"><a href="#5-2-关系" class="headerlink" title="5.2 关系"></a>5.2 关系</h3><pre><code class="hljs cypher">MATCH (j:Person &#123;name: &#39;Jennifer&#39;&#125;)
MATCH (m:Person &#123;name: &#39;Mark&#39;&#125;)
MERGE (j)-[r:IS_FRIENDS_WITH]-&gt;(m)
RETURN j, r, m</code></pre>
<p>这里首先通过<code>MATCH</code>检查是否存在我们要建立关系的两个节点，如果存在，再在两者之间建立关系。</p>
<p><strong>注意：</strong><code>Merge</code>会检查我们要建立的模式在数据库中已经存在，如果不存在，那么它会将模式完整地建立，包括节点和关系。使用下面的语句，如果节点已经存在，那么就会造成重复插入的问题。所以一定要先<strong>用<code>MATCH</code>匹配节点是否已经存在</strong></p>
<pre><code class="hljs cypher">&#x2F;&#x2F;this statement will create duplicate nodes for Mark and Jennifer
MERGE (j:Person &#123;name: &#39;Jennifer&#39;&#125;)-[r:IS_FRIENDS_WITH]-&gt;(m:Person &#123;name: &#39;Mark&#39;&#125;)
RETURN j, r, m</code></pre>
<pre><code class="hljs cypher">MERGE (m:Person &#123;name: &#39;Mark&#39;&#125;)-[r:IS_FRIENDS_WITH]-(j:Person &#123;name:&#39;Jennifer&#39;&#125;)
  ON MATCH SET r.updated &#x3D; date()
RETURN m, r, j</code></pre>
<p>如果想要不重复创建节点，并且更新匹配到的节点属性，可以使用<code>ON MATCH SET</code>的方式</p>
<p>官方文档上的<code>ON CTRATE SET</code>似乎没有作用，而<code>ON MATCH SET</code>就可以起到创建和更新的作用</p>
<h2 id="6-WHERE"><a href="#6-WHERE" class="headerlink" title="6. WHERE"></a>6. WHERE</h2><p>与SQL查询类似，CQL也可以使用where进行范围的限定，在全键值等值查询时，效果与前面的例子一样。但对于熟悉SQL语法的人来说可能这种方式更容易上手。</p>
<pre><code class="hljs cypher">&#x2F;&#x2F;query using equality check in the MATCH clause
MATCH (j:Person &#123;name: &#39;Jennifer&#39;&#125;)
RETURN j

&#x2F;&#x2F;query using equality check in the WHERE clause
MATCH (j:Person)
WHERE j.name &#x3D; &#39;Jennifer&#39;
RETURN j</code></pre>
<h3 id="6-1-否定属性"><a href="#6-1-否定属性" class="headerlink" title="6.1 否定属性"></a>6.1 否定属性</h3><p>使用<code>NOT</code> <code>AND</code> <code>OR</code> <code>XOR</code>等操作符</p>
<pre><code class="hljs cypher">MATCH (j:Person)
WHERE NOT j.name &#x3D; &#39;Jennifer&#39;
RETURN j</code></pre>
<h3 id="6-2-范围查询"><a href="#6-2-范围查询" class="headerlink" title="6.2 范围查询"></a>6.2 范围查询</h3><p>查询1960到1970年出生的人</p>
<pre><code class="hljs cypher">MATCH (p:Person)
WHERE 1960 &lt;&#x3D; p.born &lt;&#x3D; 1970
RETURN p</code></pre>
<h3 id="6-3-exists"><a href="#6-3-exists" class="headerlink" title="6.3 exists"></a>6.3 exists</h3><p>检查一个属性是否存在</p>
<p><strong>注意</strong>：neo4j不会存储null值</p>
<pre><code class="hljs cypher">&#x2F;&#x2F;Query1: find all users who have a birthdate property
MATCH (p:Person)
WHERE exists(p.birthdate)
RETURN p.name</code></pre>
<h3 id="6-4-模糊查询"><a href="#6-4-模糊查询" class="headerlink" title="6.4 模糊查询"></a>6.4 模糊查询</h3><p>对一个字符串，我们可能需要根据前缀，后缀或包含进行模糊查询。</p>
<pre><code class="hljs cypher">&#x2F;&#x2F;check if a property starts with &#39;M&#39;
MATCH (p:Person)
WHERE p.name STARTS WITH &#39;Ma&#39;
RETURN p.name

&#x2F;&#x2F;check if a property contains &#39;a&#39;
MATCH (p:Person)
WHERE p.name CONTAINS &#39;a&#39;
RETURN p.name

&#x2F;&#x2F;check if a property ends with &#39;n&#39;
MATCH (p:Person)
WHERE p.name ENDS WITH &#39;n&#39;</code></pre>
<p>当然，我们还可以使用正则表达式的形式。<code>~</code>表示使用正则表达式</p>
<pre><code class="hljs cypher">MATCH (p:Person)
WHERE p.name &#x3D;~ &#39;Jo.*&#39;
RETURN p.name</code></pre>
<h3 id="6-5-Filtering-on-Patterns"><a href="#6-5-Filtering-on-Patterns" class="headerlink" title="6.5 Filtering on Patterns"></a>6.5 Filtering on Patterns</h3><p>由于neo4j是图形数据库，它比其它数据库更注重于关系(relationships)。所以我们也可以通过关系来进行筛选。</p>
<p>比如下面这个关系匹配同时担任一部电影的导演和编剧的人。</p>
<pre><code class="hljs cypher">MATCH (p:Person)-[r:DIRECTED]-&gt;(m:Movie)
WHERE exists((p)-[:WROTE]-&gt;(m))
RETURN p</code></pre>
<h3 id="6-6-Optional-Patterns"><a href="#6-6-Optional-Patterns" class="headerlink" title="6.6 Optional Patterns"></a>6.6 Optional Patterns</h3><p>类似于SQL的外连接。可选匹配。</p>
<p>这个例子匹配以姓名以Jo开头并且担任过电影编剧的人，后面这个条件不是强制的。</p>
<pre><code class="hljs cypher">MATCH (p:Person)
WHERE p.name STARTS WITH &#39;Jo&#39;
OPTIONAL MATCH (p) - [:WROTE] -&gt; (m:Movie)
RETURN p.name, m.title</code></pre>
<h2 id="7-Aggregation-in-Cypher"><a href="#7-Aggregation-in-Cypher" class="headerlink" title="7. Aggregation in Cypher"></a>7. Aggregation in Cypher</h2><h3 id="7-1-count"><a href="#7-1-count" class="headerlink" title="7.1 count"></a>7.1 count</h3><p>统计数量</p>
<p>例1加上了属性值title，可以去掉null值，而使用*会统计所有电影节点。</p>
<pre><code class="hljs cypher">MATCH (m:Movie)
RETURN count(m.title)
   
MATCH (m:Movie)
RETURN count(*)</code></pre>
<h3 id="7-2-collect"><a href="#7-2-collect" class="headerlink" title="7.2 collect"></a>7.2 collect</h3><p>将值聚合成一个列表。可以使用collect基于一个起始节点或关系等组织一系列的值。</p>
<p>下面这个例子展示了导演和他们执导的电影。如果不使用collect，那么导演和电影会一对一的呈现在表格中。但一个导演可能执导过多部电影，所以使用collect将电影节点聚合起来。</p>
<pre><code class="hljs cypher">MATCH (p:Person) - [r:DIRECTED] -&gt; (m:Movie)
RETURN p.name, collect(m.title) AS titles</code></pre>
<h3 id="7-3-size"><a href="#7-3-size" class="headerlink" title="7.3 size"></a>7.3 size</h3><p>size的作用是统计列表中元素的个数或者统计一个表达式返回的内容大小。</p>
<pre><code class="hljs cypher">&#x2F;&#x2F; 统计导演执导电影数量
MATCH (p:Person) - [r:DIRECTED] -&gt; (m:Movie)
RETURN p.name, collect(m.title) AS titles, size(collect(m.title)) AS count

&#x2F;&#x2F; 统计导演同时还担任该电影的编剧的数量
MATCH (p:Person) - [r:DIRECTED] -&gt; (m:Movie)
RETURN p.name, size((p) - [:WROTE] -&gt; (m)) AS count</code></pre>
<h3 id="7-4-WITH"><a href="#7-4-WITH" class="headerlink" title="7.4 WITH"></a>7.4 WITH</h3><p>使用<code>WITH</code>传递参数到下一个查询</p>
<pre><code class="hljs cypher">&#x2F;&#x2F;find number of friends who have other friends
MATCH (p:Person)-[:IS_FRIENDS_WITH]-&gt;(friend:Person)
WITH p, collect(friend.name) AS friendsList, size((friend)-[:IS_FRIENDS_WITH]-(:Person)) AS numberOfFoFs
WHERE numberOfFoFs &gt; 1
RETURN p.name, friendsList, numberOfFoFs

&#x2F;&#x2F;find people with 2-6 years of experience
WITH 2 AS experienceMin, 6 AS experienceMax
MATCH (p:Person)
WHERE experienceMin &lt;&#x3D; p.yrsExperience &lt;&#x3D; experienceMax
RETURN p</code></pre>
<h3 id="7-5-UNWIND"><a href="#7-5-UNWIND" class="headerlink" title="7.5 UNWIND"></a>7.5 UNWIND</h3><p>将一个列表拆分成单独的值，与<code>collect()</code>的作用相反</p>
<pre><code class="hljs cypher">&#x2F;&#x2F;Query10: for numbers in a list, find candidates who have that many years of experience
WITH [4, 5, 6, 7] AS experienceRange
UNWIND experienceRange AS number
MATCH (p:Person)
WHERE p.yearsExp &#x3D; number
RETURN p.name, p.yearsExp</code></pre>
<h3 id="7-6-ORDER-BY"><a href="#7-6-ORDER-BY" class="headerlink" title="7.6 ORDER BY"></a>7.6 ORDER BY</h3><p>排序，默认是升序的。</p>
<p>如下的例子将出生在1960年到1965年的人按降序排序</p>
<p>（如果对个值参与排序，那按照先后顺序排序）</p>
<pre><code class="hljs cypher">MATCH (p:Person)
WHERE 1960 &lt;&#x3D; p.born &lt;&#x3D; 1965
RETURN p.name, p.born ORDER BY p.born DESC</code></pre>
<h3 id="7-7-DISTINCT"><a href="#7-7-DISTINCT" class="headerlink" title="7.7 DISTINCT"></a>7.7 DISTINCT</h3><p>有点时候，一个查询可能会返回多个重复的结果。使用<code>DISTINCT</code>可以解决这个问题。</p>
<p>下面这个例子查询导演过电影并且担任过电影编剧的人，有的人导演过多部电影，那么就会返回重复的名字，但使用了<code>DISTINCT</code>，就可以获得独特的结果。</p>
<pre><code class="hljs cypher">MATCH (p:Person) - [:DIRECTED] -&gt; (m:Movie)
MATCH (p) - [:WROTE] -&gt; (:Movie)
RETURN DISTINCT p.name</code></pre>
<h3 id="7-8-LIMIT"><a href="#7-8-LIMIT" class="headerlink" title="7.8 LIMIT"></a>7.8 LIMIT</h3><p>限制返回的个数</p>
<pre><code class="hljs cypher">MATCH (p:Person) RETURN p LIMIT 10</code></pre>
<h2 id="8-进阶"><a href="#8-进阶" class="headerlink" title="8. 进阶"></a>8. 进阶</h2><h3 id="8-1-APOC插件"><a href="#8-1-APOC插件" class="headerlink" title="8.1 APOC插件"></a>8.1 APOC插件</h3><h4 id="8-1-1-简介"><a href="#8-1-1-简介" class="headerlink" title="8.1.1 简介"></a>8.1.1 简介</h4><p> APOC是 Neo4j 3.3 版本推出时正式推荐的一个Java存储过程包，里面包含丰富的函数和过程，作为对Cypher所不能提供的复杂图算法和数据操作功能的补充，APOC还具有使用灵活、高性能等优势，是一个基于Neo4j的函数包插件。</p>
<h4 id="8-1-2-安装"><a href="#8-1-2-安装" class="headerlink" title="8.1.2 安装"></a>8.1.2 安装</h4><ol>
<li><p>下载对应的jar包<a target="_blank" rel="noopener" href="https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases">https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases</a></p>
</li>
<li><p>把jar包放在安装目录的plugins文件夹下</p>
</li>
<li><p>进入neo4j的目录，编辑在<code>conf</code>文件夹下的<code>neo4j.conf</code>配置文件，加入如下一行</p>
<pre><code class="hljs shell">dbms.security.procedures.unrestricted=apoc.*</code></pre>
</li>
<li><p>重启Neo4j服务</p>
</li>
<li><p>在可视化界面运行：<code>return apoc.version()</code>。如果出现对应的版本号，证明安装成功</p>
</li>
</ol>
<h3 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h3><p>变量引用<code>$</code></p>
<pre><code class="hljs cypher">MATCH (n:Person)
WHERE n.name &#x3D; $name
RETURN n</code></pre>
<p>动态访问节点或关系<code>[]</code></p>
<p>Springboot data neo4j @Query不支持<code>apoc</code></p>
<p>不会报错但返回信息为<code>null</code></p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://neo4j.com/developer/cypher/">Neo4j官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36226553/article/details/108569048?spm=1001.2014.3001.5501">Neo4j：入门基础（三）之APOC插件</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>mosh优化ssh</title>
    <url>/posts/38412875.html</url>
    <content><![CDATA[<p>最近使用ssh连接云服务器时，卡顿的现象很严重，输入一段内容要等一会儿才会显示完全，在网上找了半天，看到了一个ssh的替代品——<a target="_blank" rel="noopener" href="https://mosh.org/">mosh</a></p>
<a id="more"></a>
<h1 id="1-什么是mosh"><a href="#1-什么是mosh" class="headerlink" title="1. 什么是mosh"></a>1. 什么是mosh</h1><p>Mosh最大的特点是基于<strong>UDP</strong>方式传输，支持在服务端创建一个临时的Key供客户端一次性连接，退出后失效；也支持通过SSH的配置进行认证，但数据传输本身还是自身的UDP方式。</p>
<p>另外，Mosh还有两个我觉得非常有用的功能</p>
<ul>
<li>会话的中断不会导致当前正在前端执行的命令中断，相当于你所有的操作都是在screen命令中一样在后台执行。</li>
<li>会话在中断过后，不会立刻退出，而是启用一个计时器，当网络恢复后会自动重新连接，同时会延续之前的会话，不会重新开启一个。</li>
</ul>
<h1 id="2-服务端配置"><a href="#2-服务端配置" class="headerlink" title="2. 服务端配置"></a>2. 服务端配置</h1><p>我的Linux服务器版本是Ubuntu18.04</p>
<p>输入如下命令安装mosh</p>
<pre><code class="hljs shell">sudo apt-get update
sudo apt-get install mosh</code></pre>
<p>Mosh使用UDP协议连接，端口从60000到61000，网上有教程使用ufw开启端口，但是经过测试是无效的，有一个比较方便的方法时直接在云服务器管理控制台的安全组中添加。</p>
<p><img src="https://learn-notes-1301797566.cos.ap-shanghai.myqcloud.com/20200926-03.png" alt=""></p>
<h1 id="3-客户端配置"><a href="#3-客户端配置" class="headerlink" title="3. 客户端配置"></a>3. 客户端配置</h1><p>本地机器是Mac，输入命令安装mosh，注意客户端和服务端都需要安装mosh</p>
<pre><code class="hljs shell">brew install mosh</code></pre>
<p>安装完成后需要进入本地shell脚本文件中</p>
<p>如果安装了zsh，就使用命令<code>vi ~/.zshrc</code></p>
<p>如果是bash，就使用命令<code>vi ~/.bash_profile</code></p>
<p>添加如下两行</p>
<pre><code class="hljs shell">export LC_CTYPE=en_US.UTF-8  
export LC_ALL=en_US.UTF-8</code></pre>
<p>保存退出后，使用<code>source ~/.zshrc</code>或者<code>source ~/.bash_profile</code>使得更改生效。</p>
<p>使用如下命令连接</p>
<pre><code class="hljs shell">mosh root@IP -p 60001</code></pre>
<p>输入瞬间变得丝滑起来。</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>mosh</tag>
      </tags>
  </entry>
</search>
