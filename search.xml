<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Head First Pattern读书笔记(一)</title>
      <link href="/Design-Pattern/head-first-pattern-notes1/"/>
      <url>/Design-Pattern/head-first-pattern-notes1/</url>
      
        <content type="html"><![CDATA[<h1 id="head-first-设计模式-读书笔记"><a class="markdownIt-Anchor" href="#head-first-设计模式-读书笔记"></a> Head First 设计模式 读书笔记</h1><h2 id="一-设计模式入门"><a class="markdownIt-Anchor" href="#一-设计模式入门"></a> 一、 设计模式入门</h2><p>如果有一个鸭子的类如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  quack();</span><br><span class="line">  swim();</span><br><span class="line">  dispaly(); <span class="comment">// 每一种鸭子不同，display()抽象</span></span><br><span class="line">  <span class="comment">// 其它方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需要增加一个功能，让鸭子会飞。</p><p>如果直接添加一个<code>fly()</code>方法，则所有子类都具备该方法，那么会出现会飞的橡皮鸭。</p><p><font color=red><strong>涉及维护问题，为了&quot;复用&quot;目的而使用继承，并不合适</strong></font></p><p>可能的解决方案：</p><ol><li><p>继承：把在橡皮鸭的<code>fly()</code>方法覆盖</p><p><strong>问题</strong>：如果再加入诱饵鸭，不会飞也不会叫，每次更新加入更多的鸭子……</p><p>于是每当有新的子类，就要检查<code>fly()</code>方法</p><p>我们发现了以下缺点</p><ul><li>代码在多个子类中重复</li><li>运行时的状态不易改变</li><li>很难知道所有鸭子的行为</li><li>改变会牵一发而动全身，造成不想要的改变</li></ul></li><li><p>接口：把<code>fly()</code>从超类中取出，放入<code>Flyable接口</code>，使得会飞的鸭子实现接口。</p><p><strong>问题</strong>：重复代码变多，代码无法复用（如果有100个duck子类都要修改飞行的行为？？？）</p></li></ol><h3 id="1-软件开发的不变真理改变"><a class="markdownIt-Anchor" href="#1-软件开发的不变真理改变"></a> 1. 软件开发的不变真理——改变</h3><p>不管一开始软件设计的有多好，一段时间后，总是需要成长和改变。</p><h3 id="2-设计模式入门"><a class="markdownIt-Anchor" href="#2-设计模式入门"></a> 2. 设计模式入门</h3><p>继承的问题：让所有鸭子都有某些行为，不恰当</p><p>接口的问题：Java接口不具有实现代码，所以继承接口无法实现代码的复用。修改量大。</p><h4 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h4><p><font color=red><strong>设计原则</strong></font></p><p><strong>找到可能需要变化的地方，独立出来，不要和不需要变化的代码混在一起。</strong></p><p>把会变化的部分取出封装起来，改动和扩充时不会影响不需要变化的部分。</p><p>核心：<font color=red><strong>系统中某部分的改变不影响其他部分</strong></font></p><p>结果：改动引起的可能错误减少，系统更有弹性</p><h4 id="分开变化和不会变化的部分"><a class="markdownIt-Anchor" href="#分开变化和不会变化的部分"></a> 分开变化和不会变化的部分</h4><p>对于Duck，分离fly与quack，建立两组类，分别实现各自的动作</p><p>比如一组类中可以有“呱呱叫”，“吱吱叫”，“安静”</p><h4 id="设计鸭子的行为"><a class="markdownIt-Anchor" href="#设计鸭子的行为"></a> 设计鸭子的行为</h4><p>一切要由弹性。鸭子类中包含设定行为的方法，这样可以动态的改变实例的行为</p><p><font color=red><strong>设计原则</strong></font></p><p><strong>针对接口编程，而不是针对实现编程</strong></p><p>利用接口代表每个行为，由行为类而不是Duck类实现行为接口</p><p>比较：</p><p>​以前行为来自Duck超类，依赖于实现，无法更改行为</p><p>​现在使用接口表是的行为，特定的具体行为编写在了行为类中。</p><p>比如，FlyBehavior接口,以及它对应的类，负责实现具体的行为：</p><p>​实现复用，新增行为不会影响到已有的类</p><p><strong>针对接口编程的真正意思是针对超类型编程</strong>，这里的接口可以是interface构造，也可以是超类型编程。</p><p>关键在于多态。</p><h4 id="整合鸭子的行为"><a class="markdownIt-Anchor" href="#整合鸭子的行为"></a> 整合鸭子的行为</h4><h4 id="动态设定行为"><a class="markdownIt-Anchor" href="#动态设定行为"></a> 动态设定行为</h4><p>见代码</p><h4 id="封装行为的大局观"><a class="markdownIt-Anchor" href="#封装行为的大局观"></a> 封装行为的大局观</h4><p>鸭子的一组行为  --&gt; 一族算法（代表鸭子能做的事）</p><p>每一个鸭子都有一个（HAS-A）FlyBehavior和一个QuackBehavior，将飞行和叫声委托给它代为处理。</p><p>将两个类结合起来使用——<strong>组合</strong></p><p><font color=red><strong>设计原则</strong></font></p><p><strong>多用组合，少用继承</strong></p><p>使用继承具有很大的弹性，不仅可以将算法族封装成类，还可以在运行时动态地改变行为。</p><h4 id="第一个设计模式策略模式"><a class="markdownIt-Anchor" href="#第一个设计模式策略模式"></a> 第一个设计模式：策略模式</h4><p>定义了<strong>算法族</strong>，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p><h3 id="3-工具"><a class="markdownIt-Anchor" href="#3-工具"></a> 3. 工具</h3><table><thead><tr><th style="text-align:center">基础</th><th style="text-align:center">原则</th><th style="text-align:center">模式</th></tr></thead><tbody><tr><td style="text-align:center">抽象</td><td style="text-align:center">封装变化</td><td style="text-align:center">策略模式</td></tr><tr><td style="text-align:center">封装</td><td style="text-align:center">多用组合，少用继承</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">多态</td><td style="text-align:center">针对接口编程，不针对实现编程</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">继承</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="二-观察者模式"><a class="markdownIt-Anchor" href="#二-观察者模式"></a> 二、观察者模式</h2><p><strong>观察者模式</strong>定义了对象之间的一对多依赖。</p><p>这样一来，当一个状态改变时，它的所有依赖者都会收到通知并自动更新。</p>]]></content>
      
      
      <categories>
          
          <category> Design Pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Strategy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Github pages+Hexo 搭建个人博客</title>
      <link href="/Hexo/build-a-blog-with-hexo/"/>
      <url>/Hexo/build-a-blog-with-hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="github-pages-hexo-搭建个人博客"><a class="markdownIt-Anchor" href="#github-pages-hexo-搭建个人博客"></a> Github pages + Hexo 搭建个人博客</h1><p>2019年11月19日，我决定开始写<strong>博客</strong>，首先要用<em>github pages+hexo</em>搭建一个个人博客，其中的过程我就记录在这里面。</p><h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><ol><li>注册一个 GitHub 账户</li><li>安装 Node.js<br />下载链接<br /><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a><br />下面这个是中文网，对于国内用户来说下载速度非常快。<br /><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a><br />推荐菜鸟教程关于node的安装教程以及简易的语法介绍<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></li><li>安装git</li><li>markdown语法学习<br /><a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed</a></li><li>git语法学习<br />推荐廖雪峰的git教程<br /><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></li></ol><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>在终端检查node和npm的版本情况</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>然后输入命令安装hexo</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>我使用的是Mac电脑，在这一步出现了问题，终端显示如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rollbackFailedOptional verb npm-session</span><br></pre></td></tr></table></figure><p>然后我又等了一会儿，终端又报错了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules</span><br><span class="line">npm ERR! code EACCES</span><br><span class="line">npm ERR! syscall access</span><br><span class="line">npm ERR! path /usr/local/lib/node_modules</span><br><span class="line">npm ERR! errno -13</span><br><span class="line">npm ERR! Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;</span><br><span class="line">npm ERR!  [Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;] &#123;</span><br><span class="line">npm ERR!   stack: &quot;Error: EACCES: permission denied, access &apos;/usr/local/lib/node_modules&apos;&quot;,</span><br><span class="line">npm ERR!   errno: -13,</span><br><span class="line">npm ERR!   code: &apos;EACCES&apos;,</span><br><span class="line">npm ERR!   syscall: &apos;access&apos;,</span><br><span class="line">npm ERR!   path: &apos;/usr/local/lib/node_modules&apos;</span><br><span class="line">npm ERR! &#125;</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! The operation was rejected by your operating system.</span><br><span class="line">npm ERR! It is likely you do not have the permissions to access this file as the current user</span><br><span class="line">npm ERR! </span><br><span class="line">npm ERR! If you believe this might be a permissions issue, please double-check the</span><br><span class="line">npm ERR! permissions of the file and its containing directories, or try running</span><br><span class="line">npm ERR! the command again as root/Administrator.</span><br></pre></td></tr></table></figure><p>根据官方文档，如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code>权限错误，要遵循由<a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally#reinstall-npm-with-a-node-version-manager" target="_blank" rel="noopener">npmjs</a>发布的指导修复该问题。强烈建议不要使用 root、sudo 等方法覆盖权限。<br />根据要求，下载了<strong>nvm</strong>，并且在终端利用nvm下载了最新版本的node和更新了npm后，hexo下载成功了。（以下是下载和使用nvm的教程链接）<br /><a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a>.</p><h2 id="建站"><a class="markdownIt-Anchor" href="#建站"></a> 建站</h2><p>输入以下命令hexo就会出现在指定的文件夹中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>如果出现错误</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-bash: syntax error near unexpected token `newline<span class="string">'</span></span><br></pre></td></tr></table></figure><p>这是占位符的问题，将第一行命令的&lt;&gt;去除，再重新输入即可。</p><p>到此，建站的基本操作就完成了。</p><p>界面的设计等就可以由自己来操作了。放一个hexo的官方网站供大家参考。<br /><a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration</a></p><h2 id="创建github远程仓库"><a class="markdownIt-Anchor" href="#创建github远程仓库"></a> 创建Github远程仓库</h2><p><a href="http://xn--github-vy7ix4bc60aha9370a9hgi3dqx5cq4zcte.github.io" target="_blank" rel="noopener">注意仓库名为github的用户名.github.io</a>，勾选readme<br /><img src="https://img-blog.csdnimg.cn/20191123194438458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dhbGFoYWR6aG91,size_16,color_FFFFFF,t_70" alt="" /></p><p>创建之后，进入仓库，点击<strong>Settings</strong>按钮，然后翻到GitHub Pages的部分，点击网页链接，就能够看到一个简易的网页了。</p><p><img src="https://img-blog.csdnimg.cn/20191123194913735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dhbGFoYWR6aG91,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="部署hexo"><a class="markdownIt-Anchor" href="#部署hexo"></a> 部署hexo</h2><p>进入本地的hexo文件，找到 <strong>_config.yml</strong>，打开后翻到最后，修改成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">     gitHub: git<span class="meta">@github</span>.com:你的GitHub用户名/你的GitHub用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>repo后面的内容要修改成自己github仓库的SSH密匙。</p><p>然后在终端中输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>开始安装hexo-deploy-git，安装完成后，开始部署，在终端中输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>部署完成。</p><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>这个时候，再次进入刚刚进入过的网页链接，就会看到一个船新版本的界面，也就是本地的hexo库已经部署到github上了。</p><p><img src="https://img-blog.csdnimg.cn/20191123195408260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dhbGFoYWR6aG91,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo写作</title>
      <link href="/Hexo/writing-with-hexo/"/>
      <url>/Hexo/writing-with-hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo写作"><a class="markdownIt-Anchor" href="#hexo写作"></a> Hexo写作</h1><p>本文介绍了一些基本的Hexo配置和使用hexo+GitHub写作的流程。</p><a id="more"></a><h3 id="1-hexo基本命令"><a class="markdownIt-Anchor" href="#1-hexo基本命令"></a> 1. Hexo基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g = hexo generate  #生成</span><br><span class="line">hexo s = hexo server  #启动本地预览</span><br><span class="line">hexo d = hexo deploy  #远程部署</span><br><span class="line"></span><br><span class="line">hexo n "文章标题" = hexo new "文章标题"  #新建一篇博文</span><br></pre></td></tr></table></figure><h3 id="2-整体配置"><a class="markdownIt-Anchor" href="#2-整体配置"></a> 2. 整体配置</h3><p><code>\hexo\_config.yml</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Site</span></span><br><span class="line">title:  # 网站名，标签页显示</span><br><span class="line">subtitle:  # 副标题，网站名下显示</span><br><span class="line">description:  # 网站描述，便于搜索</span><br><span class="line">keywords:</span><br><span class="line">author: # 作者</span><br><span class="line">language: zh-CN # 中文</span><br><span class="line">timezone: Asia/Shanghai # 时区</span><br></pre></td></tr></table></figure><h3 id="3-更换主题"><a class="markdownIt-Anchor" href="#3-更换主题"></a> 3. 更换主题</h3><p>推荐使用<code>melody</code>，有完整的中文教程</p><p><a href="%5Bhttps://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html#%E5%AE%89%E8%A3%85%5D(https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html#%E5%AE%89%E8%A3%85)">hexo-theme-melody快速开始</a></p><p>相关操作见教程。</p><h3 id="4-写作步骤"><a class="markdownIt-Anchor" href="#4-写作步骤"></a> 4. 写作步骤</h3><ol><li><p>新建文章</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new "title"</span><br></pre></td></tr></table></figure></li><li><p>写作</p><p><code>\hexo\source\_post</code>中找到<code>title.md</code>，使用<code>typora</code>打开</p><p>注意文章的<code>tags</code>格式是<code>[]</code></p><p>在信息栏填写<code>top_img</code>信息可以自定义该页图片情况，如<code>false</code>表示不显示</p><p><code>文章中&lt;!-- more --&gt;</code>之前的部分会显示在主页上，并出现<code>Read more</code>按钮，点击阅读更多内容</p></li><li><p>预览</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></li><li><p>同步到远程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-问题"><a class="markdownIt-Anchor" href="#5-问题"></a> 5.  问题</h3><ol><li>Template render error: (unknown path)</li></ol><p>在命令行输入<code>hexo -g</code>后报错，原因在于文章内容中有**{}**时，如果它没有被代码块包括，解析会出现错误，所以需要写成<code></code></p><ol start="2"><li>Permalink</li></ol><p>在文档名有中文的时候，默认的永久链接非常复杂，可以优化一下。</p><p>首先，在<code>scaffolds</code>的<code>post.md</code>中，加入<code>urlname</code>元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">urlname:</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br></pre></td></tr></table></figure><p>然后，在配置文件<code>_config.yml</code>中，将永久链接<code>permalink</code>的形式改为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: :category/:urlname/</span><br></pre></td></tr></table></figure><p>这样不仅可以自己设计链接，使得它变得简单，同时也利于区分。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习cpp</title>
      <link href="/C/basic/cpp-learning/"/>
      <url>/C/basic/cpp-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="c学习笔记"><a class="markdownIt-Anchor" href="#c学习笔记"></a> C++学习笔记</h1><p>本文记录了C++的学习笔记，主要内容来自于MOOC北京大学课程程序设计与算法。</p><a id="more"></a><h1 id="一-变量"><a class="markdownIt-Anchor" href="#一-变量"></a> 一、 变量</h1><h2 id="1-用sizeof运算符求某一类型或变量占据的字节数"><a class="markdownIt-Anchor" href="#1-用sizeof运算符求某一类型或变量占据的字节数"></a> 1. 用sizeof运算符求某一类型或变量占据的字节数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// sizeof运算符可以求变量占据的字节数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 未初始化的变量，其值是不确定的</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-数据类型的自动转换"><a class="markdownIt-Anchor" href="#2-数据类型的自动转换"></a> 2. 数据类型的自动转换</h2><h3 id="1-数"><a class="markdownIt-Anchor" href="#1-数"></a> 1. 数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">11.34</span>; <span class="comment">// 11.34被自动转化为11后赋值给a</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">double</span> d = b; <span class="comment">// d的值是30.0</span></span><br></pre></td></tr></table></figure><h3 id="2-字符类型与整型"><a class="markdownIt-Anchor" href="#2-字符类型与整型"></a> 2. 字符类型与整型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, k); <span class="comment">// 输出97，即a的ASCII码</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">98</span>;</span><br><span class="line"><span class="keyword">char</span> k = n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, k); <span class="comment">// 输出b</span></span><br></pre></td></tr></table></figure><h2 id="3-输入和输出"><a class="markdownIt-Anchor" href="#3-输入和输出"></a> 3. 输入和输出</h2><h4 id="1-scanf和printf"><a class="markdownIt-Anchor" href="#1-scanf和printf"></a> 1. scanf和printf</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; //使用scanf和printf时需要使用该库</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">float</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%c%f"</span>, &amp;n, &amp;c, &amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %c %f\n"</span>, n, c, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用scanf可以一次读入多个不同类型的变量，输入各项用空格隔开<br />注意在输入<strong>字符</strong>时，不会跳过空格（空格也会被当做字符读入）<br />输入其它数据时，会跳过空格</p><h4 id="2-cin和cout"><a class="markdownIt-Anchor" href="#2-cin和cout"></a> 2. cin和cout</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c=<span class="built_in">cin</span>.get()) != EOF) &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>) c; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用cin读入所有字符，包括空格和回车，EOF<br />Mac（ctrl+D停止输入，ctrl+C停止程序)<br />windows ctrl+Z停止</p><h4 id="3-cincout-scanfprintf-比较"><a class="markdownIt-Anchor" href="#3-cincout-scanfprintf-比较"></a> 3. cin&amp;cout / scanf&amp;printf 比较</h4><ul><li>cin，cout速度慢，输入输出数据量大时用scanf/printf</li><li>一个程序不要同时出现cin和scanf，cout和prinf</li></ul><h2 id="4-运算"><a class="markdownIt-Anchor" href="#4-运算"></a> 4. 运算</h2><ol><li>加、减、乘运算的溢出</li></ol><hr /><h1 id="二-函数"><a class="markdownIt-Anchor" href="#二-函数"></a> 二、函数</h1><h3 id="1-数组作为函数的参数传递"><a class="markdownIt-Anchor" href="#1-数组作为函数的参数传递"></a> 1. 数组作为函数的参数传递</h3><p>数组作为函数的参数时，是传引用的，即<strong>形参数组改变了，实参数组也会改变</strong></p><p>二维数组作为函数的形参时，<strong>必须写明函数有多少列</strong>，不要写明有多少行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">5</span>])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须要写明列数，编译器才能够根据下标算出元素的地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\color&#123;#F00&#125;&#123;a[i][j]的地址 = 数组首地址 + i \times N \times sizeof(a[0][0]) + j \times sizeof(a[0][0])&#125;$ (N是数组列数)</span><br></pre></td></tr></table></figure><p>形参数组的首地址就是实参数组的首地址</p><h1 id="三-字符串"><a class="markdownIt-Anchor" href="#三-字符串"></a> 三、字符串</h1><h2 id="1-字符串的形式"><a class="markdownIt-Anchor" href="#1-字符串的形式"></a> 1. 字符串的形式</h2><h3 id="1字符串常量"><a class="markdownIt-Anchor" href="#1字符串常量"></a> （1）字符串常量</h3><p>用双引号括起来的，如&quot;China&quot;, “C++ program”.</p><p>字符串常量占据<strong>内存</strong>的字节数等于字符中字符数目加1，结尾多出字符’\0’.</p><p><font color=#F00>但是字符串的长度不包含’\0’</font></p><p>&quot;&quot;也是合法的·1字符串常量，称为空串，仍然占据一个字节的内存空间，存放’\0’</p><h3 id="2存放于字符数组中以0结尾"><a class="markdownIt-Anchor" href="#2存放于字符数组中以0结尾"></a> （2）存放于字符数组中，以’\0’结尾</h3><p>用一维char数组存放字符串，结尾是’\0’，数组元素个数至少为<font color=#F00>字符串长度+1</font>。</p><p>用cin、scanf将字符串读入字符数组时，会自动在字符数组中字符串的末尾加上’\0’。</p><h3 id="3string对象"><a class="markdownIt-Anchor" href="#3string对象"></a> （3）string对象。</h3><p>string是C++标准模板库里的一个类，专门用于处理字符串</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
